{
  "version": 3,
  "sources": ["../../../../.yarn/cache/@babel-runtime-npm-7.26.0-9afa3c4ef6-12c01357e0.zip/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js", "../../../../.yarn/cache/@babel-runtime-npm-7.26.0-9afa3c4ef6-12c01357e0.zip/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js", "../../../../.yarn/cache/@babel-runtime-npm-7.26.0-9afa3c4ef6-12c01357e0.zip/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelperLoose.js", "../../../../.yarn/cache/@babel-runtime-npm-7.26.0-9afa3c4ef6-12c01357e0.zip/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js", "browser-external:path", "../../../../.yarn/cache/source-map-npm-0.5.7-7c3f035429-904e767bb9.zip/node_modules/source-map/lib/base64.js", "../../../../.yarn/cache/source-map-npm-0.5.7-7c3f035429-904e767bb9.zip/node_modules/source-map/lib/base64-vlq.js", "../../../../.yarn/cache/source-map-npm-0.5.7-7c3f035429-904e767bb9.zip/node_modules/source-map/lib/util.js", "../../../../.yarn/cache/source-map-npm-0.5.7-7c3f035429-904e767bb9.zip/node_modules/source-map/lib/array-set.js", "../../../../.yarn/cache/source-map-npm-0.5.7-7c3f035429-904e767bb9.zip/node_modules/source-map/lib/mapping-list.js", "../../../../.yarn/cache/source-map-npm-0.5.7-7c3f035429-904e767bb9.zip/node_modules/source-map/lib/source-map-generator.js", "../../../../.yarn/cache/source-map-npm-0.5.7-7c3f035429-904e767bb9.zip/node_modules/source-map/lib/binary-search.js", "../../../../.yarn/cache/source-map-npm-0.5.7-7c3f035429-904e767bb9.zip/node_modules/source-map/lib/quick-sort.js", "../../../../.yarn/cache/source-map-npm-0.5.7-7c3f035429-904e767bb9.zip/node_modules/source-map/lib/source-map-consumer.js", "../../../../.yarn/cache/source-map-npm-0.5.7-7c3f035429-904e767bb9.zip/node_modules/source-map/lib/source-node.js", "../../../../.yarn/cache/source-map-npm-0.5.7-7c3f035429-904e767bb9.zip/node_modules/source-map/source-map.js", "browser-external:fs", "../../../../.yarn/cache/convert-source-map-npm-1.9.0-e294555f4b-281da55454.zip/node_modules/convert-source-map/index.js", "../../../../.yarn/cache/find-root-npm-1.1.0-a16a94005f-1abc7f3bf2.zip/node_modules/find-root/index.js", "../../../../.yarn/cache/escape-string-regexp-npm-4.0.0-4b531d8d59-9497d4dd30.zip/node_modules/escape-string-regexp/index.js", "browser-external:assert", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/utils/shallowEqual.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/utils/deprecationWarning.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/validators/generated/index.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/validators/matchesPattern.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/validators/buildMatchMemberExpression.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/validators/react/isReactComponent.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/validators/react/isCompatTag.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/validators/isType.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/validators/isPlaceholderType.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/validators/is.ts", "../../../../.yarn/cache/@babel-helper-validator-identifier-npm-7.25.9-2634b947a4-4fc6f83017.zip/node_modules/@babel/helper-validator-identifier/src/identifier.ts", "../../../../.yarn/cache/@babel-helper-validator-identifier-npm-7.25.9-2634b947a4-4fc6f83017.zip/node_modules/@babel/helper-validator-identifier/src/keyword.ts", "../../../../.yarn/cache/@babel-helper-validator-identifier-npm-7.25.9-2634b947a4-4fc6f83017.zip/node_modules/@babel/helper-validator-identifier/src/index.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/validators/isValidIdentifier.ts", "../../../../.yarn/cache/@babel-helper-string-parser-npm-7.25.9-eade578078-7244b45d8e.zip/node_modules/@babel/helper-string-parser/src/index.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/constants/index.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/definitions/utils.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/definitions/core.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/definitions/flow.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/definitions/jsx.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/definitions/placeholders.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/definitions/misc.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/definitions/experimental.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/definitions/typescript.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/definitions/deprecated-aliases.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/definitions/index.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/validators/validate.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/builders/generated/index.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/utils/react/cleanJSXElementLiteralChild.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/builders/react/buildChildren.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/validators/isNode.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/asserts/assertNode.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/asserts/generated/index.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/builders/flow/createTypeAnnotationBasedOnTypeof.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/modifications/flow/removeTypeDuplicates.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/builders/flow/createFlowUnionType.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/modifications/typescript/removeTypeDuplicates.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/builders/typescript/createTSUnionType.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/builders/generated/uppercase.js", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/builders/productions.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/clone/cloneNode.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/clone/clone.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/clone/cloneDeep.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/clone/cloneDeepWithoutLoc.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/clone/cloneWithoutLoc.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/comments/addComments.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/comments/addComment.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/utils/inherit.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/comments/inheritInnerComments.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/comments/inheritLeadingComments.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/comments/inheritTrailingComments.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/comments/inheritsComments.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/comments/removeComments.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/constants/generated/index.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/converters/toBlock.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/converters/ensureBlock.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/converters/toIdentifier.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/converters/toBindingIdentifierName.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/converters/toComputedKey.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/converters/toExpression.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/traverse/traverseFast.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/modifications/removeProperties.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/modifications/removePropertiesDeep.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/converters/toKeyAlias.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/converters/toStatement.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/converters/valueToNode.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/modifications/appendToMemberExpression.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/modifications/inherits.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/modifications/prependToMemberExpression.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/retrievers/getAssignmentIdentifiers.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/retrievers/getBindingIdentifiers.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/retrievers/getOuterBindingIdentifiers.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/retrievers/getFunctionName.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/traverse/traverse.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/validators/isBinding.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/validators/isLet.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/validators/isBlockScoped.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/validators/isImmutable.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/validators/isNodesEquivalent.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/validators/isReferenced.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/validators/isScope.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/validators/isSpecifierDefault.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/validators/isValidES3Identifier.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/validators/isVar.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/converters/gatherSequenceExpressions.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/converters/toSequenceExpression.ts", "../../../../.yarn/cache/@babel-types-npm-7.26.3-348c6bde15-966c5242c5.zip/node_modules/@babel/types/src/index.ts", "../../../../.yarn/cache/@babel-helper-module-imports-npm-7.25.9-b86e31bde9-078d3c2b45.zip/node_modules/@babel/helper-module-imports/src/import-builder.ts", "../../../../.yarn/cache/@babel-helper-module-imports-npm-7.25.9-b86e31bde9-078d3c2b45.zip/node_modules/@babel/helper-module-imports/src/is-module.ts", "../../../../.yarn/cache/@babel-helper-module-imports-npm-7.25.9-b86e31bde9-078d3c2b45.zip/node_modules/@babel/helper-module-imports/src/import-injector.ts", "../../../../.yarn/cache/@babel-helper-module-imports-npm-7.25.9-b86e31bde9-078d3c2b45.zip/node_modules/@babel/helper-module-imports/src/index.ts", "browser-external:os", "../../../../.yarn/cache/resolve-patch-4254c24959-0446f02443.zip/node_modules/resolve/lib/homedir.js", "../../../../.yarn/cache/resolve-patch-4254c24959-0446f02443.zip/node_modules/resolve/lib/caller.js", "../../../../.yarn/cache/path-parse-npm-1.0.7-09564527b7-11ce261f9d.zip/node_modules/path-parse/index.js", "../../../../.yarn/cache/resolve-patch-4254c24959-0446f02443.zip/node_modules/resolve/lib/node-modules-paths.js", "browser-external:module", "../../../../.yarn/cache/resolve-patch-4254c24959-0446f02443.zip/node_modules/resolve/lib/normalize-options.js", "../../../../.yarn/cache/function-bind-npm-1.1.2-7a55be9b03-d8680ee1e5.zip/node_modules/function-bind/implementation.js", "../../../../.yarn/cache/function-bind-npm-1.1.2-7a55be9b03-d8680ee1e5.zip/node_modules/function-bind/index.js", "../../../../.yarn/cache/hasown-npm-2.0.2-80fe6c9901-3769d43470.zip/node_modules/hasown/index.js", "../../../../.yarn/cache/is-core-module-npm-2.15.1-34c73a6cbd-53432f10c6.zip/node_modules/is-core-module/core.json", "../../../../.yarn/cache/is-core-module-npm-2.15.1-34c73a6cbd-53432f10c6.zip/node_modules/is-core-module/index.js", "../../../../.yarn/cache/resolve-patch-4254c24959-0446f02443.zip/node_modules/resolve/lib/async.js", "../../../../.yarn/cache/resolve-patch-4254c24959-0446f02443.zip/node_modules/resolve/lib/core.json", "../../../../.yarn/cache/resolve-patch-4254c24959-0446f02443.zip/node_modules/resolve/lib/core.js", "../../../../.yarn/cache/resolve-patch-4254c24959-0446f02443.zip/node_modules/resolve/lib/is-core.js", "../../../../.yarn/cache/resolve-patch-4254c24959-0446f02443.zip/node_modules/resolve/lib/sync.js", "../../../../.yarn/cache/resolve-patch-4254c24959-0446f02443.zip/node_modules/resolve/index.js", "../../../../.yarn/cache/resolve-from-npm-4.0.0-f758ec21bf-8408eec31a.zip/node_modules/resolve-from/index.js", "../../../../.yarn/cache/callsites-npm-3.1.0-268f989910-fff9227740.zip/node_modules/callsites/index.js", "../../../../.yarn/cache/parent-module-npm-1.0.1-1fae11b095-c63d6e8000.zip/node_modules/parent-module/index.js", "../../../../.yarn/cache/import-fresh-npm-3.3.0-3e34265ca9-7f882953aa.zip/node_modules/import-fresh/index.js", "browser-external:util", "../../../../.yarn/cache/is-arrayish-npm-0.2.1-23927dfb15-e7fb686a73.zip/node_modules/is-arrayish/index.js", "../../../../.yarn/cache/error-ex-npm-1.3.2-5654f80c0f-ba827f8936.zip/node_modules/error-ex/index.js", "../../../../.yarn/cache/json-parse-even-better-errors-npm-2.3.1-144d62256e-140932564c.zip/node_modules/json-parse-even-better-errors/index.js", "../../../../.yarn/cache/lines-and-columns-npm-1.2.4-d6c7cc5799-3da6ee62d4.zip/node_modules/lines-and-columns/build/index.js", "../../../../.yarn/cache/picocolors-npm-1.1.1-4fede47cf1-e2e3e8170a.zip/node_modules/picocolors/picocolors.browser.js", "../../../../.yarn/cache/js-tokens-npm-4.0.0-0ac852e9e2-e248708d37.zip/node_modules/js-tokens/index.js", "../../../../.yarn/cache/@babel-code-frame-npm-7.26.2-4902b56813-7d79621a68.zip/node_modules/@babel/code-frame/src/defs.ts", "../../../../.yarn/cache/@babel-code-frame-npm-7.26.2-4902b56813-7d79621a68.zip/node_modules/@babel/code-frame/src/highlight.ts", "../../../../.yarn/cache/@babel-code-frame-npm-7.26.2-4902b56813-7d79621a68.zip/node_modules/@babel/code-frame/src/index.ts", "../../../../.yarn/cache/parse-json-npm-5.2.0-00a63b1199-77947f2253.zip/node_modules/parse-json/index.js", "../../../../.yarn/cache/yaml-npm-1.10.2-0e780aebdf-5c28b9eb7a.zip/node_modules/yaml/browser/dist/PlainValue-b8036b75.js", "../../../../.yarn/cache/yaml-npm-1.10.2-0e780aebdf-5c28b9eb7a.zip/node_modules/yaml/browser/dist/parse-cst.js", "../../../../.yarn/cache/yaml-npm-1.10.2-0e780aebdf-5c28b9eb7a.zip/node_modules/yaml/browser/dist/resolveSeq-492ab440.js", "../../../../.yarn/cache/yaml-npm-1.10.2-0e780aebdf-5c28b9eb7a.zip/node_modules/yaml/browser/dist/warnings-df54cb69.js", "../../../../.yarn/cache/yaml-npm-1.10.2-0e780aebdf-5c28b9eb7a.zip/node_modules/yaml/browser/dist/Schema-e94716c8.js", "../../../../.yarn/cache/yaml-npm-1.10.2-0e780aebdf-5c28b9eb7a.zip/node_modules/yaml/browser/dist/index.js", "../../../../.yarn/cache/yaml-npm-1.10.2-0e780aebdf-5c28b9eb7a.zip/node_modules/yaml/browser/index.js", "../../../../.yarn/cache/cosmiconfig-npm-7.1.0-13a5090bcd-b923ff6af5.zip/node_modules/cosmiconfig/src/loaders.ts", "../../../../.yarn/cache/cosmiconfig-npm-7.1.0-13a5090bcd-b923ff6af5.zip/node_modules/cosmiconfig/src/getPropertyByPath.ts", "../../../../.yarn/cache/cosmiconfig-npm-7.1.0-13a5090bcd-b923ff6af5.zip/node_modules/cosmiconfig/src/ExplorerBase.ts", "../../../../.yarn/cache/cosmiconfig-npm-7.1.0-13a5090bcd-b923ff6af5.zip/node_modules/cosmiconfig/src/readFile.ts", "../../../../.yarn/cache/cosmiconfig-npm-7.1.0-13a5090bcd-b923ff6af5.zip/node_modules/cosmiconfig/src/cacheWrapper.ts", "../../../../.yarn/cache/path-type-npm-4.0.0-10d47fc86a-666f6973f3.zip/node_modules/path-type/index.js", "../../../../.yarn/cache/cosmiconfig-npm-7.1.0-13a5090bcd-b923ff6af5.zip/node_modules/cosmiconfig/src/getDirectory.ts", "../../../../.yarn/cache/cosmiconfig-npm-7.1.0-13a5090bcd-b923ff6af5.zip/node_modules/cosmiconfig/src/Explorer.ts", "../../../../.yarn/cache/cosmiconfig-npm-7.1.0-13a5090bcd-b923ff6af5.zip/node_modules/cosmiconfig/src/ExplorerSync.ts", "../../../../.yarn/cache/cosmiconfig-npm-7.1.0-13a5090bcd-b923ff6af5.zip/node_modules/cosmiconfig/dist/types.js", "../../../../.yarn/cache/cosmiconfig-npm-7.1.0-13a5090bcd-b923ff6af5.zip/node_modules/cosmiconfig/src/index.ts", "../../../../.yarn/cache/babel-plugin-macros-npm-3.1.0-320e781f4e-c6dfb15de9.zip/node_modules/babel-plugin-macros/dist/index.js", "../../../../.yarn/cache/@emotion-babel-plugin-npm-11.13.5-ca65815e43-8ccbfec7de.zip/node_modules/@emotion/babel-plugin/dist/emotion-babel-plugin.esm.js", "../../../../.yarn/__virtual__/@emotion-styled-virtual-2965579ce9/0/cache/@emotion-styled-npm-11.14.0-36f2daa0c9-20aa5c488e.zip/node_modules/@emotion/styled/macro.js"],
  "sourcesContent": ["function _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\nexport { _arrayLikeToArray as default };", "import arrayLikeToArray from \"./arrayLikeToArray.js\";\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? arrayLikeToArray(r, a) : void 0;\n  }\n}\nexport { _unsupportedIterableToArray as default };", "import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nfunction _createForOfIteratorHelperLoose(r, e) {\n  var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (t) return (t = t.call(r)).next.bind(t);\n  if (Array.isArray(r) || (t = unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) {\n    t && (r = t);\n    var o = 0;\n    return function () {\n      return o >= r.length ? {\n        done: !0\n      } : {\n        done: !1,\n        value: r[o++]\n      };\n    };\n  }\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nexport { _createForOfIteratorHelperLoose as default };", "function _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (e.includes(n)) continue;\n    t[n] = r[n];\n  }\n  return t;\n}\nexport { _objectWithoutPropertiesLoose as default };", "module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"path\" has been externalized for browser compatibility. Cannot access \"path.${key}\" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */\nexports.encode = function (number) {\n  if (0 <= number && number < intToCharMap.length) {\n    return intToCharMap[number];\n  }\n  throw new TypeError(\"Must be between 0 and 63: \" + number);\n};\n\n/**\n * Decode a single base 64 character code digit to an integer. Returns -1 on\n * failure.\n */\nexports.decode = function (charCode) {\n  var bigA = 65;     // 'A'\n  var bigZ = 90;     // 'Z'\n\n  var littleA = 97;  // 'a'\n  var littleZ = 122; // 'z'\n\n  var zero = 48;     // '0'\n  var nine = 57;     // '9'\n\n  var plus = 43;     // '+'\n  var slash = 47;    // '/'\n\n  var littleOffset = 26;\n  var numberOffset = 52;\n\n  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n  if (bigA <= charCode && charCode <= bigZ) {\n    return (charCode - bigA);\n  }\n\n  // 26 - 51: abcdefghijklmnopqrstuvwxyz\n  if (littleA <= charCode && charCode <= littleZ) {\n    return (charCode - littleA + littleOffset);\n  }\n\n  // 52 - 61: 0123456789\n  if (zero <= charCode && charCode <= nine) {\n    return (charCode - zero + numberOffset);\n  }\n\n  // 62: +\n  if (charCode == plus) {\n    return 62;\n  }\n\n  // 63: /\n  if (charCode == slash) {\n    return 63;\n  }\n\n  // Invalid base64 digit.\n  return -1;\n};\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar base64 = require('./base64');\n\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\n\nvar VLQ_BASE_SHIFT = 5;\n\n// binary: 100000\nvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n// binary: 011111\nvar VLQ_BASE_MASK = VLQ_BASE - 1;\n\n// binary: 100000\nvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */\nfunction toVLQSigned(aValue) {\n  return aValue < 0\n    ? ((-aValue) << 1) + 1\n    : (aValue << 1) + 0;\n}\n\n/**\n * Converts to a two-complement value from a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n */\nfunction fromVLQSigned(aValue) {\n  var isNegative = (aValue & 1) === 1;\n  var shifted = aValue >> 1;\n  return isNegative\n    ? -shifted\n    : shifted;\n}\n\n/**\n * Returns the base 64 VLQ encoded value.\n */\nexports.encode = function base64VLQ_encode(aValue) {\n  var encoded = \"\";\n  var digit;\n\n  var vlq = toVLQSigned(aValue);\n\n  do {\n    digit = vlq & VLQ_BASE_MASK;\n    vlq >>>= VLQ_BASE_SHIFT;\n    if (vlq > 0) {\n      // There are still more digits in this value, so we must make sure the\n      // continuation bit is marked.\n      digit |= VLQ_CONTINUATION_BIT;\n    }\n    encoded += base64.encode(digit);\n  } while (vlq > 0);\n\n  return encoded;\n};\n\n/**\n * Decodes the next base 64 VLQ value from the given string and returns the\n * value and the rest of the string via the out parameter.\n */\nexports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n  var strLen = aStr.length;\n  var result = 0;\n  var shift = 0;\n  var continuation, digit;\n\n  do {\n    if (aIndex >= strLen) {\n      throw new Error(\"Expected more digits in base 64 VLQ value.\");\n    }\n\n    digit = base64.decode(aStr.charCodeAt(aIndex++));\n    if (digit === -1) {\n      throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n    }\n\n    continuation = !!(digit & VLQ_CONTINUATION_BIT);\n    digit &= VLQ_BASE_MASK;\n    result = result + (digit << shift);\n    shift += VLQ_BASE_SHIFT;\n  } while (continuation);\n\n  aOutParam.value = fromVLQSigned(result);\n  aOutParam.rest = aIndex;\n};\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  } else {\n    throw new Error('\"' + aName + '\" is a required argument.');\n  }\n}\nexports.getArg = getArg;\n\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.]*)(?::(\\d+))?(\\S*)$/;\nvar dataUrlRegexp = /^data:.+\\,.+$/;\n\nfunction urlParse(aUrl) {\n  var match = aUrl.match(urlRegexp);\n  if (!match) {\n    return null;\n  }\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\nexports.urlParse = urlParse;\n\nfunction urlGenerate(aParsedUrl) {\n  var url = '';\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + ':';\n  }\n  url += '//';\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + '@';\n  }\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port\n  }\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n  return url;\n}\nexports.urlGenerate = urlGenerate;\n\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\nfunction normalize(aPath) {\n  var path = aPath;\n  var url = urlParse(aPath);\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n    path = url.path;\n  }\n  var isAbsolute = exports.isAbsolute(path);\n\n  var parts = path.split(/\\/+/);\n  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n    part = parts[i];\n    if (part === '.') {\n      parts.splice(i, 1);\n    } else if (part === '..') {\n      up++;\n    } else if (up > 0) {\n      if (part === '') {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n  path = parts.join('/');\n\n  if (path === '') {\n    path = isAbsolute ? '/' : '.';\n  }\n\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n  return path;\n}\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n  var aPathUrl = urlParse(aPath);\n  var aRootUrl = urlParse(aRoot);\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || '/';\n  }\n\n  // `join(foo, '//www.example.org')`\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n    return urlGenerate(aPathUrl);\n  }\n\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  }\n\n  // `join('http://', 'www.example.com')`\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n\n  var joined = aPath.charAt(0) === '/'\n    ? aPath\n    : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n  return joined;\n}\nexports.join = join;\n\nexports.isAbsolute = function (aPath) {\n  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);\n};\n\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  aRoot = aRoot.replace(/\\/$/, '');\n\n  // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n  var level = 0;\n  while (aPath.indexOf(aRoot + '/') !== 0) {\n    var index = aRoot.lastIndexOf(\"/\");\n    if (index < 0) {\n      return aPath;\n    }\n\n    // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n    aRoot = aRoot.slice(0, index);\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n\n    ++level;\n  }\n\n  // Make sure we add a \"../\" for each component we removed from the root.\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\n\nvar supportsNullProto = (function () {\n  var obj = Object.create(null);\n  return !('__proto__' in obj);\n}());\n\nfunction identity (s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return '$' + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  var length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n    return false;\n  }\n\n  for (var i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp = mappingA.source - mappingB.source;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return mappingA.name - mappingB.name;\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\n\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = mappingA.source - mappingB.source;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return mappingA.name - mappingB.name;\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar has = Object.prototype.hasOwnProperty;\nvar hasNativeMap = typeof Map !== \"undefined\";\n\n/**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */\nfunction ArraySet() {\n  this._array = [];\n  this._set = hasNativeMap ? new Map() : Object.create(null);\n}\n\n/**\n * Static method for creating ArraySet instances from an existing array.\n */\nArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n  var set = new ArraySet();\n  for (var i = 0, len = aArray.length; i < len; i++) {\n    set.add(aArray[i], aAllowDuplicates);\n  }\n  return set;\n};\n\n/**\n * Return how many unique items are in this ArraySet. If duplicates have been\n * added, than those do not count towards the size.\n *\n * @returns Number\n */\nArraySet.prototype.size = function ArraySet_size() {\n  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;\n};\n\n/**\n * Add the given string to this set.\n *\n * @param String aStr\n */\nArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);\n  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);\n  var idx = this._array.length;\n  if (!isDuplicate || aAllowDuplicates) {\n    this._array.push(aStr);\n  }\n  if (!isDuplicate) {\n    if (hasNativeMap) {\n      this._set.set(aStr, idx);\n    } else {\n      this._set[sStr] = idx;\n    }\n  }\n};\n\n/**\n * Is the given string a member of this set?\n *\n * @param String aStr\n */\nArraySet.prototype.has = function ArraySet_has(aStr) {\n  if (hasNativeMap) {\n    return this._set.has(aStr);\n  } else {\n    var sStr = util.toSetString(aStr);\n    return has.call(this._set, sStr);\n  }\n};\n\n/**\n * What is the index of the given string in the array?\n *\n * @param String aStr\n */\nArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n  if (hasNativeMap) {\n    var idx = this._set.get(aStr);\n    if (idx >= 0) {\n        return idx;\n    }\n  } else {\n    var sStr = util.toSetString(aStr);\n    if (has.call(this._set, sStr)) {\n      return this._set[sStr];\n    }\n  }\n\n  throw new Error('\"' + aStr + '\" is not in the set.');\n};\n\n/**\n * What is the element at the given index?\n *\n * @param Number aIdx\n */\nArraySet.prototype.at = function ArraySet_at(aIdx) {\n  if (aIdx >= 0 && aIdx < this._array.length) {\n    return this._array[aIdx];\n  }\n  throw new Error('No element indexed by ' + aIdx);\n};\n\n/**\n * Returns the array representation of this set (which has the proper indices\n * indicated by indexOf). Note that this is a copy of the internal array used\n * for storing the members so that no one can mess with internal state.\n */\nArraySet.prototype.toArray = function ArraySet_toArray() {\n  return this._array.slice();\n};\n\nexports.ArraySet = ArraySet;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\n\n/**\n * Determine whether mappingB is after mappingA with respect to generated\n * position.\n */\nfunction generatedPositionAfter(mappingA, mappingB) {\n  // Optimized for most common case\n  var lineA = mappingA.generatedLine;\n  var lineB = mappingB.generatedLine;\n  var columnA = mappingA.generatedColumn;\n  var columnB = mappingB.generatedColumn;\n  return lineB > lineA || lineB == lineA && columnB >= columnA ||\n         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n}\n\n/**\n * A data structure to provide a sorted view of accumulated mappings in a\n * performance conscious manner. It trades a neglibable overhead in general\n * case for a large speedup in case of mappings being added in order.\n */\nfunction MappingList() {\n  this._array = [];\n  this._sorted = true;\n  // Serves as infimum\n  this._last = {generatedLine: -1, generatedColumn: 0};\n}\n\n/**\n * Iterate through internal items. This method takes the same arguments that\n * `Array.prototype.forEach` takes.\n *\n * NOTE: The order of the mappings is NOT guaranteed.\n */\nMappingList.prototype.unsortedForEach =\n  function MappingList_forEach(aCallback, aThisArg) {\n    this._array.forEach(aCallback, aThisArg);\n  };\n\n/**\n * Add the given source mapping.\n *\n * @param Object aMapping\n */\nMappingList.prototype.add = function MappingList_add(aMapping) {\n  if (generatedPositionAfter(this._last, aMapping)) {\n    this._last = aMapping;\n    this._array.push(aMapping);\n  } else {\n    this._sorted = false;\n    this._array.push(aMapping);\n  }\n};\n\n/**\n * Returns the flat, sorted array of mappings. The mappings are sorted by\n * generated position.\n *\n * WARNING: This method returns internal data without copying, for\n * performance. The return value must NOT be mutated, and should be treated as\n * an immutable borrow. If you want to take ownership, you must make your own\n * copy.\n */\nMappingList.prototype.toArray = function MappingList_toArray() {\n  if (!this._sorted) {\n    this._array.sort(util.compareByGeneratedPositionsInflated);\n    this._sorted = true;\n  }\n  return this._array;\n};\n\nexports.MappingList = MappingList;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar base64VLQ = require('./base64-vlq');\nvar util = require('./util');\nvar ArraySet = require('./array-set').ArraySet;\nvar MappingList = require('./mapping-list').MappingList;\n\n/**\n * An instance of the SourceMapGenerator represents a source map which is\n * being built incrementally. You may pass an object with the following\n * properties:\n *\n *   - file: The filename of the generated source.\n *   - sourceRoot: A root for all relative URLs in this source map.\n */\nfunction SourceMapGenerator(aArgs) {\n  if (!aArgs) {\n    aArgs = {};\n  }\n  this._file = util.getArg(aArgs, 'file', null);\n  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n  this._mappings = new MappingList();\n  this._sourcesContents = null;\n}\n\nSourceMapGenerator.prototype._version = 3;\n\n/**\n * Creates a new SourceMapGenerator based on a SourceMapConsumer\n *\n * @param aSourceMapConsumer The SourceMap.\n */\nSourceMapGenerator.fromSourceMap =\n  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n    var sourceRoot = aSourceMapConsumer.sourceRoot;\n    var generator = new SourceMapGenerator({\n      file: aSourceMapConsumer.file,\n      sourceRoot: sourceRoot\n    });\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      var newMapping = {\n        generated: {\n          line: mapping.generatedLine,\n          column: mapping.generatedColumn\n        }\n      };\n\n      if (mapping.source != null) {\n        newMapping.source = mapping.source;\n        if (sourceRoot != null) {\n          newMapping.source = util.relative(sourceRoot, newMapping.source);\n        }\n\n        newMapping.original = {\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        };\n\n        if (mapping.name != null) {\n          newMapping.name = mapping.name;\n        }\n      }\n\n      generator.addMapping(newMapping);\n    });\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        generator.setSourceContent(sourceFile, content);\n      }\n    });\n    return generator;\n  };\n\n/**\n * Add a single mapping from original source line and column to the generated\n * source's line and column for this source map being created. The mapping\n * object should have the following properties:\n *\n *   - generated: An object with the generated line and column positions.\n *   - original: An object with the original line and column positions.\n *   - source: The original source file (relative to the sourceRoot).\n *   - name: An optional original token name for this mapping.\n */\nSourceMapGenerator.prototype.addMapping =\n  function SourceMapGenerator_addMapping(aArgs) {\n    var generated = util.getArg(aArgs, 'generated');\n    var original = util.getArg(aArgs, 'original', null);\n    var source = util.getArg(aArgs, 'source', null);\n    var name = util.getArg(aArgs, 'name', null);\n\n    if (!this._skipValidation) {\n      this._validateMapping(generated, original, source, name);\n    }\n\n    if (source != null) {\n      source = String(source);\n      if (!this._sources.has(source)) {\n        this._sources.add(source);\n      }\n    }\n\n    if (name != null) {\n      name = String(name);\n      if (!this._names.has(name)) {\n        this._names.add(name);\n      }\n    }\n\n    this._mappings.add({\n      generatedLine: generated.line,\n      generatedColumn: generated.column,\n      originalLine: original != null && original.line,\n      originalColumn: original != null && original.column,\n      source: source,\n      name: name\n    });\n  };\n\n/**\n * Set the source content for a source file.\n */\nSourceMapGenerator.prototype.setSourceContent =\n  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n    var source = aSourceFile;\n    if (this._sourceRoot != null) {\n      source = util.relative(this._sourceRoot, source);\n    }\n\n    if (aSourceContent != null) {\n      // Add the source content to the _sourcesContents map.\n      // Create a new _sourcesContents map if the property is null.\n      if (!this._sourcesContents) {\n        this._sourcesContents = Object.create(null);\n      }\n      this._sourcesContents[util.toSetString(source)] = aSourceContent;\n    } else if (this._sourcesContents) {\n      // Remove the source file from the _sourcesContents map.\n      // If the _sourcesContents map is empty, set the property to null.\n      delete this._sourcesContents[util.toSetString(source)];\n      if (Object.keys(this._sourcesContents).length === 0) {\n        this._sourcesContents = null;\n      }\n    }\n  };\n\n/**\n * Applies the mappings of a sub-source-map for a specific source file to the\n * source map being generated. Each mapping to the supplied source file is\n * rewritten using the supplied source map. Note: The resolution for the\n * resulting mappings is the minimium of this map and the supplied map.\n *\n * @param aSourceMapConsumer The source map to be applied.\n * @param aSourceFile Optional. The filename of the source file.\n *        If omitted, SourceMapConsumer's file property will be used.\n * @param aSourceMapPath Optional. The dirname of the path to the source map\n *        to be applied. If relative, it is relative to the SourceMapConsumer.\n *        This parameter is needed when the two source maps aren't in the same\n *        directory, and the source map to be applied contains relative source\n *        paths. If so, those relative source paths need to be rewritten\n *        relative to the SourceMapGenerator.\n */\nSourceMapGenerator.prototype.applySourceMap =\n  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n    var sourceFile = aSourceFile;\n    // If aSourceFile is omitted, we will use the file property of the SourceMap\n    if (aSourceFile == null) {\n      if (aSourceMapConsumer.file == null) {\n        throw new Error(\n          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +\n          'or the source map\\'s \"file\" property. Both were omitted.'\n        );\n      }\n      sourceFile = aSourceMapConsumer.file;\n    }\n    var sourceRoot = this._sourceRoot;\n    // Make \"sourceFile\" relative if an absolute Url is passed.\n    if (sourceRoot != null) {\n      sourceFile = util.relative(sourceRoot, sourceFile);\n    }\n    // Applying the SourceMap can add and remove items from the sources and\n    // the names array.\n    var newSources = new ArraySet();\n    var newNames = new ArraySet();\n\n    // Find mappings for the \"sourceFile\"\n    this._mappings.unsortedForEach(function (mapping) {\n      if (mapping.source === sourceFile && mapping.originalLine != null) {\n        // Check if it can be mapped by the source map, then update the mapping.\n        var original = aSourceMapConsumer.originalPositionFor({\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        });\n        if (original.source != null) {\n          // Copy mapping\n          mapping.source = original.source;\n          if (aSourceMapPath != null) {\n            mapping.source = util.join(aSourceMapPath, mapping.source)\n          }\n          if (sourceRoot != null) {\n            mapping.source = util.relative(sourceRoot, mapping.source);\n          }\n          mapping.originalLine = original.line;\n          mapping.originalColumn = original.column;\n          if (original.name != null) {\n            mapping.name = original.name;\n          }\n        }\n      }\n\n      var source = mapping.source;\n      if (source != null && !newSources.has(source)) {\n        newSources.add(source);\n      }\n\n      var name = mapping.name;\n      if (name != null && !newNames.has(name)) {\n        newNames.add(name);\n      }\n\n    }, this);\n    this._sources = newSources;\n    this._names = newNames;\n\n    // Copy sourcesContents of applied map.\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aSourceMapPath != null) {\n          sourceFile = util.join(aSourceMapPath, sourceFile);\n        }\n        if (sourceRoot != null) {\n          sourceFile = util.relative(sourceRoot, sourceFile);\n        }\n        this.setSourceContent(sourceFile, content);\n      }\n    }, this);\n  };\n\n/**\n * A mapping can have one of the three levels of data:\n *\n *   1. Just the generated position.\n *   2. The Generated position, original position, and original source.\n *   3. Generated and original position, original source, as well as a name\n *      token.\n *\n * To maintain consistency, we validate that any new mapping being added falls\n * in to one of these categories.\n */\nSourceMapGenerator.prototype._validateMapping =\n  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,\n                                              aName) {\n    // When aOriginal is truthy but has empty values for .line and .column,\n    // it is most likely a programmer error. In this case we throw a very\n    // specific error message to try to guide them the right way.\n    // For example: https://github.com/Polymer/polymer-bundler/pull/519\n    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {\n        throw new Error(\n            'original.line and original.column are not numbers -- you probably meant to omit ' +\n            'the original mapping entirely and only map the generated position. If so, pass ' +\n            'null for the original mapping instead of an object with empty or null values.'\n        );\n    }\n\n    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n        && aGenerated.line > 0 && aGenerated.column >= 0\n        && !aOriginal && !aSource && !aName) {\n      // Case 1.\n      return;\n    }\n    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n             && aOriginal && 'line' in aOriginal && 'column' in aOriginal\n             && aGenerated.line > 0 && aGenerated.column >= 0\n             && aOriginal.line > 0 && aOriginal.column >= 0\n             && aSource) {\n      // Cases 2 and 3.\n      return;\n    }\n    else {\n      throw new Error('Invalid mapping: ' + JSON.stringify({\n        generated: aGenerated,\n        source: aSource,\n        original: aOriginal,\n        name: aName\n      }));\n    }\n  };\n\n/**\n * Serialize the accumulated mappings in to the stream of base 64 VLQs\n * specified by the source map format.\n */\nSourceMapGenerator.prototype._serializeMappings =\n  function SourceMapGenerator_serializeMappings() {\n    var previousGeneratedColumn = 0;\n    var previousGeneratedLine = 1;\n    var previousOriginalColumn = 0;\n    var previousOriginalLine = 0;\n    var previousName = 0;\n    var previousSource = 0;\n    var result = '';\n    var next;\n    var mapping;\n    var nameIdx;\n    var sourceIdx;\n\n    var mappings = this._mappings.toArray();\n    for (var i = 0, len = mappings.length; i < len; i++) {\n      mapping = mappings[i];\n      next = ''\n\n      if (mapping.generatedLine !== previousGeneratedLine) {\n        previousGeneratedColumn = 0;\n        while (mapping.generatedLine !== previousGeneratedLine) {\n          next += ';';\n          previousGeneratedLine++;\n        }\n      }\n      else {\n        if (i > 0) {\n          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n            continue;\n          }\n          next += ',';\n        }\n      }\n\n      next += base64VLQ.encode(mapping.generatedColumn\n                                 - previousGeneratedColumn);\n      previousGeneratedColumn = mapping.generatedColumn;\n\n      if (mapping.source != null) {\n        sourceIdx = this._sources.indexOf(mapping.source);\n        next += base64VLQ.encode(sourceIdx - previousSource);\n        previousSource = sourceIdx;\n\n        // lines are stored 0-based in SourceMap spec version 3\n        next += base64VLQ.encode(mapping.originalLine - 1\n                                   - previousOriginalLine);\n        previousOriginalLine = mapping.originalLine - 1;\n\n        next += base64VLQ.encode(mapping.originalColumn\n                                   - previousOriginalColumn);\n        previousOriginalColumn = mapping.originalColumn;\n\n        if (mapping.name != null) {\n          nameIdx = this._names.indexOf(mapping.name);\n          next += base64VLQ.encode(nameIdx - previousName);\n          previousName = nameIdx;\n        }\n      }\n\n      result += next;\n    }\n\n    return result;\n  };\n\nSourceMapGenerator.prototype._generateSourcesContent =\n  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n    return aSources.map(function (source) {\n      if (!this._sourcesContents) {\n        return null;\n      }\n      if (aSourceRoot != null) {\n        source = util.relative(aSourceRoot, source);\n      }\n      var key = util.toSetString(source);\n      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\n        ? this._sourcesContents[key]\n        : null;\n    }, this);\n  };\n\n/**\n * Externalize the source map.\n */\nSourceMapGenerator.prototype.toJSON =\n  function SourceMapGenerator_toJSON() {\n    var map = {\n      version: this._version,\n      sources: this._sources.toArray(),\n      names: this._names.toArray(),\n      mappings: this._serializeMappings()\n    };\n    if (this._file != null) {\n      map.file = this._file;\n    }\n    if (this._sourceRoot != null) {\n      map.sourceRoot = this._sourceRoot;\n    }\n    if (this._sourcesContents) {\n      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n    }\n\n    return map;\n  };\n\n/**\n * Render the source map being generated to a string.\n */\nSourceMapGenerator.prototype.toString =\n  function SourceMapGenerator_toString() {\n    return JSON.stringify(this.toJSON());\n  };\n\nexports.SourceMapGenerator = SourceMapGenerator;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nexports.GREATEST_LOWER_BOUND = 1;\nexports.LEAST_UPPER_BOUND = 2;\n\n/**\n * Recursive implementation of binary search.\n *\n * @param aLow Indices here and lower do not contain the needle.\n * @param aHigh Indices here and higher do not contain the needle.\n * @param aNeedle The element being searched for.\n * @param aHaystack The non-empty array being searched.\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n */\nfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n  // This function terminates when one of the following is true:\n  //\n  //   1. We find the exact element we are looking for.\n  //\n  //   2. We did not find the exact element, but we can return the index of\n  //      the next-closest element.\n  //\n  //   3. We did not find the exact element, and there is no next-closest\n  //      element than the one we are searching for, so we return -1.\n  var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n  var cmp = aCompare(aNeedle, aHaystack[mid], true);\n  if (cmp === 0) {\n    // Found the element we are looking for.\n    return mid;\n  }\n  else if (cmp > 0) {\n    // Our needle is greater than aHaystack[mid].\n    if (aHigh - mid > 1) {\n      // The element is in the upper half.\n      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // The exact needle element was not found in this haystack. Determine if\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return aHigh < aHaystack.length ? aHigh : -1;\n    } else {\n      return mid;\n    }\n  }\n  else {\n    // Our needle is less than aHaystack[mid].\n    if (mid - aLow > 1) {\n      // The element is in the lower half.\n      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return mid;\n    } else {\n      return aLow < 0 ? -1 : aLow;\n    }\n  }\n}\n\n/**\n * This is an implementation of binary search which will always try and return\n * the index of the closest element if there is no exact hit. This is because\n * mappings between original and generated line/col pairs are single points,\n * and there is an implicit region between each of them, so a miss just means\n * that you aren't on the very start of a region.\n *\n * @param aNeedle The element you are looking for.\n * @param aHaystack The array that is being searched.\n * @param aCompare A function which takes the needle and an element in the\n *     array and returns -1, 0, or 1 depending on whether the needle is less\n *     than, equal to, or greater than the element, respectively.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n */\nexports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n  if (aHaystack.length === 0) {\n    return -1;\n  }\n\n  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n  if (index < 0) {\n    return -1;\n  }\n\n  // We have found either the exact element, or the next-closest element than\n  // the one we are searching for. However, there may be more than one such\n  // element. Make sure we always return the smallest of these.\n  while (index - 1 >= 0) {\n    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n      break;\n    }\n    --index;\n  }\n\n  return index;\n};\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n// It turns out that some (most?) JavaScript engines don't self-host\n// `Array.prototype.sort`. This makes sense because C++ will likely remain\n// faster than JS when doing raw CPU-intensive sorting. However, when using a\n// custom comparator function, calling back and forth between the VM's C++ and\n// JIT'd JS is rather slow *and* loses JIT type information, resulting in\n// worse generated code for the comparator function than would be optimal. In\n// fact, when sorting with a comparator, these costs outweigh the benefits of\n// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n// a ~3500ms mean speed-up in `bench/bench.html`.\n\n/**\n * Swap the elements indexed by `x` and `y` in the array `ary`.\n *\n * @param {Array} ary\n *        The array.\n * @param {Number} x\n *        The index of the first item.\n * @param {Number} y\n *        The index of the second item.\n */\nfunction swap(ary, x, y) {\n  var temp = ary[x];\n  ary[x] = ary[y];\n  ary[y] = temp;\n}\n\n/**\n * Returns a random integer within the range `low .. high` inclusive.\n *\n * @param {Number} low\n *        The lower bound on the range.\n * @param {Number} high\n *        The upper bound on the range.\n */\nfunction randomIntInRange(low, high) {\n  return Math.round(low + (Math.random() * (high - low)));\n}\n\n/**\n * The Quick Sort algorithm.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n * @param {Number} p\n *        Start index of the array\n * @param {Number} r\n *        End index of the array\n */\nfunction doQuickSort(ary, comparator, p, r) {\n  // If our lower bound is less than our upper bound, we (1) partition the\n  // array into two pieces and (2) recurse on each half. If it is not, this is\n  // the empty array and our base case.\n\n  if (p < r) {\n    // (1) Partitioning.\n    //\n    // The partitioning chooses a pivot between `p` and `r` and moves all\n    // elements that are less than or equal to the pivot to the before it, and\n    // all the elements that are greater than it after it. The effect is that\n    // once partition is done, the pivot is in the exact place it will be when\n    // the array is put in sorted order, and it will not need to be moved\n    // again. This runs in O(n) time.\n\n    // Always choose a random pivot so that an input array which is reverse\n    // sorted does not cause O(n^2) running time.\n    var pivotIndex = randomIntInRange(p, r);\n    var i = p - 1;\n\n    swap(ary, pivotIndex, r);\n    var pivot = ary[r];\n\n    // Immediately after `j` is incremented in this loop, the following hold\n    // true:\n    //\n    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n    //\n    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n    for (var j = p; j < r; j++) {\n      if (comparator(ary[j], pivot) <= 0) {\n        i += 1;\n        swap(ary, i, j);\n      }\n    }\n\n    swap(ary, i + 1, j);\n    var q = i + 1;\n\n    // (2) Recurse on each half.\n\n    doQuickSort(ary, comparator, p, q - 1);\n    doQuickSort(ary, comparator, q + 1, r);\n  }\n}\n\n/**\n * Sort the given array in-place with the given comparator function.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n */\nexports.quickSort = function (ary, comparator) {\n  doQuickSort(ary, comparator, 0, ary.length - 1);\n};\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar binarySearch = require('./binary-search');\nvar ArraySet = require('./array-set').ArraySet;\nvar base64VLQ = require('./base64-vlq');\nvar quickSort = require('./quick-sort').quickSort;\n\nfunction SourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n  }\n\n  return sourceMap.sections != null\n    ? new IndexedSourceMapConsumer(sourceMap)\n    : new BasicSourceMapConsumer(sourceMap);\n}\n\nSourceMapConsumer.fromSourceMap = function(aSourceMap) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);\n}\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\n\n// `__generatedMappings` and `__originalMappings` are arrays that hold the\n// parsed mapping coordinates from the source map's \"mappings\" attribute. They\n// are lazily instantiated, accessed via the `_generatedMappings` and\n// `_originalMappings` getters respectively, and we only parse the mappings\n// and create these arrays once queried for a source location. We jump through\n// these hoops because there can be many thousands of mappings, and parsing\n// them is expensive, so we only want to do it if we must.\n//\n// Each object in the arrays is of the form:\n//\n//     {\n//       generatedLine: The line number in the generated code,\n//       generatedColumn: The column number in the generated code,\n//       source: The path to the original source file that generated this\n//               chunk of code,\n//       originalLine: The line number in the original source that\n//                     corresponds to this chunk of generated code,\n//       originalColumn: The column number in the original source that\n//                       corresponds to this chunk of generated code,\n//       name: The name of the original symbol which generated this chunk of\n//             code.\n//     }\n//\n// All properties except for `generatedLine` and `generatedColumn` can be\n// `null`.\n//\n// `_generatedMappings` is ordered by the generated positions.\n//\n// `_originalMappings` is ordered by the original positions.\n\nSourceMapConsumer.prototype.__generatedMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n  get: function () {\n    if (!this.__generatedMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__generatedMappings;\n  }\n});\n\nSourceMapConsumer.prototype.__originalMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n  get: function () {\n    if (!this.__originalMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__originalMappings;\n  }\n});\n\nSourceMapConsumer.prototype._charIsMappingSeparator =\n  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n    var c = aStr.charAt(index);\n    return c === \";\" || c === \",\";\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    throw new Error(\"Subclasses must implement _parseMappings\");\n  };\n\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\n\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\n/**\n * Iterate over each mapping between an original source/line/column and a\n * generated line/column in this source map.\n *\n * @param Function aCallback\n *        The function that is called with each mapping.\n * @param Object aContext\n *        Optional. If specified, this object will be the value of `this` every\n *        time that `aCallback` is called.\n * @param aOrder\n *        Either `SourceMapConsumer.GENERATED_ORDER` or\n *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n *        iterate over the mappings sorted by the generated file's line/column\n *        order or the original's source/line/column order, respectively. Defaults to\n *        `SourceMapConsumer.GENERATED_ORDER`.\n */\nSourceMapConsumer.prototype.eachMapping =\n  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n    var context = aContext || null;\n    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    var mappings;\n    switch (order) {\n    case SourceMapConsumer.GENERATED_ORDER:\n      mappings = this._generatedMappings;\n      break;\n    case SourceMapConsumer.ORIGINAL_ORDER:\n      mappings = this._originalMappings;\n      break;\n    default:\n      throw new Error(\"Unknown order of iteration.\");\n    }\n\n    var sourceRoot = this.sourceRoot;\n    mappings.map(function (mapping) {\n      var source = mapping.source === null ? null : this._sources.at(mapping.source);\n      if (source != null && sourceRoot != null) {\n        source = util.join(sourceRoot, source);\n      }\n      return {\n        source: source,\n        generatedLine: mapping.generatedLine,\n        generatedColumn: mapping.generatedColumn,\n        originalLine: mapping.originalLine,\n        originalColumn: mapping.originalColumn,\n        name: mapping.name === null ? null : this._names.at(mapping.name)\n      };\n    }, this).forEach(aCallback, context);\n  };\n\n/**\n * Returns all generated line and column information for the original source,\n * line, and column provided. If no column is provided, returns all mappings\n * corresponding to a either the line we are searching for or the next\n * closest line that has any mappings. Otherwise, returns all mappings\n * corresponding to the given line and either the column we are searching for\n * or the next closest column that has any offsets.\n *\n * The only argument is an object with the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: Optional. the column number in the original source.\n *\n * and an array of objects is returned, each with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nSourceMapConsumer.prototype.allGeneratedPositionsFor =\n  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n    var line = util.getArg(aArgs, 'line');\n\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to 0, we thus find the last mapping for\n    // the given line, provided such a mapping exists.\n    var needle = {\n      source: util.getArg(aArgs, 'source'),\n      originalLine: line,\n      originalColumn: util.getArg(aArgs, 'column', 0)\n    };\n\n    if (this.sourceRoot != null) {\n      needle.source = util.relative(this.sourceRoot, needle.source);\n    }\n    if (!this._sources.has(needle.source)) {\n      return [];\n    }\n    needle.source = this._sources.indexOf(needle.source);\n\n    var mappings = [];\n\n    var index = this._findMapping(needle,\n                                  this._originalMappings,\n                                  \"originalLine\",\n                                  \"originalColumn\",\n                                  util.compareByOriginalPositions,\n                                  binarySearch.LEAST_UPPER_BOUND);\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (aArgs.column === undefined) {\n        var originalLine = mapping.originalLine;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we found. Since\n        // mappings are sorted, this is guaranteed to find all mappings for\n        // the line we found.\n        while (mapping && mapping.originalLine === originalLine) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      } else {\n        var originalColumn = mapping.originalColumn;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we were searching for.\n        // Since mappings are sorted, this is guaranteed to find all mappings for\n        // the line we are searching for.\n        while (mapping &&\n               mapping.originalLine === line &&\n               mapping.originalColumn == originalColumn) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      }\n    }\n\n    return mappings;\n  };\n\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The only parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referrenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nfunction BasicSourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sources = util.getArg(sourceMap, 'sources');\n  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n  // requires the array) to play nice here.\n  var names = util.getArg(sourceMap, 'names', []);\n  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n  var mappings = util.getArg(sourceMap, 'mappings');\n  var file = util.getArg(sourceMap, 'file', null);\n\n  // Once again, Sass deviates from the spec and supplies the version as a\n  // string rather than a number, so we use loose equality checking here.\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  sources = sources\n    .map(String)\n    // Some source maps produce relative source paths like \"./foo.js\" instead of\n    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n    // See bugzil.la/1090768.\n    .map(util.normalize)\n    // Always ensure that absolute sources are internally stored relative to\n    // the source root, if the source root is absolute. Not doing this would\n    // be particularly problematic when the source root is a prefix of the\n    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n    .map(function (source) {\n      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\n        ? util.relative(sourceRoot, source)\n        : source;\n    });\n\n  // Pass `true` below to allow duplicate names and sources. While source maps\n  // are intended to be compressed and deduplicated, the TypeScript compiler\n  // sometimes generates source maps with duplicates in them. See Github issue\n  // #72 and bugzil.la/889492.\n  this._names = ArraySet.fromArray(names.map(String), true);\n  this._sources = ArraySet.fromArray(sources, true);\n\n  this.sourceRoot = sourceRoot;\n  this.sourcesContent = sourcesContent;\n  this._mappings = mappings;\n  this.file = file;\n}\n\nBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n\n/**\n * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n *\n * @param SourceMapGenerator aSourceMap\n *        The source map that will be consumed.\n * @returns BasicSourceMapConsumer\n */\nBasicSourceMapConsumer.fromSourceMap =\n  function SourceMapConsumer_fromSourceMap(aSourceMap) {\n    var smc = Object.create(BasicSourceMapConsumer.prototype);\n\n    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n    smc.sourceRoot = aSourceMap._sourceRoot;\n    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\n                                                            smc.sourceRoot);\n    smc.file = aSourceMap._file;\n\n    // Because we are modifying the entries (by converting string sources and\n    // names to indices into the sources and names ArraySets), we have to make\n    // a copy of the entry or else bad things happen. Shared mutable state\n    // strikes again! See github issue #191.\n\n    var generatedMappings = aSourceMap._mappings.toArray().slice();\n    var destGeneratedMappings = smc.__generatedMappings = [];\n    var destOriginalMappings = smc.__originalMappings = [];\n\n    for (var i = 0, length = generatedMappings.length; i < length; i++) {\n      var srcMapping = generatedMappings[i];\n      var destMapping = new Mapping;\n      destMapping.generatedLine = srcMapping.generatedLine;\n      destMapping.generatedColumn = srcMapping.generatedColumn;\n\n      if (srcMapping.source) {\n        destMapping.source = sources.indexOf(srcMapping.source);\n        destMapping.originalLine = srcMapping.originalLine;\n        destMapping.originalColumn = srcMapping.originalColumn;\n\n        if (srcMapping.name) {\n          destMapping.name = names.indexOf(srcMapping.name);\n        }\n\n        destOriginalMappings.push(destMapping);\n      }\n\n      destGeneratedMappings.push(destMapping);\n    }\n\n    quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n\n    return smc;\n  };\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nBasicSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    return this._sources.toArray().map(function (s) {\n      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;\n    }, this);\n  }\n});\n\n/**\n * Provide the JIT with a nice shape / hidden class.\n */\nfunction Mapping() {\n  this.generatedLine = 0;\n  this.generatedColumn = 0;\n  this.source = null;\n  this.originalLine = null;\n  this.originalColumn = null;\n  this.name = null;\n}\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nBasicSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    var generatedLine = 1;\n    var previousGeneratedColumn = 0;\n    var previousOriginalLine = 0;\n    var previousOriginalColumn = 0;\n    var previousSource = 0;\n    var previousName = 0;\n    var length = aStr.length;\n    var index = 0;\n    var cachedSegments = {};\n    var temp = {};\n    var originalMappings = [];\n    var generatedMappings = [];\n    var mapping, str, segment, end, value;\n\n    while (index < length) {\n      if (aStr.charAt(index) === ';') {\n        generatedLine++;\n        index++;\n        previousGeneratedColumn = 0;\n      }\n      else if (aStr.charAt(index) === ',') {\n        index++;\n      }\n      else {\n        mapping = new Mapping();\n        mapping.generatedLine = generatedLine;\n\n        // Because each offset is encoded relative to the previous one,\n        // many segments often have the same encoding. We can exploit this\n        // fact by caching the parsed variable length fields of each segment,\n        // allowing us to avoid a second parse if we encounter the same\n        // segment again.\n        for (end = index; end < length; end++) {\n          if (this._charIsMappingSeparator(aStr, end)) {\n            break;\n          }\n        }\n        str = aStr.slice(index, end);\n\n        segment = cachedSegments[str];\n        if (segment) {\n          index += str.length;\n        } else {\n          segment = [];\n          while (index < end) {\n            base64VLQ.decode(aStr, index, temp);\n            value = temp.value;\n            index = temp.rest;\n            segment.push(value);\n          }\n\n          if (segment.length === 2) {\n            throw new Error('Found a source, but no line and column');\n          }\n\n          if (segment.length === 3) {\n            throw new Error('Found a source and line, but no column');\n          }\n\n          cachedSegments[str] = segment;\n        }\n\n        // Generated column.\n        mapping.generatedColumn = previousGeneratedColumn + segment[0];\n        previousGeneratedColumn = mapping.generatedColumn;\n\n        if (segment.length > 1) {\n          // Original source.\n          mapping.source = previousSource + segment[1];\n          previousSource += segment[1];\n\n          // Original line.\n          mapping.originalLine = previousOriginalLine + segment[2];\n          previousOriginalLine = mapping.originalLine;\n          // Lines are stored 0-based\n          mapping.originalLine += 1;\n\n          // Original column.\n          mapping.originalColumn = previousOriginalColumn + segment[3];\n          previousOriginalColumn = mapping.originalColumn;\n\n          if (segment.length > 4) {\n            // Original name.\n            mapping.name = previousName + segment[4];\n            previousName += segment[4];\n          }\n        }\n\n        generatedMappings.push(mapping);\n        if (typeof mapping.originalLine === 'number') {\n          originalMappings.push(mapping);\n        }\n      }\n    }\n\n    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\n    this.__generatedMappings = generatedMappings;\n\n    quickSort(originalMappings, util.compareByOriginalPositions);\n    this.__originalMappings = originalMappings;\n  };\n\n/**\n * Find the mapping that best matches the hypothetical \"needle\" mapping that\n * we are searching for in the given \"haystack\" of mappings.\n */\nBasicSourceMapConsumer.prototype._findMapping =\n  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n                                         aColumnName, aComparator, aBias) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n\n    if (aNeedle[aLineName] <= 0) {\n      throw new TypeError('Line must be greater than or equal to 1, got '\n                          + aNeedle[aLineName]);\n    }\n    if (aNeedle[aColumnName] < 0) {\n      throw new TypeError('Column must be greater than or equal to 0, got '\n                          + aNeedle[aColumnName]);\n    }\n\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n  };\n\n/**\n * Compute the last column for each generated mapping. The last column is\n * inclusive.\n */\nBasicSourceMapConsumer.prototype.computeColumnSpans =\n  function SourceMapConsumer_computeColumnSpans() {\n    for (var index = 0; index < this._generatedMappings.length; ++index) {\n      var mapping = this._generatedMappings[index];\n\n      // Mappings do not contain a field for the last generated columnt. We\n      // can come up with an optimistic estimate, however, by assuming that\n      // mappings are contiguous (i.e. given two consecutive mappings, the\n      // first mapping ends where the second one starts).\n      if (index + 1 < this._generatedMappings.length) {\n        var nextMapping = this._generatedMappings[index + 1];\n\n        if (mapping.generatedLine === nextMapping.generatedLine) {\n          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n          continue;\n        }\n      }\n\n      // The last mapping for each line spans the entire line.\n      mapping.lastGeneratedColumn = Infinity;\n    }\n  };\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.\n *   - column: The column number in the generated source.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.\n *   - column: The column number in the original source, or null.\n *   - name: The original identifier, or null.\n */\nBasicSourceMapConsumer.prototype.originalPositionFor =\n  function SourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._generatedMappings,\n      \"generatedLine\",\n      \"generatedColumn\",\n      util.compareByGeneratedPositionsDeflated,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._generatedMappings[index];\n\n      if (mapping.generatedLine === needle.generatedLine) {\n        var source = util.getArg(mapping, 'source', null);\n        if (source !== null) {\n          source = this._sources.at(source);\n          if (this.sourceRoot != null) {\n            source = util.join(this.sourceRoot, source);\n          }\n        }\n        var name = util.getArg(mapping, 'name', null);\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n        return {\n          source: source,\n          line: util.getArg(mapping, 'originalLine', null),\n          column: util.getArg(mapping, 'originalColumn', null),\n          name: name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nBasicSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function BasicSourceMapConsumer_hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() &&\n      !this.sourcesContent.some(function (sc) { return sc == null; });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nBasicSourceMapConsumer.prototype.sourceContentFor =\n  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    if (this.sourceRoot != null) {\n      aSource = util.relative(this.sourceRoot, aSource);\n    }\n\n    if (this._sources.has(aSource)) {\n      return this.sourcesContent[this._sources.indexOf(aSource)];\n    }\n\n    var url;\n    if (this.sourceRoot != null\n        && (url = util.urlParse(this.sourceRoot))) {\n      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n      // many users. We can help them out when they expect file:// URIs to\n      // behave like it would if they were running a local HTTP server. See\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n      var fileUriAbsPath = aSource.replace(/^file:\\/\\//, \"\");\n      if (url.scheme == \"file\"\n          && this._sources.has(fileUriAbsPath)) {\n        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n      }\n\n      if ((!url.path || url.path == \"/\")\n          && this._sources.has(\"/\" + aSource)) {\n        return this.sourcesContent[this._sources.indexOf(\"/\" + aSource)];\n      }\n    }\n\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: The column number in the original source.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nBasicSourceMapConsumer.prototype.generatedPositionFor =\n  function SourceMapConsumer_generatedPositionFor(aArgs) {\n    var source = util.getArg(aArgs, 'source');\n    if (this.sourceRoot != null) {\n      source = util.relative(this.sourceRoot, source);\n    }\n    if (!this._sources.has(source)) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n    source = this._sources.indexOf(source);\n\n    var needle = {\n      source: source,\n      originalLine: util.getArg(aArgs, 'line'),\n      originalColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._originalMappings,\n      \"originalLine\",\n      \"originalColumn\",\n      util.compareByOriginalPositions,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (mapping.source === needle.source) {\n        return {\n          line: util.getArg(mapping, 'generatedLine', null),\n          column: util.getArg(mapping, 'generatedColumn', null),\n          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  };\n\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The only parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nfunction IndexedSourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sections = util.getArg(sourceMap, 'sections');\n\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n\n  var lastOffset = {\n    line: -1,\n    column: 0\n  };\n  this._sections = sections.map(function (s) {\n    if (s.url) {\n      // The url field will require support for asynchronicity.\n      // See https://github.com/mozilla/source-map/issues/16\n      throw new Error('Support for url field in sections not implemented.');\n    }\n    var offset = util.getArg(s, 'offset');\n    var offsetLine = util.getArg(offset, 'line');\n    var offsetColumn = util.getArg(offset, 'column');\n\n    if (offsetLine < lastOffset.line ||\n        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n      throw new Error('Section offsets must be ordered and non-overlapping.');\n    }\n    lastOffset = offset;\n\n    return {\n      generatedOffset: {\n        // The offset fields are 0-based, but we use 1-based indices when\n        // encoding/decoding from VLQ.\n        generatedLine: offsetLine + 1,\n        generatedColumn: offsetColumn + 1\n      },\n      consumer: new SourceMapConsumer(util.getArg(s, 'map'))\n    }\n  });\n}\n\nIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nIndexedSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    var sources = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n    return sources;\n  }\n});\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.\n *   - column: The column number in the generated source.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.\n *   - column: The column number in the original source, or null.\n *   - name: The original identifier, or null.\n */\nIndexedSourceMapConsumer.prototype.originalPositionFor =\n  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    var sectionIndex = binarySearch.search(needle, this._sections,\n      function(needle, section) {\n        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n\n        return (needle.generatedColumn -\n                section.generatedOffset.generatedColumn);\n      });\n    var section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine -\n        (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn -\n        (section.generatedOffset.generatedLine === needle.generatedLine\n         ? section.generatedOffset.generatedColumn - 1\n         : 0),\n      bias: aArgs.bias\n    });\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nIndexedSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n    return this._sections.every(function (s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nIndexedSourceMapConsumer.prototype.sourceContentFor =\n  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      var content = section.consumer.sourceContentFor(aSource, true);\n      if (content) {\n        return content;\n      }\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: The column number in the original source.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nIndexedSourceMapConsumer.prototype.generatedPositionFor =\n  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      // Only consider this section if the requested source is in the list of\n      // sources of the consumer.\n      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {\n        continue;\n      }\n      var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n      if (generatedPosition) {\n        var ret = {\n          line: generatedPosition.line +\n            (section.generatedOffset.generatedLine - 1),\n          column: generatedPosition.column +\n            (section.generatedOffset.generatedLine === generatedPosition.line\n             ? section.generatedOffset.generatedColumn - 1\n             : 0)\n        };\n        return ret;\n      }\n    }\n\n    return {\n      line: null,\n      column: null\n    };\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nIndexedSourceMapConsumer.prototype._parseMappings =\n  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    this.__generatedMappings = [];\n    this.__originalMappings = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n      var sectionMappings = section.consumer._generatedMappings;\n      for (var j = 0; j < sectionMappings.length; j++) {\n        var mapping = sectionMappings[j];\n\n        var source = section.consumer._sources.at(mapping.source);\n        if (section.consumer.sourceRoot !== null) {\n          source = util.join(section.consumer.sourceRoot, source);\n        }\n        this._sources.add(source);\n        source = this._sources.indexOf(source);\n\n        var name = section.consumer._names.at(mapping.name);\n        this._names.add(name);\n        name = this._names.indexOf(name);\n\n        // The mappings coming from the consumer for the section have\n        // generated positions relative to the start of the section, so we\n        // need to offset them to be relative to the start of the concatenated\n        // generated file.\n        var adjustedMapping = {\n          source: source,\n          generatedLine: mapping.generatedLine +\n            (section.generatedOffset.generatedLine - 1),\n          generatedColumn: mapping.generatedColumn +\n            (section.generatedOffset.generatedLine === mapping.generatedLine\n            ? section.generatedOffset.generatedColumn - 1\n            : 0),\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name: name\n        };\n\n        this.__generatedMappings.push(adjustedMapping);\n        if (typeof adjustedMapping.originalLine === 'number') {\n          this.__originalMappings.push(adjustedMapping);\n        }\n      }\n    }\n\n    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n    quickSort(this.__originalMappings, util.compareByOriginalPositions);\n  };\n\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\nvar util = require('./util');\n\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nvar REGEX_NEWLINE = /(\\r?\\n)/;\n\n// Newline character code for charCodeAt() comparisons\nvar NEWLINE_CODE = 10;\n\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nvar isSourceNode = \"$$$isSourceNode$$$\";\n\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n  this.children = [];\n  this.sourceContents = {};\n  this.line = aLine == null ? null : aLine;\n  this.column = aColumn == null ? null : aColumn;\n  this.source = aSource == null ? null : aSource;\n  this.name = aName == null ? null : aName;\n  this[isSourceNode] = true;\n  if (aChunks != null) this.add(aChunks);\n}\n\n/**\n * Creates a SourceNode from generated code and a SourceMapConsumer.\n *\n * @param aGeneratedCode The generated code\n * @param aSourceMapConsumer The SourceMap for the generated code\n * @param aRelativePath Optional. The path that relative sources in the\n *        SourceMapConsumer should be relative to.\n */\nSourceNode.fromStringWithSourceMap =\n  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    var node = new SourceNode();\n\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are accessed by calling `shiftNextLine`.\n    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    var remainingLinesIndex = 0;\n    var shiftNextLine = function() {\n      var lineContents = getNextLine();\n      // The last line of a file might not have a newline.\n      var newLine = getNextLine() || \"\";\n      return lineContents + newLine;\n\n      function getNextLine() {\n        return remainingLinesIndex < remainingLines.length ?\n            remainingLines[remainingLinesIndex++] : undefined;\n      }\n    };\n\n    // We need to remember the position of \"remainingLines\"\n    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    var lastMapping = null;\n\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      if (lastMapping !== null) {\n        // We add the code from \"lastMapping\" to \"mapping\":\n        // First check if there is a new line in between.\n        if (lastGeneratedLine < mapping.generatedLine) {\n          // Associate first line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n          lastGeneratedLine++;\n          lastGeneratedColumn = 0;\n          // The remaining code is added without mapping\n        } else {\n          // There is no new line in between.\n          // Associate the code between \"lastGeneratedColumn\" and\n          // \"mapping.generatedColumn\" with \"lastMapping\"\n          var nextLine = remainingLines[remainingLinesIndex];\n          var code = nextLine.substr(0, mapping.generatedColumn -\n                                        lastGeneratedColumn);\n          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -\n                                              lastGeneratedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n          addMappingWithCode(lastMapping, code);\n          // No more remaining code, continue\n          lastMapping = mapping;\n          return;\n        }\n      }\n      // We add the generated code until the first mapping\n      // to the SourceNode without any mapping.\n      // Each line is added as separate string.\n      while (lastGeneratedLine < mapping.generatedLine) {\n        node.add(shiftNextLine());\n        lastGeneratedLine++;\n      }\n      if (lastGeneratedColumn < mapping.generatedColumn) {\n        var nextLine = remainingLines[remainingLinesIndex];\n        node.add(nextLine.substr(0, mapping.generatedColumn));\n        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n      }\n      lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLinesIndex < remainingLines.length) {\n      if (lastMapping) {\n        // Associate the remaining code in the current line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n      }\n      // and add the remaining lines without any mapping\n      node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\n    }\n\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aRelativePath != null) {\n          sourceFile = util.join(aRelativePath, sourceFile);\n        }\n        node.setSourceContent(sourceFile, content);\n      }\n    });\n\n    return node;\n\n    function addMappingWithCode(mapping, code) {\n      if (mapping === null || mapping.source === undefined) {\n        node.add(code);\n      } else {\n        var source = aRelativePath\n          ? util.join(aRelativePath, mapping.source)\n          : mapping.source;\n        node.add(new SourceNode(mapping.originalLine,\n                                mapping.originalColumn,\n                                source,\n                                code,\n                                mapping.name));\n      }\n    }\n  };\n\n/**\n * Add a chunk of generated JS to this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\n  if (Array.isArray(aChunk)) {\n    aChunk.forEach(function (chunk) {\n      this.add(chunk);\n    }, this);\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    if (aChunk) {\n      this.children.push(aChunk);\n    }\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Add a chunk of generated JS to the beginning of this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n  if (Array.isArray(aChunk)) {\n    for (var i = aChunk.length-1; i >= 0; i--) {\n      this.prepend(aChunk[i]);\n    }\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    this.children.unshift(aChunk);\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Walk over the tree of JS snippets in this node and its children. The\n * walking function is called once for each snippet of JS and is passed that\n * snippet and the its original associated source's line/column location.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\n  var chunk;\n  for (var i = 0, len = this.children.length; i < len; i++) {\n    chunk = this.children[i];\n    if (chunk[isSourceNode]) {\n      chunk.walk(aFn);\n    }\n    else {\n      if (chunk !== '') {\n        aFn(chunk, { source: this.source,\n                     line: this.line,\n                     column: this.column,\n                     name: this.name });\n      }\n    }\n  }\n};\n\n/**\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n * each of `this.children`.\n *\n * @param aSep The separator.\n */\nSourceNode.prototype.join = function SourceNode_join(aSep) {\n  var newChildren;\n  var i;\n  var len = this.children.length;\n  if (len > 0) {\n    newChildren = [];\n    for (i = 0; i < len-1; i++) {\n      newChildren.push(this.children[i]);\n      newChildren.push(aSep);\n    }\n    newChildren.push(this.children[i]);\n    this.children = newChildren;\n  }\n  return this;\n};\n\n/**\n * Call String.prototype.replace on the very right-most source snippet. Useful\n * for trimming whitespace from the end of a source node, etc.\n *\n * @param aPattern The pattern to replace.\n * @param aReplacement The thing to replace the pattern with.\n */\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n  var lastChild = this.children[this.children.length - 1];\n  if (lastChild[isSourceNode]) {\n    lastChild.replaceRight(aPattern, aReplacement);\n  }\n  else if (typeof lastChild === 'string') {\n    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n  }\n  else {\n    this.children.push(''.replace(aPattern, aReplacement));\n  }\n  return this;\n};\n\n/**\n * Set the source content for a source file. This will be added to the SourceMapGenerator\n * in the sourcesContent field.\n *\n * @param aSourceFile The filename of the source file\n * @param aSourceContent The content of the source file\n */\nSourceNode.prototype.setSourceContent =\n  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n  };\n\n/**\n * Walk over the tree of SourceNodes. The walking function is called for each\n * source file content and is passed the filename and source content.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walkSourceContents =\n  function SourceNode_walkSourceContents(aFn) {\n    for (var i = 0, len = this.children.length; i < len; i++) {\n      if (this.children[i][isSourceNode]) {\n        this.children[i].walkSourceContents(aFn);\n      }\n    }\n\n    var sources = Object.keys(this.sourceContents);\n    for (var i = 0, len = sources.length; i < len; i++) {\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n  };\n\n/**\n * Return the string representation of this source node. Walks over the tree\n * and concatenates all the various snippets together to one string.\n */\nSourceNode.prototype.toString = function SourceNode_toString() {\n  var str = \"\";\n  this.walk(function (chunk) {\n    str += chunk;\n  });\n  return str;\n};\n\n/**\n * Returns the string representation of this source node along with a source\n * map.\n */\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n  var generated = {\n    code: \"\",\n    line: 1,\n    column: 0\n  };\n  var map = new SourceMapGenerator(aArgs);\n  var sourceMappingActive = false;\n  var lastOriginalSource = null;\n  var lastOriginalLine = null;\n  var lastOriginalColumn = null;\n  var lastOriginalName = null;\n  this.walk(function (chunk, original) {\n    generated.code += chunk;\n    if (original.source !== null\n        && original.line !== null\n        && original.column !== null) {\n      if(lastOriginalSource !== original.source\n         || lastOriginalLine !== original.line\n         || lastOriginalColumn !== original.column\n         || lastOriginalName !== original.name) {\n        map.addMapping({\n          source: original.source,\n          original: {\n            line: original.line,\n            column: original.column\n          },\n          generated: {\n            line: generated.line,\n            column: generated.column\n          },\n          name: original.name\n        });\n      }\n      lastOriginalSource = original.source;\n      lastOriginalLine = original.line;\n      lastOriginalColumn = original.column;\n      lastOriginalName = original.name;\n      sourceMappingActive = true;\n    } else if (sourceMappingActive) {\n      map.addMapping({\n        generated: {\n          line: generated.line,\n          column: generated.column\n        }\n      });\n      lastOriginalSource = null;\n      sourceMappingActive = false;\n    }\n    for (var idx = 0, length = chunk.length; idx < length; idx++) {\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n        generated.line++;\n        generated.column = 0;\n        // Mappings end at eol\n        if (idx + 1 === length) {\n          lastOriginalSource = null;\n          sourceMappingActive = false;\n        } else if (sourceMappingActive) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n      } else {\n        generated.column++;\n      }\n    }\n  });\n  this.walkSourceContents(function (sourceFile, sourceContent) {\n    map.setSourceContent(sourceFile, sourceContent);\n  });\n\n  return { code: generated.code, map: map };\n};\n\nexports.SourceNode = SourceNode;\n", "/*\n * Copyright 2009-2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE.txt or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nexports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;\nexports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;\nexports.SourceNode = require('./lib/source-node').SourceNode;\n", "module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"fs\" has been externalized for browser compatibility. Cannot access \"fs.${key}\" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "'use strict';\nvar fs = require('fs');\nvar path = require('path');\n\nObject.defineProperty(exports, 'commentRegex', {\n  get: function getCommentRegex () {\n    return /^\\s*\\/(?:\\/|\\*)[@#]\\s+sourceMappingURL=data:(?:application|text)\\/json;(?:charset[:=]\\S+?;)?base64,(?:.*)$/mg;\n  }\n});\n\nObject.defineProperty(exports, 'mapFileCommentRegex', {\n  get: function getMapFileCommentRegex () {\n    // Matches sourceMappingURL in either // or /* comment styles.\n    return /(?:\\/\\/[@#][ \\t]+sourceMappingURL=([^\\s'\"`]+?)[ \\t]*$)|(?:\\/\\*[@#][ \\t]+sourceMappingURL=([^\\*]+?)[ \\t]*(?:\\*\\/){1}[ \\t]*$)/mg;\n  }\n});\n\nvar decodeBase64;\nif (typeof Buffer !== 'undefined') {\n  if (typeof Buffer.from === 'function') {\n    decodeBase64 = decodeBase64WithBufferFrom;\n  } else {\n    decodeBase64 = decodeBase64WithNewBuffer;\n  }\n} else {\n  decodeBase64 = decodeBase64WithAtob;\n}\n\nfunction decodeBase64WithBufferFrom(base64) {\n  return Buffer.from(base64, 'base64').toString();\n}\n\nfunction decodeBase64WithNewBuffer(base64) {\n  if (typeof value === 'number') {\n    throw new TypeError('The value to decode must not be of type number.');\n  }\n  return new Buffer(base64, 'base64').toString();\n}\n\nfunction decodeBase64WithAtob(base64) {\n  return decodeURIComponent(escape(atob(base64)));\n}\n\nfunction stripComment(sm) {\n  return sm.split(',').pop();\n}\n\nfunction readFromFileMap(sm, dir) {\n  // NOTE: this will only work on the server since it attempts to read the map file\n\n  var r = exports.mapFileCommentRegex.exec(sm);\n\n  // for some odd reason //# .. captures in 1 and /* .. */ in 2\n  var filename = r[1] || r[2];\n  var filepath = path.resolve(dir, filename);\n\n  try {\n    return fs.readFileSync(filepath, 'utf8');\n  } catch (e) {\n    throw new Error('An error occurred while trying to read the map file at ' + filepath + '\\n' + e);\n  }\n}\n\nfunction Converter (sm, opts) {\n  opts = opts || {};\n\n  if (opts.isFileComment) sm = readFromFileMap(sm, opts.commentFileDir);\n  if (opts.hasComment) sm = stripComment(sm);\n  if (opts.isEncoded) sm = decodeBase64(sm);\n  if (opts.isJSON || opts.isEncoded) sm = JSON.parse(sm);\n\n  this.sourcemap = sm;\n}\n\nConverter.prototype.toJSON = function (space) {\n  return JSON.stringify(this.sourcemap, null, space);\n};\n\nif (typeof Buffer !== 'undefined') {\n  if (typeof Buffer.from === 'function') {\n    Converter.prototype.toBase64 = encodeBase64WithBufferFrom;\n  } else {\n    Converter.prototype.toBase64 = encodeBase64WithNewBuffer;\n  }\n} else {\n  Converter.prototype.toBase64 = encodeBase64WithBtoa;\n}\n\nfunction encodeBase64WithBufferFrom() {\n  var json = this.toJSON();\n  return Buffer.from(json, 'utf8').toString('base64');\n}\n\nfunction encodeBase64WithNewBuffer() {\n  var json = this.toJSON();\n  if (typeof json === 'number') {\n    throw new TypeError('The json to encode must not be of type number.');\n  }\n  return new Buffer(json, 'utf8').toString('base64');\n}\n\nfunction encodeBase64WithBtoa() {\n  var json = this.toJSON();\n  return btoa(unescape(encodeURIComponent(json)));\n}\n\nConverter.prototype.toComment = function (options) {\n  var base64 = this.toBase64();\n  var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n  return options && options.multiline ? '/*# ' + data + ' */' : '//# ' + data;\n};\n\n// returns copy instead of original\nConverter.prototype.toObject = function () {\n  return JSON.parse(this.toJSON());\n};\n\nConverter.prototype.addProperty = function (key, value) {\n  if (this.sourcemap.hasOwnProperty(key)) throw new Error('property \"' + key + '\" already exists on the sourcemap, use set property instead');\n  return this.setProperty(key, value);\n};\n\nConverter.prototype.setProperty = function (key, value) {\n  this.sourcemap[key] = value;\n  return this;\n};\n\nConverter.prototype.getProperty = function (key) {\n  return this.sourcemap[key];\n};\n\nexports.fromObject = function (obj) {\n  return new Converter(obj);\n};\n\nexports.fromJSON = function (json) {\n  return new Converter(json, { isJSON: true });\n};\n\nexports.fromBase64 = function (base64) {\n  return new Converter(base64, { isEncoded: true });\n};\n\nexports.fromComment = function (comment) {\n  comment = comment\n    .replace(/^\\/\\*/g, '//')\n    .replace(/\\*\\/$/g, '');\n\n  return new Converter(comment, { isEncoded: true, hasComment: true });\n};\n\nexports.fromMapFileComment = function (comment, dir) {\n  return new Converter(comment, { commentFileDir: dir, isFileComment: true, isJSON: true });\n};\n\n// Finds last sourcemap comment in file or returns null if none was found\nexports.fromSource = function (content) {\n  var m = content.match(exports.commentRegex);\n  return m ? exports.fromComment(m.pop()) : null;\n};\n\n// Finds last sourcemap comment in file or returns null if none was found\nexports.fromMapFileSource = function (content, dir) {\n  var m = content.match(exports.mapFileCommentRegex);\n  return m ? exports.fromMapFileComment(m.pop(), dir) : null;\n};\n\nexports.removeComments = function (src) {\n  return src.replace(exports.commentRegex, '');\n};\n\nexports.removeMapFileComments = function (src) {\n  return src.replace(exports.mapFileCommentRegex, '');\n};\n\nexports.generateMapFileComment = function (file, options) {\n  var data = 'sourceMappingURL=' + file;\n  return options && options.multiline ? '/*# ' + data + ' */' : '//# ' + data;\n};\n", "var path = require('path')\nvar fs = require('fs')\n\nfunction defaultCheck (dir) {\n  return fs.existsSync(path.join(dir, 'package.json'))\n}\n\nfunction findRoot (start, check) {\n  start = start || module.parent.filename\n  check = check || defaultCheck\n\n  if (typeof start === 'string') {\n    if (start[start.length - 1] !== path.sep) {\n      start += path.sep\n    }\n    start = start.split(path.sep)\n  }\n  if (!start.length) {\n    throw new Error('package.json not found in path')\n  }\n  start.pop()\n  var dir = start.join(path.sep)\n  try {\n    if (check(dir)) {\n      return dir\n    }\n  } catch (e) {}\n  return findRoot(start, check)\n}\n\nmodule.exports = findRoot\n", "'use strict';\n\nmodule.exports = string => {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t// Escape characters with special meaning either inside or outside character sets.\n\t// Use a simple backslash escape when its always valid, and a \\unnnn escape when the simpler form would be disallowed by Unicode patterns stricter grammar.\n\treturn string\n\t\t.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n\t\t.replace(/-/g, '\\\\x2d');\n};\n", "module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"assert\" has been externalized for browser compatibility. Cannot access \"assert.${key}\" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "export default function shallowEqual<T extends object>(\n  actual: object,\n  expected: T,\n): actual is T {\n  const keys = Object.keys(expected) as (keyof T)[];\n\n  for (const key of keys) {\n    if (\n      // @ts-expect-error maybe we should check whether key exists first\n      actual[key] !== expected[key]\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n", "const warnings = new Set();\n\nexport default function deprecationWarning(\n  oldName: string,\n  newName: string,\n  prefix: string = \"\",\n) {\n  if (warnings.has(oldName)) return;\n  warnings.add(oldName);\n\n  const { internal, trace } = captureShortStackTrace(1, 2);\n  if (internal) {\n    // If usage comes from an internal package, there is no point in warning because\n    // 1. The new version of the package will already use the new API\n    // 2. When the deprecation will become an error (in a future major version), users\n    //    will have to update every package anyway.\n    return;\n  }\n  console.warn(\n    `${prefix}\\`${oldName}\\` has been deprecated, please migrate to \\`${newName}\\`\\n${trace}`,\n  );\n}\n\nfunction captureShortStackTrace(skip: number, length: number) {\n  const { stackTraceLimit, prepareStackTrace } = Error;\n  let stackTrace: NodeJS.CallSite[];\n  // We add 1 to also take into account this function.\n  Error.stackTraceLimit = 1 + skip + length;\n  Error.prepareStackTrace = function (err, stack) {\n    stackTrace = stack;\n  };\n  // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n  new Error().stack;\n  Error.stackTraceLimit = stackTraceLimit;\n  Error.prepareStackTrace = prepareStackTrace;\n\n  if (!stackTrace) return { internal: false, trace: \"\" };\n\n  const shortStackTrace = stackTrace.slice(1 + skip, 1 + skip + length);\n  return {\n    internal: /[\\\\/]@babel[\\\\/]/.test(shortStackTrace[1].getFileName()),\n    trace: shortStackTrace.map(frame => `    at ${frame}`).join(\"\\n\"),\n  };\n}\n", "/*\n * This file is auto-generated! Do not modify it directly.\n * To re-generate run 'make build'\n */\n\n/* eslint-disable no-fallthrough */\n\nimport shallowEqual from \"../../utils/shallowEqual.ts\";\nimport type * as t from \"../../index.ts\";\nimport deprecationWarning from \"../../utils/deprecationWarning.ts\";\n\ntype Opts<Obj> = Partial<{\n  [Prop in keyof Obj]: Obj[Prop] extends t.Node\n    ? t.Node\n    : Obj[Prop] extends t.Node[]\n      ? t.Node[]\n      : Obj[Prop];\n}>;\n\nexport function isArrayExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ArrayExpression> | null,\n): node is t.ArrayExpression {\n  if (!node) return false;\n\n  if (node.type !== \"ArrayExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isAssignmentExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.AssignmentExpression> | null,\n): node is t.AssignmentExpression {\n  if (!node) return false;\n\n  if (node.type !== \"AssignmentExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBinaryExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.BinaryExpression> | null,\n): node is t.BinaryExpression {\n  if (!node) return false;\n\n  if (node.type !== \"BinaryExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isInterpreterDirective(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.InterpreterDirective> | null,\n): node is t.InterpreterDirective {\n  if (!node) return false;\n\n  if (node.type !== \"InterpreterDirective\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDirective(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.Directive> | null,\n): node is t.Directive {\n  if (!node) return false;\n\n  if (node.type !== \"Directive\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDirectiveLiteral(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.DirectiveLiteral> | null,\n): node is t.DirectiveLiteral {\n  if (!node) return false;\n\n  if (node.type !== \"DirectiveLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBlockStatement(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.BlockStatement> | null,\n): node is t.BlockStatement {\n  if (!node) return false;\n\n  if (node.type !== \"BlockStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBreakStatement(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.BreakStatement> | null,\n): node is t.BreakStatement {\n  if (!node) return false;\n\n  if (node.type !== \"BreakStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isCallExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.CallExpression> | null,\n): node is t.CallExpression {\n  if (!node) return false;\n\n  if (node.type !== \"CallExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isCatchClause(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.CatchClause> | null,\n): node is t.CatchClause {\n  if (!node) return false;\n\n  if (node.type !== \"CatchClause\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isConditionalExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ConditionalExpression> | null,\n): node is t.ConditionalExpression {\n  if (!node) return false;\n\n  if (node.type !== \"ConditionalExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isContinueStatement(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ContinueStatement> | null,\n): node is t.ContinueStatement {\n  if (!node) return false;\n\n  if (node.type !== \"ContinueStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDebuggerStatement(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.DebuggerStatement> | null,\n): node is t.DebuggerStatement {\n  if (!node) return false;\n\n  if (node.type !== \"DebuggerStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDoWhileStatement(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.DoWhileStatement> | null,\n): node is t.DoWhileStatement {\n  if (!node) return false;\n\n  if (node.type !== \"DoWhileStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEmptyStatement(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.EmptyStatement> | null,\n): node is t.EmptyStatement {\n  if (!node) return false;\n\n  if (node.type !== \"EmptyStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExpressionStatement(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ExpressionStatement> | null,\n): node is t.ExpressionStatement {\n  if (!node) return false;\n\n  if (node.type !== \"ExpressionStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFile(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.File> | null,\n): node is t.File {\n  if (!node) return false;\n\n  if (node.type !== \"File\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isForInStatement(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ForInStatement> | null,\n): node is t.ForInStatement {\n  if (!node) return false;\n\n  if (node.type !== \"ForInStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isForStatement(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ForStatement> | null,\n): node is t.ForStatement {\n  if (!node) return false;\n\n  if (node.type !== \"ForStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFunctionDeclaration(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.FunctionDeclaration> | null,\n): node is t.FunctionDeclaration {\n  if (!node) return false;\n\n  if (node.type !== \"FunctionDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFunctionExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.FunctionExpression> | null,\n): node is t.FunctionExpression {\n  if (!node) return false;\n\n  if (node.type !== \"FunctionExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isIdentifier(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.Identifier> | null,\n): node is t.Identifier {\n  if (!node) return false;\n\n  if (node.type !== \"Identifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isIfStatement(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.IfStatement> | null,\n): node is t.IfStatement {\n  if (!node) return false;\n\n  if (node.type !== \"IfStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isLabeledStatement(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.LabeledStatement> | null,\n): node is t.LabeledStatement {\n  if (!node) return false;\n\n  if (node.type !== \"LabeledStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isStringLiteral(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.StringLiteral> | null,\n): node is t.StringLiteral {\n  if (!node) return false;\n\n  if (node.type !== \"StringLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isNumericLiteral(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.NumericLiteral> | null,\n): node is t.NumericLiteral {\n  if (!node) return false;\n\n  if (node.type !== \"NumericLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isNullLiteral(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.NullLiteral> | null,\n): node is t.NullLiteral {\n  if (!node) return false;\n\n  if (node.type !== \"NullLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBooleanLiteral(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.BooleanLiteral> | null,\n): node is t.BooleanLiteral {\n  if (!node) return false;\n\n  if (node.type !== \"BooleanLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isRegExpLiteral(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.RegExpLiteral> | null,\n): node is t.RegExpLiteral {\n  if (!node) return false;\n\n  if (node.type !== \"RegExpLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isLogicalExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.LogicalExpression> | null,\n): node is t.LogicalExpression {\n  if (!node) return false;\n\n  if (node.type !== \"LogicalExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isMemberExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.MemberExpression> | null,\n): node is t.MemberExpression {\n  if (!node) return false;\n\n  if (node.type !== \"MemberExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isNewExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.NewExpression> | null,\n): node is t.NewExpression {\n  if (!node) return false;\n\n  if (node.type !== \"NewExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isProgram(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.Program> | null,\n): node is t.Program {\n  if (!node) return false;\n\n  if (node.type !== \"Program\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ObjectExpression> | null,\n): node is t.ObjectExpression {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectMethod(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ObjectMethod> | null,\n): node is t.ObjectMethod {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectMethod\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectProperty(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ObjectProperty> | null,\n): node is t.ObjectProperty {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isRestElement(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.RestElement> | null,\n): node is t.RestElement {\n  if (!node) return false;\n\n  if (node.type !== \"RestElement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isReturnStatement(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ReturnStatement> | null,\n): node is t.ReturnStatement {\n  if (!node) return false;\n\n  if (node.type !== \"ReturnStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isSequenceExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.SequenceExpression> | null,\n): node is t.SequenceExpression {\n  if (!node) return false;\n\n  if (node.type !== \"SequenceExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isParenthesizedExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ParenthesizedExpression> | null,\n): node is t.ParenthesizedExpression {\n  if (!node) return false;\n\n  if (node.type !== \"ParenthesizedExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isSwitchCase(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.SwitchCase> | null,\n): node is t.SwitchCase {\n  if (!node) return false;\n\n  if (node.type !== \"SwitchCase\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isSwitchStatement(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.SwitchStatement> | null,\n): node is t.SwitchStatement {\n  if (!node) return false;\n\n  if (node.type !== \"SwitchStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isThisExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ThisExpression> | null,\n): node is t.ThisExpression {\n  if (!node) return false;\n\n  if (node.type !== \"ThisExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isThrowStatement(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ThrowStatement> | null,\n): node is t.ThrowStatement {\n  if (!node) return false;\n\n  if (node.type !== \"ThrowStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTryStatement(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TryStatement> | null,\n): node is t.TryStatement {\n  if (!node) return false;\n\n  if (node.type !== \"TryStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isUnaryExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.UnaryExpression> | null,\n): node is t.UnaryExpression {\n  if (!node) return false;\n\n  if (node.type !== \"UnaryExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isUpdateExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.UpdateExpression> | null,\n): node is t.UpdateExpression {\n  if (!node) return false;\n\n  if (node.type !== \"UpdateExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isVariableDeclaration(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.VariableDeclaration> | null,\n): node is t.VariableDeclaration {\n  if (!node) return false;\n\n  if (node.type !== \"VariableDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isVariableDeclarator(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.VariableDeclarator> | null,\n): node is t.VariableDeclarator {\n  if (!node) return false;\n\n  if (node.type !== \"VariableDeclarator\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isWhileStatement(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.WhileStatement> | null,\n): node is t.WhileStatement {\n  if (!node) return false;\n\n  if (node.type !== \"WhileStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isWithStatement(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.WithStatement> | null,\n): node is t.WithStatement {\n  if (!node) return false;\n\n  if (node.type !== \"WithStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isAssignmentPattern(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.AssignmentPattern> | null,\n): node is t.AssignmentPattern {\n  if (!node) return false;\n\n  if (node.type !== \"AssignmentPattern\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isArrayPattern(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ArrayPattern> | null,\n): node is t.ArrayPattern {\n  if (!node) return false;\n\n  if (node.type !== \"ArrayPattern\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isArrowFunctionExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ArrowFunctionExpression> | null,\n): node is t.ArrowFunctionExpression {\n  if (!node) return false;\n\n  if (node.type !== \"ArrowFunctionExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClassBody(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ClassBody> | null,\n): node is t.ClassBody {\n  if (!node) return false;\n\n  if (node.type !== \"ClassBody\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClassExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ClassExpression> | null,\n): node is t.ClassExpression {\n  if (!node) return false;\n\n  if (node.type !== \"ClassExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClassDeclaration(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ClassDeclaration> | null,\n): node is t.ClassDeclaration {\n  if (!node) return false;\n\n  if (node.type !== \"ClassDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExportAllDeclaration(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ExportAllDeclaration> | null,\n): node is t.ExportAllDeclaration {\n  if (!node) return false;\n\n  if (node.type !== \"ExportAllDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExportDefaultDeclaration(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ExportDefaultDeclaration> | null,\n): node is t.ExportDefaultDeclaration {\n  if (!node) return false;\n\n  if (node.type !== \"ExportDefaultDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExportNamedDeclaration(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ExportNamedDeclaration> | null,\n): node is t.ExportNamedDeclaration {\n  if (!node) return false;\n\n  if (node.type !== \"ExportNamedDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExportSpecifier(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ExportSpecifier> | null,\n): node is t.ExportSpecifier {\n  if (!node) return false;\n\n  if (node.type !== \"ExportSpecifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isForOfStatement(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ForOfStatement> | null,\n): node is t.ForOfStatement {\n  if (!node) return false;\n\n  if (node.type !== \"ForOfStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isImportDeclaration(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ImportDeclaration> | null,\n): node is t.ImportDeclaration {\n  if (!node) return false;\n\n  if (node.type !== \"ImportDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isImportDefaultSpecifier(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ImportDefaultSpecifier> | null,\n): node is t.ImportDefaultSpecifier {\n  if (!node) return false;\n\n  if (node.type !== \"ImportDefaultSpecifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isImportNamespaceSpecifier(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ImportNamespaceSpecifier> | null,\n): node is t.ImportNamespaceSpecifier {\n  if (!node) return false;\n\n  if (node.type !== \"ImportNamespaceSpecifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isImportSpecifier(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ImportSpecifier> | null,\n): node is t.ImportSpecifier {\n  if (!node) return false;\n\n  if (node.type !== \"ImportSpecifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isImportExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ImportExpression> | null,\n): node is t.ImportExpression {\n  if (!node) return false;\n\n  if (node.type !== \"ImportExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isMetaProperty(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.MetaProperty> | null,\n): node is t.MetaProperty {\n  if (!node) return false;\n\n  if (node.type !== \"MetaProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClassMethod(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ClassMethod> | null,\n): node is t.ClassMethod {\n  if (!node) return false;\n\n  if (node.type !== \"ClassMethod\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectPattern(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ObjectPattern> | null,\n): node is t.ObjectPattern {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectPattern\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isSpreadElement(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.SpreadElement> | null,\n): node is t.SpreadElement {\n  if (!node) return false;\n\n  if (node.type !== \"SpreadElement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isSuper(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.Super> | null,\n): node is t.Super {\n  if (!node) return false;\n\n  if (node.type !== \"Super\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTaggedTemplateExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TaggedTemplateExpression> | null,\n): node is t.TaggedTemplateExpression {\n  if (!node) return false;\n\n  if (node.type !== \"TaggedTemplateExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTemplateElement(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TemplateElement> | null,\n): node is t.TemplateElement {\n  if (!node) return false;\n\n  if (node.type !== \"TemplateElement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTemplateLiteral(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TemplateLiteral> | null,\n): node is t.TemplateLiteral {\n  if (!node) return false;\n\n  if (node.type !== \"TemplateLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isYieldExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.YieldExpression> | null,\n): node is t.YieldExpression {\n  if (!node) return false;\n\n  if (node.type !== \"YieldExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isAwaitExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.AwaitExpression> | null,\n): node is t.AwaitExpression {\n  if (!node) return false;\n\n  if (node.type !== \"AwaitExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isImport(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.Import> | null,\n): node is t.Import {\n  if (!node) return false;\n\n  if (node.type !== \"Import\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBigIntLiteral(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.BigIntLiteral> | null,\n): node is t.BigIntLiteral {\n  if (!node) return false;\n\n  if (node.type !== \"BigIntLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExportNamespaceSpecifier(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ExportNamespaceSpecifier> | null,\n): node is t.ExportNamespaceSpecifier {\n  if (!node) return false;\n\n  if (node.type !== \"ExportNamespaceSpecifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isOptionalMemberExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.OptionalMemberExpression> | null,\n): node is t.OptionalMemberExpression {\n  if (!node) return false;\n\n  if (node.type !== \"OptionalMemberExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isOptionalCallExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.OptionalCallExpression> | null,\n): node is t.OptionalCallExpression {\n  if (!node) return false;\n\n  if (node.type !== \"OptionalCallExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClassProperty(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ClassProperty> | null,\n): node is t.ClassProperty {\n  if (!node) return false;\n\n  if (node.type !== \"ClassProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClassAccessorProperty(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ClassAccessorProperty> | null,\n): node is t.ClassAccessorProperty {\n  if (!node) return false;\n\n  if (node.type !== \"ClassAccessorProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClassPrivateProperty(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ClassPrivateProperty> | null,\n): node is t.ClassPrivateProperty {\n  if (!node) return false;\n\n  if (node.type !== \"ClassPrivateProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClassPrivateMethod(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ClassPrivateMethod> | null,\n): node is t.ClassPrivateMethod {\n  if (!node) return false;\n\n  if (node.type !== \"ClassPrivateMethod\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isPrivateName(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.PrivateName> | null,\n): node is t.PrivateName {\n  if (!node) return false;\n\n  if (node.type !== \"PrivateName\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isStaticBlock(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.StaticBlock> | null,\n): node is t.StaticBlock {\n  if (!node) return false;\n\n  if (node.type !== \"StaticBlock\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isAnyTypeAnnotation(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.AnyTypeAnnotation> | null,\n): node is t.AnyTypeAnnotation {\n  if (!node) return false;\n\n  if (node.type !== \"AnyTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isArrayTypeAnnotation(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ArrayTypeAnnotation> | null,\n): node is t.ArrayTypeAnnotation {\n  if (!node) return false;\n\n  if (node.type !== \"ArrayTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBooleanTypeAnnotation(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.BooleanTypeAnnotation> | null,\n): node is t.BooleanTypeAnnotation {\n  if (!node) return false;\n\n  if (node.type !== \"BooleanTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBooleanLiteralTypeAnnotation(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.BooleanLiteralTypeAnnotation> | null,\n): node is t.BooleanLiteralTypeAnnotation {\n  if (!node) return false;\n\n  if (node.type !== \"BooleanLiteralTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isNullLiteralTypeAnnotation(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.NullLiteralTypeAnnotation> | null,\n): node is t.NullLiteralTypeAnnotation {\n  if (!node) return false;\n\n  if (node.type !== \"NullLiteralTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClassImplements(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ClassImplements> | null,\n): node is t.ClassImplements {\n  if (!node) return false;\n\n  if (node.type !== \"ClassImplements\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareClass(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.DeclareClass> | null,\n): node is t.DeclareClass {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareClass\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareFunction(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.DeclareFunction> | null,\n): node is t.DeclareFunction {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareFunction\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareInterface(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.DeclareInterface> | null,\n): node is t.DeclareInterface {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareInterface\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareModule(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.DeclareModule> | null,\n): node is t.DeclareModule {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareModule\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareModuleExports(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.DeclareModuleExports> | null,\n): node is t.DeclareModuleExports {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareModuleExports\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareTypeAlias(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.DeclareTypeAlias> | null,\n): node is t.DeclareTypeAlias {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareTypeAlias\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareOpaqueType(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.DeclareOpaqueType> | null,\n): node is t.DeclareOpaqueType {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareOpaqueType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareVariable(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.DeclareVariable> | null,\n): node is t.DeclareVariable {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareVariable\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareExportDeclaration(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.DeclareExportDeclaration> | null,\n): node is t.DeclareExportDeclaration {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareExportDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareExportAllDeclaration(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.DeclareExportAllDeclaration> | null,\n): node is t.DeclareExportAllDeclaration {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareExportAllDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclaredPredicate(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.DeclaredPredicate> | null,\n): node is t.DeclaredPredicate {\n  if (!node) return false;\n\n  if (node.type !== \"DeclaredPredicate\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExistsTypeAnnotation(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ExistsTypeAnnotation> | null,\n): node is t.ExistsTypeAnnotation {\n  if (!node) return false;\n\n  if (node.type !== \"ExistsTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFunctionTypeAnnotation(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.FunctionTypeAnnotation> | null,\n): node is t.FunctionTypeAnnotation {\n  if (!node) return false;\n\n  if (node.type !== \"FunctionTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFunctionTypeParam(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.FunctionTypeParam> | null,\n): node is t.FunctionTypeParam {\n  if (!node) return false;\n\n  if (node.type !== \"FunctionTypeParam\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isGenericTypeAnnotation(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.GenericTypeAnnotation> | null,\n): node is t.GenericTypeAnnotation {\n  if (!node) return false;\n\n  if (node.type !== \"GenericTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isInferredPredicate(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.InferredPredicate> | null,\n): node is t.InferredPredicate {\n  if (!node) return false;\n\n  if (node.type !== \"InferredPredicate\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isInterfaceExtends(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.InterfaceExtends> | null,\n): node is t.InterfaceExtends {\n  if (!node) return false;\n\n  if (node.type !== \"InterfaceExtends\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isInterfaceDeclaration(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.InterfaceDeclaration> | null,\n): node is t.InterfaceDeclaration {\n  if (!node) return false;\n\n  if (node.type !== \"InterfaceDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isInterfaceTypeAnnotation(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.InterfaceTypeAnnotation> | null,\n): node is t.InterfaceTypeAnnotation {\n  if (!node) return false;\n\n  if (node.type !== \"InterfaceTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isIntersectionTypeAnnotation(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.IntersectionTypeAnnotation> | null,\n): node is t.IntersectionTypeAnnotation {\n  if (!node) return false;\n\n  if (node.type !== \"IntersectionTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isMixedTypeAnnotation(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.MixedTypeAnnotation> | null,\n): node is t.MixedTypeAnnotation {\n  if (!node) return false;\n\n  if (node.type !== \"MixedTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEmptyTypeAnnotation(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.EmptyTypeAnnotation> | null,\n): node is t.EmptyTypeAnnotation {\n  if (!node) return false;\n\n  if (node.type !== \"EmptyTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isNullableTypeAnnotation(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.NullableTypeAnnotation> | null,\n): node is t.NullableTypeAnnotation {\n  if (!node) return false;\n\n  if (node.type !== \"NullableTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isNumberLiteralTypeAnnotation(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.NumberLiteralTypeAnnotation> | null,\n): node is t.NumberLiteralTypeAnnotation {\n  if (!node) return false;\n\n  if (node.type !== \"NumberLiteralTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isNumberTypeAnnotation(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.NumberTypeAnnotation> | null,\n): node is t.NumberTypeAnnotation {\n  if (!node) return false;\n\n  if (node.type !== \"NumberTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectTypeAnnotation(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ObjectTypeAnnotation> | null,\n): node is t.ObjectTypeAnnotation {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectTypeInternalSlot(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ObjectTypeInternalSlot> | null,\n): node is t.ObjectTypeInternalSlot {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectTypeInternalSlot\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectTypeCallProperty(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ObjectTypeCallProperty> | null,\n): node is t.ObjectTypeCallProperty {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectTypeCallProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectTypeIndexer(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ObjectTypeIndexer> | null,\n): node is t.ObjectTypeIndexer {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectTypeIndexer\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectTypeProperty(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ObjectTypeProperty> | null,\n): node is t.ObjectTypeProperty {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectTypeProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectTypeSpreadProperty(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ObjectTypeSpreadProperty> | null,\n): node is t.ObjectTypeSpreadProperty {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectTypeSpreadProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isOpaqueType(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.OpaqueType> | null,\n): node is t.OpaqueType {\n  if (!node) return false;\n\n  if (node.type !== \"OpaqueType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isQualifiedTypeIdentifier(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.QualifiedTypeIdentifier> | null,\n): node is t.QualifiedTypeIdentifier {\n  if (!node) return false;\n\n  if (node.type !== \"QualifiedTypeIdentifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isStringLiteralTypeAnnotation(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.StringLiteralTypeAnnotation> | null,\n): node is t.StringLiteralTypeAnnotation {\n  if (!node) return false;\n\n  if (node.type !== \"StringLiteralTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isStringTypeAnnotation(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.StringTypeAnnotation> | null,\n): node is t.StringTypeAnnotation {\n  if (!node) return false;\n\n  if (node.type !== \"StringTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isSymbolTypeAnnotation(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.SymbolTypeAnnotation> | null,\n): node is t.SymbolTypeAnnotation {\n  if (!node) return false;\n\n  if (node.type !== \"SymbolTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isThisTypeAnnotation(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ThisTypeAnnotation> | null,\n): node is t.ThisTypeAnnotation {\n  if (!node) return false;\n\n  if (node.type !== \"ThisTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTupleTypeAnnotation(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TupleTypeAnnotation> | null,\n): node is t.TupleTypeAnnotation {\n  if (!node) return false;\n\n  if (node.type !== \"TupleTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTypeofTypeAnnotation(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TypeofTypeAnnotation> | null,\n): node is t.TypeofTypeAnnotation {\n  if (!node) return false;\n\n  if (node.type !== \"TypeofTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTypeAlias(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TypeAlias> | null,\n): node is t.TypeAlias {\n  if (!node) return false;\n\n  if (node.type !== \"TypeAlias\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTypeAnnotation(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TypeAnnotation> | null,\n): node is t.TypeAnnotation {\n  if (!node) return false;\n\n  if (node.type !== \"TypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTypeCastExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TypeCastExpression> | null,\n): node is t.TypeCastExpression {\n  if (!node) return false;\n\n  if (node.type !== \"TypeCastExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTypeParameter(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TypeParameter> | null,\n): node is t.TypeParameter {\n  if (!node) return false;\n\n  if (node.type !== \"TypeParameter\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTypeParameterDeclaration(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TypeParameterDeclaration> | null,\n): node is t.TypeParameterDeclaration {\n  if (!node) return false;\n\n  if (node.type !== \"TypeParameterDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTypeParameterInstantiation(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TypeParameterInstantiation> | null,\n): node is t.TypeParameterInstantiation {\n  if (!node) return false;\n\n  if (node.type !== \"TypeParameterInstantiation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isUnionTypeAnnotation(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.UnionTypeAnnotation> | null,\n): node is t.UnionTypeAnnotation {\n  if (!node) return false;\n\n  if (node.type !== \"UnionTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isVariance(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.Variance> | null,\n): node is t.Variance {\n  if (!node) return false;\n\n  if (node.type !== \"Variance\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isVoidTypeAnnotation(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.VoidTypeAnnotation> | null,\n): node is t.VoidTypeAnnotation {\n  if (!node) return false;\n\n  if (node.type !== \"VoidTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumDeclaration(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.EnumDeclaration> | null,\n): node is t.EnumDeclaration {\n  if (!node) return false;\n\n  if (node.type !== \"EnumDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumBooleanBody(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.EnumBooleanBody> | null,\n): node is t.EnumBooleanBody {\n  if (!node) return false;\n\n  if (node.type !== \"EnumBooleanBody\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumNumberBody(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.EnumNumberBody> | null,\n): node is t.EnumNumberBody {\n  if (!node) return false;\n\n  if (node.type !== \"EnumNumberBody\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumStringBody(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.EnumStringBody> | null,\n): node is t.EnumStringBody {\n  if (!node) return false;\n\n  if (node.type !== \"EnumStringBody\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumSymbolBody(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.EnumSymbolBody> | null,\n): node is t.EnumSymbolBody {\n  if (!node) return false;\n\n  if (node.type !== \"EnumSymbolBody\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumBooleanMember(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.EnumBooleanMember> | null,\n): node is t.EnumBooleanMember {\n  if (!node) return false;\n\n  if (node.type !== \"EnumBooleanMember\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumNumberMember(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.EnumNumberMember> | null,\n): node is t.EnumNumberMember {\n  if (!node) return false;\n\n  if (node.type !== \"EnumNumberMember\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumStringMember(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.EnumStringMember> | null,\n): node is t.EnumStringMember {\n  if (!node) return false;\n\n  if (node.type !== \"EnumStringMember\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumDefaultedMember(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.EnumDefaultedMember> | null,\n): node is t.EnumDefaultedMember {\n  if (!node) return false;\n\n  if (node.type !== \"EnumDefaultedMember\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isIndexedAccessType(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.IndexedAccessType> | null,\n): node is t.IndexedAccessType {\n  if (!node) return false;\n\n  if (node.type !== \"IndexedAccessType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isOptionalIndexedAccessType(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.OptionalIndexedAccessType> | null,\n): node is t.OptionalIndexedAccessType {\n  if (!node) return false;\n\n  if (node.type !== \"OptionalIndexedAccessType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXAttribute(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.JSXAttribute> | null,\n): node is t.JSXAttribute {\n  if (!node) return false;\n\n  if (node.type !== \"JSXAttribute\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXClosingElement(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.JSXClosingElement> | null,\n): node is t.JSXClosingElement {\n  if (!node) return false;\n\n  if (node.type !== \"JSXClosingElement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXElement(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.JSXElement> | null,\n): node is t.JSXElement {\n  if (!node) return false;\n\n  if (node.type !== \"JSXElement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXEmptyExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.JSXEmptyExpression> | null,\n): node is t.JSXEmptyExpression {\n  if (!node) return false;\n\n  if (node.type !== \"JSXEmptyExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXExpressionContainer(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.JSXExpressionContainer> | null,\n): node is t.JSXExpressionContainer {\n  if (!node) return false;\n\n  if (node.type !== \"JSXExpressionContainer\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXSpreadChild(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.JSXSpreadChild> | null,\n): node is t.JSXSpreadChild {\n  if (!node) return false;\n\n  if (node.type !== \"JSXSpreadChild\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXIdentifier(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.JSXIdentifier> | null,\n): node is t.JSXIdentifier {\n  if (!node) return false;\n\n  if (node.type !== \"JSXIdentifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXMemberExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.JSXMemberExpression> | null,\n): node is t.JSXMemberExpression {\n  if (!node) return false;\n\n  if (node.type !== \"JSXMemberExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXNamespacedName(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.JSXNamespacedName> | null,\n): node is t.JSXNamespacedName {\n  if (!node) return false;\n\n  if (node.type !== \"JSXNamespacedName\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXOpeningElement(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.JSXOpeningElement> | null,\n): node is t.JSXOpeningElement {\n  if (!node) return false;\n\n  if (node.type !== \"JSXOpeningElement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXSpreadAttribute(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.JSXSpreadAttribute> | null,\n): node is t.JSXSpreadAttribute {\n  if (!node) return false;\n\n  if (node.type !== \"JSXSpreadAttribute\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXText(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.JSXText> | null,\n): node is t.JSXText {\n  if (!node) return false;\n\n  if (node.type !== \"JSXText\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXFragment(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.JSXFragment> | null,\n): node is t.JSXFragment {\n  if (!node) return false;\n\n  if (node.type !== \"JSXFragment\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXOpeningFragment(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.JSXOpeningFragment> | null,\n): node is t.JSXOpeningFragment {\n  if (!node) return false;\n\n  if (node.type !== \"JSXOpeningFragment\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXClosingFragment(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.JSXClosingFragment> | null,\n): node is t.JSXClosingFragment {\n  if (!node) return false;\n\n  if (node.type !== \"JSXClosingFragment\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isNoop(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.Noop> | null,\n): node is t.Noop {\n  if (!node) return false;\n\n  if (node.type !== \"Noop\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isPlaceholder(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.Placeholder> | null,\n): node is t.Placeholder {\n  if (!node) return false;\n\n  if (node.type !== \"Placeholder\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isV8IntrinsicIdentifier(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.V8IntrinsicIdentifier> | null,\n): node is t.V8IntrinsicIdentifier {\n  if (!node) return false;\n\n  if (node.type !== \"V8IntrinsicIdentifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isArgumentPlaceholder(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ArgumentPlaceholder> | null,\n): node is t.ArgumentPlaceholder {\n  if (!node) return false;\n\n  if (node.type !== \"ArgumentPlaceholder\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBindExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.BindExpression> | null,\n): node is t.BindExpression {\n  if (!node) return false;\n\n  if (node.type !== \"BindExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isImportAttribute(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ImportAttribute> | null,\n): node is t.ImportAttribute {\n  if (!node) return false;\n\n  if (node.type !== \"ImportAttribute\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDecorator(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.Decorator> | null,\n): node is t.Decorator {\n  if (!node) return false;\n\n  if (node.type !== \"Decorator\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDoExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.DoExpression> | null,\n): node is t.DoExpression {\n  if (!node) return false;\n\n  if (node.type !== \"DoExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExportDefaultSpecifier(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ExportDefaultSpecifier> | null,\n): node is t.ExportDefaultSpecifier {\n  if (!node) return false;\n\n  if (node.type !== \"ExportDefaultSpecifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isRecordExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.RecordExpression> | null,\n): node is t.RecordExpression {\n  if (!node) return false;\n\n  if (node.type !== \"RecordExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTupleExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TupleExpression> | null,\n): node is t.TupleExpression {\n  if (!node) return false;\n\n  if (node.type !== \"TupleExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDecimalLiteral(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.DecimalLiteral> | null,\n): node is t.DecimalLiteral {\n  if (!node) return false;\n\n  if (node.type !== \"DecimalLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isModuleExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ModuleExpression> | null,\n): node is t.ModuleExpression {\n  if (!node) return false;\n\n  if (node.type !== \"ModuleExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTopicReference(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TopicReference> | null,\n): node is t.TopicReference {\n  if (!node) return false;\n\n  if (node.type !== \"TopicReference\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isPipelineTopicExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.PipelineTopicExpression> | null,\n): node is t.PipelineTopicExpression {\n  if (!node) return false;\n\n  if (node.type !== \"PipelineTopicExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isPipelineBareFunction(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.PipelineBareFunction> | null,\n): node is t.PipelineBareFunction {\n  if (!node) return false;\n\n  if (node.type !== \"PipelineBareFunction\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isPipelinePrimaryTopicReference(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.PipelinePrimaryTopicReference> | null,\n): node is t.PipelinePrimaryTopicReference {\n  if (!node) return false;\n\n  if (node.type !== \"PipelinePrimaryTopicReference\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSParameterProperty(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSParameterProperty> | null,\n): node is t.TSParameterProperty {\n  if (!node) return false;\n\n  if (node.type !== \"TSParameterProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSDeclareFunction(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSDeclareFunction> | null,\n): node is t.TSDeclareFunction {\n  if (!node) return false;\n\n  if (node.type !== \"TSDeclareFunction\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSDeclareMethod(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSDeclareMethod> | null,\n): node is t.TSDeclareMethod {\n  if (!node) return false;\n\n  if (node.type !== \"TSDeclareMethod\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSQualifiedName(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSQualifiedName> | null,\n): node is t.TSQualifiedName {\n  if (!node) return false;\n\n  if (node.type !== \"TSQualifiedName\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSCallSignatureDeclaration(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSCallSignatureDeclaration> | null,\n): node is t.TSCallSignatureDeclaration {\n  if (!node) return false;\n\n  if (node.type !== \"TSCallSignatureDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSConstructSignatureDeclaration(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSConstructSignatureDeclaration> | null,\n): node is t.TSConstructSignatureDeclaration {\n  if (!node) return false;\n\n  if (node.type !== \"TSConstructSignatureDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSPropertySignature(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSPropertySignature> | null,\n): node is t.TSPropertySignature {\n  if (!node) return false;\n\n  if (node.type !== \"TSPropertySignature\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSMethodSignature(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSMethodSignature> | null,\n): node is t.TSMethodSignature {\n  if (!node) return false;\n\n  if (node.type !== \"TSMethodSignature\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSIndexSignature(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSIndexSignature> | null,\n): node is t.TSIndexSignature {\n  if (!node) return false;\n\n  if (node.type !== \"TSIndexSignature\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSAnyKeyword(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSAnyKeyword> | null,\n): node is t.TSAnyKeyword {\n  if (!node) return false;\n\n  if (node.type !== \"TSAnyKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSBooleanKeyword(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSBooleanKeyword> | null,\n): node is t.TSBooleanKeyword {\n  if (!node) return false;\n\n  if (node.type !== \"TSBooleanKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSBigIntKeyword(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSBigIntKeyword> | null,\n): node is t.TSBigIntKeyword {\n  if (!node) return false;\n\n  if (node.type !== \"TSBigIntKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSIntrinsicKeyword(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSIntrinsicKeyword> | null,\n): node is t.TSIntrinsicKeyword {\n  if (!node) return false;\n\n  if (node.type !== \"TSIntrinsicKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSNeverKeyword(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSNeverKeyword> | null,\n): node is t.TSNeverKeyword {\n  if (!node) return false;\n\n  if (node.type !== \"TSNeverKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSNullKeyword(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSNullKeyword> | null,\n): node is t.TSNullKeyword {\n  if (!node) return false;\n\n  if (node.type !== \"TSNullKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSNumberKeyword(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSNumberKeyword> | null,\n): node is t.TSNumberKeyword {\n  if (!node) return false;\n\n  if (node.type !== \"TSNumberKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSObjectKeyword(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSObjectKeyword> | null,\n): node is t.TSObjectKeyword {\n  if (!node) return false;\n\n  if (node.type !== \"TSObjectKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSStringKeyword(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSStringKeyword> | null,\n): node is t.TSStringKeyword {\n  if (!node) return false;\n\n  if (node.type !== \"TSStringKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSSymbolKeyword(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSSymbolKeyword> | null,\n): node is t.TSSymbolKeyword {\n  if (!node) return false;\n\n  if (node.type !== \"TSSymbolKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSUndefinedKeyword(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSUndefinedKeyword> | null,\n): node is t.TSUndefinedKeyword {\n  if (!node) return false;\n\n  if (node.type !== \"TSUndefinedKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSUnknownKeyword(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSUnknownKeyword> | null,\n): node is t.TSUnknownKeyword {\n  if (!node) return false;\n\n  if (node.type !== \"TSUnknownKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSVoidKeyword(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSVoidKeyword> | null,\n): node is t.TSVoidKeyword {\n  if (!node) return false;\n\n  if (node.type !== \"TSVoidKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSThisType(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSThisType> | null,\n): node is t.TSThisType {\n  if (!node) return false;\n\n  if (node.type !== \"TSThisType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSFunctionType(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSFunctionType> | null,\n): node is t.TSFunctionType {\n  if (!node) return false;\n\n  if (node.type !== \"TSFunctionType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSConstructorType(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSConstructorType> | null,\n): node is t.TSConstructorType {\n  if (!node) return false;\n\n  if (node.type !== \"TSConstructorType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeReference(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSTypeReference> | null,\n): node is t.TSTypeReference {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeReference\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypePredicate(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSTypePredicate> | null,\n): node is t.TSTypePredicate {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypePredicate\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeQuery(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSTypeQuery> | null,\n): node is t.TSTypeQuery {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeQuery\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeLiteral(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSTypeLiteral> | null,\n): node is t.TSTypeLiteral {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSArrayType(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSArrayType> | null,\n): node is t.TSArrayType {\n  if (!node) return false;\n\n  if (node.type !== \"TSArrayType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTupleType(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSTupleType> | null,\n): node is t.TSTupleType {\n  if (!node) return false;\n\n  if (node.type !== \"TSTupleType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSOptionalType(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSOptionalType> | null,\n): node is t.TSOptionalType {\n  if (!node) return false;\n\n  if (node.type !== \"TSOptionalType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSRestType(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSRestType> | null,\n): node is t.TSRestType {\n  if (!node) return false;\n\n  if (node.type !== \"TSRestType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSNamedTupleMember(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSNamedTupleMember> | null,\n): node is t.TSNamedTupleMember {\n  if (!node) return false;\n\n  if (node.type !== \"TSNamedTupleMember\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSUnionType(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSUnionType> | null,\n): node is t.TSUnionType {\n  if (!node) return false;\n\n  if (node.type !== \"TSUnionType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSIntersectionType(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSIntersectionType> | null,\n): node is t.TSIntersectionType {\n  if (!node) return false;\n\n  if (node.type !== \"TSIntersectionType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSConditionalType(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSConditionalType> | null,\n): node is t.TSConditionalType {\n  if (!node) return false;\n\n  if (node.type !== \"TSConditionalType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSInferType(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSInferType> | null,\n): node is t.TSInferType {\n  if (!node) return false;\n\n  if (node.type !== \"TSInferType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSParenthesizedType(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSParenthesizedType> | null,\n): node is t.TSParenthesizedType {\n  if (!node) return false;\n\n  if (node.type !== \"TSParenthesizedType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeOperator(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSTypeOperator> | null,\n): node is t.TSTypeOperator {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeOperator\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSIndexedAccessType(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSIndexedAccessType> | null,\n): node is t.TSIndexedAccessType {\n  if (!node) return false;\n\n  if (node.type !== \"TSIndexedAccessType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSMappedType(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSMappedType> | null,\n): node is t.TSMappedType {\n  if (!node) return false;\n\n  if (node.type !== \"TSMappedType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSLiteralType(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSLiteralType> | null,\n): node is t.TSLiteralType {\n  if (!node) return false;\n\n  if (node.type !== \"TSLiteralType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSExpressionWithTypeArguments(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSExpressionWithTypeArguments> | null,\n): node is t.TSExpressionWithTypeArguments {\n  if (!node) return false;\n\n  if (node.type !== \"TSExpressionWithTypeArguments\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSInterfaceDeclaration(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSInterfaceDeclaration> | null,\n): node is t.TSInterfaceDeclaration {\n  if (!node) return false;\n\n  if (node.type !== \"TSInterfaceDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSInterfaceBody(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSInterfaceBody> | null,\n): node is t.TSInterfaceBody {\n  if (!node) return false;\n\n  if (node.type !== \"TSInterfaceBody\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeAliasDeclaration(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSTypeAliasDeclaration> | null,\n): node is t.TSTypeAliasDeclaration {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeAliasDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSInstantiationExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSInstantiationExpression> | null,\n): node is t.TSInstantiationExpression {\n  if (!node) return false;\n\n  if (node.type !== \"TSInstantiationExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSAsExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSAsExpression> | null,\n): node is t.TSAsExpression {\n  if (!node) return false;\n\n  if (node.type !== \"TSAsExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSSatisfiesExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSSatisfiesExpression> | null,\n): node is t.TSSatisfiesExpression {\n  if (!node) return false;\n\n  if (node.type !== \"TSSatisfiesExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeAssertion(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSTypeAssertion> | null,\n): node is t.TSTypeAssertion {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeAssertion\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSEnumDeclaration(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSEnumDeclaration> | null,\n): node is t.TSEnumDeclaration {\n  if (!node) return false;\n\n  if (node.type !== \"TSEnumDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSEnumMember(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSEnumMember> | null,\n): node is t.TSEnumMember {\n  if (!node) return false;\n\n  if (node.type !== \"TSEnumMember\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSModuleDeclaration(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSModuleDeclaration> | null,\n): node is t.TSModuleDeclaration {\n  if (!node) return false;\n\n  if (node.type !== \"TSModuleDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSModuleBlock(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSModuleBlock> | null,\n): node is t.TSModuleBlock {\n  if (!node) return false;\n\n  if (node.type !== \"TSModuleBlock\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSImportType(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSImportType> | null,\n): node is t.TSImportType {\n  if (!node) return false;\n\n  if (node.type !== \"TSImportType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSImportEqualsDeclaration(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSImportEqualsDeclaration> | null,\n): node is t.TSImportEqualsDeclaration {\n  if (!node) return false;\n\n  if (node.type !== \"TSImportEqualsDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSExternalModuleReference(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSExternalModuleReference> | null,\n): node is t.TSExternalModuleReference {\n  if (!node) return false;\n\n  if (node.type !== \"TSExternalModuleReference\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSNonNullExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSNonNullExpression> | null,\n): node is t.TSNonNullExpression {\n  if (!node) return false;\n\n  if (node.type !== \"TSNonNullExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSExportAssignment(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSExportAssignment> | null,\n): node is t.TSExportAssignment {\n  if (!node) return false;\n\n  if (node.type !== \"TSExportAssignment\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSNamespaceExportDeclaration(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSNamespaceExportDeclaration> | null,\n): node is t.TSNamespaceExportDeclaration {\n  if (!node) return false;\n\n  if (node.type !== \"TSNamespaceExportDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeAnnotation(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSTypeAnnotation> | null,\n): node is t.TSTypeAnnotation {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeParameterInstantiation(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSTypeParameterInstantiation> | null,\n): node is t.TSTypeParameterInstantiation {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeParameterInstantiation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeParameterDeclaration(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSTypeParameterDeclaration> | null,\n): node is t.TSTypeParameterDeclaration {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeParameterDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeParameter(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSTypeParameter> | null,\n): node is t.TSTypeParameter {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeParameter\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isStandardized(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.Standardized> | null,\n): node is t.Standardized {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ArrayExpression\":\n    case \"AssignmentExpression\":\n    case \"BinaryExpression\":\n    case \"InterpreterDirective\":\n    case \"Directive\":\n    case \"DirectiveLiteral\":\n    case \"BlockStatement\":\n    case \"BreakStatement\":\n    case \"CallExpression\":\n    case \"CatchClause\":\n    case \"ConditionalExpression\":\n    case \"ContinueStatement\":\n    case \"DebuggerStatement\":\n    case \"DoWhileStatement\":\n    case \"EmptyStatement\":\n    case \"ExpressionStatement\":\n    case \"File\":\n    case \"ForInStatement\":\n    case \"ForStatement\":\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"Identifier\":\n    case \"IfStatement\":\n    case \"LabeledStatement\":\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"RegExpLiteral\":\n    case \"LogicalExpression\":\n    case \"MemberExpression\":\n    case \"NewExpression\":\n    case \"Program\":\n    case \"ObjectExpression\":\n    case \"ObjectMethod\":\n    case \"ObjectProperty\":\n    case \"RestElement\":\n    case \"ReturnStatement\":\n    case \"SequenceExpression\":\n    case \"ParenthesizedExpression\":\n    case \"SwitchCase\":\n    case \"SwitchStatement\":\n    case \"ThisExpression\":\n    case \"ThrowStatement\":\n    case \"TryStatement\":\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n    case \"VariableDeclaration\":\n    case \"VariableDeclarator\":\n    case \"WhileStatement\":\n    case \"WithStatement\":\n    case \"AssignmentPattern\":\n    case \"ArrayPattern\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassBody\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n    case \"ExportAllDeclaration\":\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n    case \"ExportSpecifier\":\n    case \"ForOfStatement\":\n    case \"ImportDeclaration\":\n    case \"ImportDefaultSpecifier\":\n    case \"ImportNamespaceSpecifier\":\n    case \"ImportSpecifier\":\n    case \"ImportExpression\":\n    case \"MetaProperty\":\n    case \"ClassMethod\":\n    case \"ObjectPattern\":\n    case \"SpreadElement\":\n    case \"Super\":\n    case \"TaggedTemplateExpression\":\n    case \"TemplateElement\":\n    case \"TemplateLiteral\":\n    case \"YieldExpression\":\n    case \"AwaitExpression\":\n    case \"Import\":\n    case \"BigIntLiteral\":\n    case \"ExportNamespaceSpecifier\":\n    case \"OptionalMemberExpression\":\n    case \"OptionalCallExpression\":\n    case \"ClassProperty\":\n    case \"ClassAccessorProperty\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n    case \"PrivateName\":\n    case \"StaticBlock\":\n      break;\n    case \"Placeholder\":\n      switch (node.expectedNode) {\n        case \"Identifier\":\n        case \"StringLiteral\":\n        case \"BlockStatement\":\n        case \"ClassBody\":\n          break;\n        default:\n          return false;\n      }\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExpression(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.Expression> | null,\n): node is t.Expression {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ArrayExpression\":\n    case \"AssignmentExpression\":\n    case \"BinaryExpression\":\n    case \"CallExpression\":\n    case \"ConditionalExpression\":\n    case \"FunctionExpression\":\n    case \"Identifier\":\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"RegExpLiteral\":\n    case \"LogicalExpression\":\n    case \"MemberExpression\":\n    case \"NewExpression\":\n    case \"ObjectExpression\":\n    case \"SequenceExpression\":\n    case \"ParenthesizedExpression\":\n    case \"ThisExpression\":\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassExpression\":\n    case \"ImportExpression\":\n    case \"MetaProperty\":\n    case \"Super\":\n    case \"TaggedTemplateExpression\":\n    case \"TemplateLiteral\":\n    case \"YieldExpression\":\n    case \"AwaitExpression\":\n    case \"Import\":\n    case \"BigIntLiteral\":\n    case \"OptionalMemberExpression\":\n    case \"OptionalCallExpression\":\n    case \"TypeCastExpression\":\n    case \"JSXElement\":\n    case \"JSXFragment\":\n    case \"BindExpression\":\n    case \"DoExpression\":\n    case \"RecordExpression\":\n    case \"TupleExpression\":\n    case \"DecimalLiteral\":\n    case \"ModuleExpression\":\n    case \"TopicReference\":\n    case \"PipelineTopicExpression\":\n    case \"PipelineBareFunction\":\n    case \"PipelinePrimaryTopicReference\":\n    case \"TSInstantiationExpression\":\n    case \"TSAsExpression\":\n    case \"TSSatisfiesExpression\":\n    case \"TSTypeAssertion\":\n    case \"TSNonNullExpression\":\n      break;\n    case \"Placeholder\":\n      switch (node.expectedNode) {\n        case \"Expression\":\n        case \"Identifier\":\n        case \"StringLiteral\":\n          break;\n        default:\n          return false;\n      }\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBinary(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.Binary> | null,\n): node is t.Binary {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"BinaryExpression\":\n    case \"LogicalExpression\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isScopable(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.Scopable> | null,\n): node is t.Scopable {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"BlockStatement\":\n    case \"CatchClause\":\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForStatement\":\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"Program\":\n    case \"ObjectMethod\":\n    case \"SwitchStatement\":\n    case \"WhileStatement\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n    case \"ForOfStatement\":\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n    case \"StaticBlock\":\n    case \"TSModuleBlock\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"BlockStatement\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBlockParent(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.BlockParent> | null,\n): node is t.BlockParent {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"BlockStatement\":\n    case \"CatchClause\":\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForStatement\":\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"Program\":\n    case \"ObjectMethod\":\n    case \"SwitchStatement\":\n    case \"WhileStatement\":\n    case \"ArrowFunctionExpression\":\n    case \"ForOfStatement\":\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n    case \"StaticBlock\":\n    case \"TSModuleBlock\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"BlockStatement\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBlock(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.Block> | null,\n): node is t.Block {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"BlockStatement\":\n    case \"Program\":\n    case \"TSModuleBlock\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"BlockStatement\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isStatement(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.Statement> | null,\n): node is t.Statement {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"BlockStatement\":\n    case \"BreakStatement\":\n    case \"ContinueStatement\":\n    case \"DebuggerStatement\":\n    case \"DoWhileStatement\":\n    case \"EmptyStatement\":\n    case \"ExpressionStatement\":\n    case \"ForInStatement\":\n    case \"ForStatement\":\n    case \"FunctionDeclaration\":\n    case \"IfStatement\":\n    case \"LabeledStatement\":\n    case \"ReturnStatement\":\n    case \"SwitchStatement\":\n    case \"ThrowStatement\":\n    case \"TryStatement\":\n    case \"VariableDeclaration\":\n    case \"WhileStatement\":\n    case \"WithStatement\":\n    case \"ClassDeclaration\":\n    case \"ExportAllDeclaration\":\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n    case \"ForOfStatement\":\n    case \"ImportDeclaration\":\n    case \"DeclareClass\":\n    case \"DeclareFunction\":\n    case \"DeclareInterface\":\n    case \"DeclareModule\":\n    case \"DeclareModuleExports\":\n    case \"DeclareTypeAlias\":\n    case \"DeclareOpaqueType\":\n    case \"DeclareVariable\":\n    case \"DeclareExportDeclaration\":\n    case \"DeclareExportAllDeclaration\":\n    case \"InterfaceDeclaration\":\n    case \"OpaqueType\":\n    case \"TypeAlias\":\n    case \"EnumDeclaration\":\n    case \"TSDeclareFunction\":\n    case \"TSInterfaceDeclaration\":\n    case \"TSTypeAliasDeclaration\":\n    case \"TSEnumDeclaration\":\n    case \"TSModuleDeclaration\":\n    case \"TSImportEqualsDeclaration\":\n    case \"TSExportAssignment\":\n    case \"TSNamespaceExportDeclaration\":\n      break;\n    case \"Placeholder\":\n      switch (node.expectedNode) {\n        case \"Statement\":\n        case \"Declaration\":\n        case \"BlockStatement\":\n          break;\n        default:\n          return false;\n      }\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTerminatorless(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.Terminatorless> | null,\n): node is t.Terminatorless {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"BreakStatement\":\n    case \"ContinueStatement\":\n    case \"ReturnStatement\":\n    case \"ThrowStatement\":\n    case \"YieldExpression\":\n    case \"AwaitExpression\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isCompletionStatement(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.CompletionStatement> | null,\n): node is t.CompletionStatement {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"BreakStatement\":\n    case \"ContinueStatement\":\n    case \"ReturnStatement\":\n    case \"ThrowStatement\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isConditional(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.Conditional> | null,\n): node is t.Conditional {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isLoop(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.Loop> | null,\n): node is t.Loop {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForStatement\":\n    case \"WhileStatement\":\n    case \"ForOfStatement\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isWhile(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.While> | null,\n): node is t.While {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"DoWhileStatement\":\n    case \"WhileStatement\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExpressionWrapper(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ExpressionWrapper> | null,\n): node is t.ExpressionWrapper {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ExpressionStatement\":\n    case \"ParenthesizedExpression\":\n    case \"TypeCastExpression\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFor(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.For> | null,\n): node is t.For {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ForInStatement\":\n    case \"ForStatement\":\n    case \"ForOfStatement\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isForXStatement(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ForXStatement> | null,\n): node is t.ForXStatement {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFunction(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.Function> | null,\n): node is t.Function {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ObjectMethod\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFunctionParent(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.FunctionParent> | null,\n): node is t.FunctionParent {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ObjectMethod\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n    case \"StaticBlock\":\n    case \"TSModuleBlock\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isPureish(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.Pureish> | null,\n): node is t.Pureish {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"RegExpLiteral\":\n    case \"ArrowFunctionExpression\":\n    case \"BigIntLiteral\":\n    case \"DecimalLiteral\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"StringLiteral\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclaration(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.Declaration> | null,\n): node is t.Declaration {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"FunctionDeclaration\":\n    case \"VariableDeclaration\":\n    case \"ClassDeclaration\":\n    case \"ExportAllDeclaration\":\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n    case \"ImportDeclaration\":\n    case \"DeclareClass\":\n    case \"DeclareFunction\":\n    case \"DeclareInterface\":\n    case \"DeclareModule\":\n    case \"DeclareModuleExports\":\n    case \"DeclareTypeAlias\":\n    case \"DeclareOpaqueType\":\n    case \"DeclareVariable\":\n    case \"DeclareExportDeclaration\":\n    case \"DeclareExportAllDeclaration\":\n    case \"InterfaceDeclaration\":\n    case \"OpaqueType\":\n    case \"TypeAlias\":\n    case \"EnumDeclaration\":\n    case \"TSDeclareFunction\":\n    case \"TSInterfaceDeclaration\":\n    case \"TSTypeAliasDeclaration\":\n    case \"TSEnumDeclaration\":\n    case \"TSModuleDeclaration\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"Declaration\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isPatternLike(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.PatternLike> | null,\n): node is t.PatternLike {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"Identifier\":\n    case \"RestElement\":\n    case \"AssignmentPattern\":\n    case \"ArrayPattern\":\n    case \"ObjectPattern\":\n    case \"TSAsExpression\":\n    case \"TSSatisfiesExpression\":\n    case \"TSTypeAssertion\":\n    case \"TSNonNullExpression\":\n      break;\n    case \"Placeholder\":\n      switch (node.expectedNode) {\n        case \"Pattern\":\n        case \"Identifier\":\n          break;\n        default:\n          return false;\n      }\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isLVal(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.LVal> | null,\n): node is t.LVal {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"Identifier\":\n    case \"MemberExpression\":\n    case \"RestElement\":\n    case \"AssignmentPattern\":\n    case \"ArrayPattern\":\n    case \"ObjectPattern\":\n    case \"TSParameterProperty\":\n    case \"TSAsExpression\":\n    case \"TSSatisfiesExpression\":\n    case \"TSTypeAssertion\":\n    case \"TSNonNullExpression\":\n      break;\n    case \"Placeholder\":\n      switch (node.expectedNode) {\n        case \"Pattern\":\n        case \"Identifier\":\n          break;\n        default:\n          return false;\n      }\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSEntityName(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSEntityName> | null,\n): node is t.TSEntityName {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"Identifier\":\n    case \"TSQualifiedName\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"Identifier\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isLiteral(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.Literal> | null,\n): node is t.Literal {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"RegExpLiteral\":\n    case \"TemplateLiteral\":\n    case \"BigIntLiteral\":\n    case \"DecimalLiteral\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"StringLiteral\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isImmutable(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.Immutable> | null,\n): node is t.Immutable {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"BigIntLiteral\":\n    case \"JSXAttribute\":\n    case \"JSXClosingElement\":\n    case \"JSXElement\":\n    case \"JSXExpressionContainer\":\n    case \"JSXSpreadChild\":\n    case \"JSXOpeningElement\":\n    case \"JSXText\":\n    case \"JSXFragment\":\n    case \"JSXOpeningFragment\":\n    case \"JSXClosingFragment\":\n    case \"DecimalLiteral\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"StringLiteral\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isUserWhitespacable(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.UserWhitespacable> | null,\n): node is t.UserWhitespacable {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ObjectMethod\":\n    case \"ObjectProperty\":\n    case \"ObjectTypeInternalSlot\":\n    case \"ObjectTypeCallProperty\":\n    case \"ObjectTypeIndexer\":\n    case \"ObjectTypeProperty\":\n    case \"ObjectTypeSpreadProperty\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isMethod(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.Method> | null,\n): node is t.Method {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ObjectMethod\":\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectMember(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ObjectMember> | null,\n): node is t.ObjectMember {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ObjectMethod\":\n    case \"ObjectProperty\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isProperty(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.Property> | null,\n): node is t.Property {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ObjectProperty\":\n    case \"ClassProperty\":\n    case \"ClassAccessorProperty\":\n    case \"ClassPrivateProperty\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isUnaryLike(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.UnaryLike> | null,\n): node is t.UnaryLike {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"UnaryExpression\":\n    case \"SpreadElement\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isPattern(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.Pattern> | null,\n): node is t.Pattern {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"AssignmentPattern\":\n    case \"ArrayPattern\":\n    case \"ObjectPattern\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"Pattern\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClass(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.Class> | null,\n): node is t.Class {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isImportOrExportDeclaration(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ImportOrExportDeclaration> | null,\n): node is t.ImportOrExportDeclaration {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ExportAllDeclaration\":\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n    case \"ImportDeclaration\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExportDeclaration(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ExportDeclaration> | null,\n): node is t.ExportDeclaration {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ExportAllDeclaration\":\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isModuleSpecifier(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ModuleSpecifier> | null,\n): node is t.ModuleSpecifier {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ExportSpecifier\":\n    case \"ImportDefaultSpecifier\":\n    case \"ImportNamespaceSpecifier\":\n    case \"ImportSpecifier\":\n    case \"ExportNamespaceSpecifier\":\n    case \"ExportDefaultSpecifier\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isAccessor(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.Accessor> | null,\n): node is t.Accessor {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ClassAccessorProperty\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isPrivate(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.Private> | null,\n): node is t.Private {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n    case \"PrivateName\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFlow(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.Flow> | null,\n): node is t.Flow {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"AnyTypeAnnotation\":\n    case \"ArrayTypeAnnotation\":\n    case \"BooleanTypeAnnotation\":\n    case \"BooleanLiteralTypeAnnotation\":\n    case \"NullLiteralTypeAnnotation\":\n    case \"ClassImplements\":\n    case \"DeclareClass\":\n    case \"DeclareFunction\":\n    case \"DeclareInterface\":\n    case \"DeclareModule\":\n    case \"DeclareModuleExports\":\n    case \"DeclareTypeAlias\":\n    case \"DeclareOpaqueType\":\n    case \"DeclareVariable\":\n    case \"DeclareExportDeclaration\":\n    case \"DeclareExportAllDeclaration\":\n    case \"DeclaredPredicate\":\n    case \"ExistsTypeAnnotation\":\n    case \"FunctionTypeAnnotation\":\n    case \"FunctionTypeParam\":\n    case \"GenericTypeAnnotation\":\n    case \"InferredPredicate\":\n    case \"InterfaceExtends\":\n    case \"InterfaceDeclaration\":\n    case \"InterfaceTypeAnnotation\":\n    case \"IntersectionTypeAnnotation\":\n    case \"MixedTypeAnnotation\":\n    case \"EmptyTypeAnnotation\":\n    case \"NullableTypeAnnotation\":\n    case \"NumberLiteralTypeAnnotation\":\n    case \"NumberTypeAnnotation\":\n    case \"ObjectTypeAnnotation\":\n    case \"ObjectTypeInternalSlot\":\n    case \"ObjectTypeCallProperty\":\n    case \"ObjectTypeIndexer\":\n    case \"ObjectTypeProperty\":\n    case \"ObjectTypeSpreadProperty\":\n    case \"OpaqueType\":\n    case \"QualifiedTypeIdentifier\":\n    case \"StringLiteralTypeAnnotation\":\n    case \"StringTypeAnnotation\":\n    case \"SymbolTypeAnnotation\":\n    case \"ThisTypeAnnotation\":\n    case \"TupleTypeAnnotation\":\n    case \"TypeofTypeAnnotation\":\n    case \"TypeAlias\":\n    case \"TypeAnnotation\":\n    case \"TypeCastExpression\":\n    case \"TypeParameter\":\n    case \"TypeParameterDeclaration\":\n    case \"TypeParameterInstantiation\":\n    case \"UnionTypeAnnotation\":\n    case \"Variance\":\n    case \"VoidTypeAnnotation\":\n    case \"EnumDeclaration\":\n    case \"EnumBooleanBody\":\n    case \"EnumNumberBody\":\n    case \"EnumStringBody\":\n    case \"EnumSymbolBody\":\n    case \"EnumBooleanMember\":\n    case \"EnumNumberMember\":\n    case \"EnumStringMember\":\n    case \"EnumDefaultedMember\":\n    case \"IndexedAccessType\":\n    case \"OptionalIndexedAccessType\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFlowType(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.FlowType> | null,\n): node is t.FlowType {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"AnyTypeAnnotation\":\n    case \"ArrayTypeAnnotation\":\n    case \"BooleanTypeAnnotation\":\n    case \"BooleanLiteralTypeAnnotation\":\n    case \"NullLiteralTypeAnnotation\":\n    case \"ExistsTypeAnnotation\":\n    case \"FunctionTypeAnnotation\":\n    case \"GenericTypeAnnotation\":\n    case \"InterfaceTypeAnnotation\":\n    case \"IntersectionTypeAnnotation\":\n    case \"MixedTypeAnnotation\":\n    case \"EmptyTypeAnnotation\":\n    case \"NullableTypeAnnotation\":\n    case \"NumberLiteralTypeAnnotation\":\n    case \"NumberTypeAnnotation\":\n    case \"ObjectTypeAnnotation\":\n    case \"StringLiteralTypeAnnotation\":\n    case \"StringTypeAnnotation\":\n    case \"SymbolTypeAnnotation\":\n    case \"ThisTypeAnnotation\":\n    case \"TupleTypeAnnotation\":\n    case \"TypeofTypeAnnotation\":\n    case \"UnionTypeAnnotation\":\n    case \"VoidTypeAnnotation\":\n    case \"IndexedAccessType\":\n    case \"OptionalIndexedAccessType\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFlowBaseAnnotation(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.FlowBaseAnnotation> | null,\n): node is t.FlowBaseAnnotation {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"AnyTypeAnnotation\":\n    case \"BooleanTypeAnnotation\":\n    case \"NullLiteralTypeAnnotation\":\n    case \"MixedTypeAnnotation\":\n    case \"EmptyTypeAnnotation\":\n    case \"NumberTypeAnnotation\":\n    case \"StringTypeAnnotation\":\n    case \"SymbolTypeAnnotation\":\n    case \"ThisTypeAnnotation\":\n    case \"VoidTypeAnnotation\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFlowDeclaration(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.FlowDeclaration> | null,\n): node is t.FlowDeclaration {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"DeclareClass\":\n    case \"DeclareFunction\":\n    case \"DeclareInterface\":\n    case \"DeclareModule\":\n    case \"DeclareModuleExports\":\n    case \"DeclareTypeAlias\":\n    case \"DeclareOpaqueType\":\n    case \"DeclareVariable\":\n    case \"DeclareExportDeclaration\":\n    case \"DeclareExportAllDeclaration\":\n    case \"InterfaceDeclaration\":\n    case \"OpaqueType\":\n    case \"TypeAlias\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFlowPredicate(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.FlowPredicate> | null,\n): node is t.FlowPredicate {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"DeclaredPredicate\":\n    case \"InferredPredicate\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumBody(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.EnumBody> | null,\n): node is t.EnumBody {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"EnumBooleanBody\":\n    case \"EnumNumberBody\":\n    case \"EnumStringBody\":\n    case \"EnumSymbolBody\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumMember(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.EnumMember> | null,\n): node is t.EnumMember {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"EnumBooleanMember\":\n    case \"EnumNumberMember\":\n    case \"EnumStringMember\":\n    case \"EnumDefaultedMember\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSX(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.JSX> | null,\n): node is t.JSX {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"JSXAttribute\":\n    case \"JSXClosingElement\":\n    case \"JSXElement\":\n    case \"JSXEmptyExpression\":\n    case \"JSXExpressionContainer\":\n    case \"JSXSpreadChild\":\n    case \"JSXIdentifier\":\n    case \"JSXMemberExpression\":\n    case \"JSXNamespacedName\":\n    case \"JSXOpeningElement\":\n    case \"JSXSpreadAttribute\":\n    case \"JSXText\":\n    case \"JSXFragment\":\n    case \"JSXOpeningFragment\":\n    case \"JSXClosingFragment\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isMiscellaneous(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.Miscellaneous> | null,\n): node is t.Miscellaneous {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"Noop\":\n    case \"Placeholder\":\n    case \"V8IntrinsicIdentifier\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTypeScript(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TypeScript> | null,\n): node is t.TypeScript {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"TSParameterProperty\":\n    case \"TSDeclareFunction\":\n    case \"TSDeclareMethod\":\n    case \"TSQualifiedName\":\n    case \"TSCallSignatureDeclaration\":\n    case \"TSConstructSignatureDeclaration\":\n    case \"TSPropertySignature\":\n    case \"TSMethodSignature\":\n    case \"TSIndexSignature\":\n    case \"TSAnyKeyword\":\n    case \"TSBooleanKeyword\":\n    case \"TSBigIntKeyword\":\n    case \"TSIntrinsicKeyword\":\n    case \"TSNeverKeyword\":\n    case \"TSNullKeyword\":\n    case \"TSNumberKeyword\":\n    case \"TSObjectKeyword\":\n    case \"TSStringKeyword\":\n    case \"TSSymbolKeyword\":\n    case \"TSUndefinedKeyword\":\n    case \"TSUnknownKeyword\":\n    case \"TSVoidKeyword\":\n    case \"TSThisType\":\n    case \"TSFunctionType\":\n    case \"TSConstructorType\":\n    case \"TSTypeReference\":\n    case \"TSTypePredicate\":\n    case \"TSTypeQuery\":\n    case \"TSTypeLiteral\":\n    case \"TSArrayType\":\n    case \"TSTupleType\":\n    case \"TSOptionalType\":\n    case \"TSRestType\":\n    case \"TSNamedTupleMember\":\n    case \"TSUnionType\":\n    case \"TSIntersectionType\":\n    case \"TSConditionalType\":\n    case \"TSInferType\":\n    case \"TSParenthesizedType\":\n    case \"TSTypeOperator\":\n    case \"TSIndexedAccessType\":\n    case \"TSMappedType\":\n    case \"TSLiteralType\":\n    case \"TSExpressionWithTypeArguments\":\n    case \"TSInterfaceDeclaration\":\n    case \"TSInterfaceBody\":\n    case \"TSTypeAliasDeclaration\":\n    case \"TSInstantiationExpression\":\n    case \"TSAsExpression\":\n    case \"TSSatisfiesExpression\":\n    case \"TSTypeAssertion\":\n    case \"TSEnumDeclaration\":\n    case \"TSEnumMember\":\n    case \"TSModuleDeclaration\":\n    case \"TSModuleBlock\":\n    case \"TSImportType\":\n    case \"TSImportEqualsDeclaration\":\n    case \"TSExternalModuleReference\":\n    case \"TSNonNullExpression\":\n    case \"TSExportAssignment\":\n    case \"TSNamespaceExportDeclaration\":\n    case \"TSTypeAnnotation\":\n    case \"TSTypeParameterInstantiation\":\n    case \"TSTypeParameterDeclaration\":\n    case \"TSTypeParameter\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeElement(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSTypeElement> | null,\n): node is t.TSTypeElement {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"TSCallSignatureDeclaration\":\n    case \"TSConstructSignatureDeclaration\":\n    case \"TSPropertySignature\":\n    case \"TSMethodSignature\":\n    case \"TSIndexSignature\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSType(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSType> | null,\n): node is t.TSType {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"TSAnyKeyword\":\n    case \"TSBooleanKeyword\":\n    case \"TSBigIntKeyword\":\n    case \"TSIntrinsicKeyword\":\n    case \"TSNeverKeyword\":\n    case \"TSNullKeyword\":\n    case \"TSNumberKeyword\":\n    case \"TSObjectKeyword\":\n    case \"TSStringKeyword\":\n    case \"TSSymbolKeyword\":\n    case \"TSUndefinedKeyword\":\n    case \"TSUnknownKeyword\":\n    case \"TSVoidKeyword\":\n    case \"TSThisType\":\n    case \"TSFunctionType\":\n    case \"TSConstructorType\":\n    case \"TSTypeReference\":\n    case \"TSTypePredicate\":\n    case \"TSTypeQuery\":\n    case \"TSTypeLiteral\":\n    case \"TSArrayType\":\n    case \"TSTupleType\":\n    case \"TSOptionalType\":\n    case \"TSRestType\":\n    case \"TSUnionType\":\n    case \"TSIntersectionType\":\n    case \"TSConditionalType\":\n    case \"TSInferType\":\n    case \"TSParenthesizedType\":\n    case \"TSTypeOperator\":\n    case \"TSIndexedAccessType\":\n    case \"TSMappedType\":\n    case \"TSLiteralType\":\n    case \"TSExpressionWithTypeArguments\":\n    case \"TSImportType\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSBaseType(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.TSBaseType> | null,\n): node is t.TSBaseType {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"TSAnyKeyword\":\n    case \"TSBooleanKeyword\":\n    case \"TSBigIntKeyword\":\n    case \"TSIntrinsicKeyword\":\n    case \"TSNeverKeyword\":\n    case \"TSNullKeyword\":\n    case \"TSNumberKeyword\":\n    case \"TSObjectKeyword\":\n    case \"TSStringKeyword\":\n    case \"TSSymbolKeyword\":\n    case \"TSUndefinedKeyword\":\n    case \"TSUnknownKeyword\":\n    case \"TSVoidKeyword\":\n    case \"TSThisType\":\n    case \"TSLiteralType\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\n/**\n * @deprecated Use `isNumericLiteral`\n */\nexport function isNumberLiteral(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.NumberLiteral> | null,\n): boolean {\n  deprecationWarning(\"isNumberLiteral\", \"isNumericLiteral\");\n  if (!node) return false;\n\n  if (node.type !== \"NumberLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\n/**\n * @deprecated Use `isRegExpLiteral`\n */\nexport function isRegexLiteral(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.RegexLiteral> | null,\n): boolean {\n  deprecationWarning(\"isRegexLiteral\", \"isRegExpLiteral\");\n  if (!node) return false;\n\n  if (node.type !== \"RegexLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\n/**\n * @deprecated Use `isRestElement`\n */\nexport function isRestProperty(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.RestProperty> | null,\n): boolean {\n  deprecationWarning(\"isRestProperty\", \"isRestElement\");\n  if (!node) return false;\n\n  if (node.type !== \"RestProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\n/**\n * @deprecated Use `isSpreadElement`\n */\nexport function isSpreadProperty(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.SpreadProperty> | null,\n): boolean {\n  deprecationWarning(\"isSpreadProperty\", \"isSpreadElement\");\n  if (!node) return false;\n\n  if (node.type !== \"SpreadProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\n/**\n * @deprecated Use `isImportOrExportDeclaration`\n */\nexport function isModuleDeclaration(\n  node: t.Node | null | undefined,\n  opts?: Opts<t.ModuleDeclaration> | null,\n): node is t.ImportOrExportDeclaration {\n  deprecationWarning(\"isModuleDeclaration\", \"isImportOrExportDeclaration\");\n  return isImportOrExportDeclaration(node, opts);\n}\n", "import {\n  isIdentifier,\n  isMemberExpression,\n  isStringLiteral,\n  isThisExpression,\n} from \"./generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Determines whether or not the input node `member` matches the\n * input `match`.\n *\n * For example, given the match `React.createClass` it would match the\n * parsed nodes of `React.createClass` and `React[\"createClass\"]`.\n */\nexport default function matchesPattern(\n  member: t.Node | null | undefined,\n  match: string | string[],\n  allowPartial?: boolean,\n): boolean {\n  // not a member expression\n  if (!isMemberExpression(member)) return false;\n\n  const parts = Array.isArray(match) ? match : match.split(\".\");\n  const nodes = [];\n\n  let node;\n  for (node = member; isMemberExpression(node); node = node.object) {\n    nodes.push(node.property);\n  }\n  nodes.push(node);\n\n  if (nodes.length < parts.length) return false;\n  if (!allowPartial && nodes.length > parts.length) return false;\n\n  for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {\n    const node = nodes[j];\n    let value;\n    if (isIdentifier(node)) {\n      value = node.name;\n    } else if (isStringLiteral(node)) {\n      value = node.value;\n    } else if (isThisExpression(node)) {\n      value = \"this\";\n    } else {\n      return false;\n    }\n\n    if (parts[i] !== value) return false;\n  }\n\n  return true;\n}\n", "import matchesPattern from \"./matchesPattern.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Build a function that when called will return whether or not the\n * input `node` `MemberExpression` matches the input `match`.\n *\n * For example, given the match `React.createClass` it would match the\n * parsed nodes of `React.createClass` and `React[\"createClass\"]`.\n */\nexport default function buildMatchMemberExpression(\n  match: string,\n  allowPartial?: boolean,\n) {\n  const parts = match.split(\".\");\n\n  return (member: t.Node) => matchesPattern(member, parts, allowPartial);\n}\n", "import buildMatchMemberExpression from \"../buildMatchMemberExpression.ts\";\n\nconst isReactComponent = buildMatchMemberExpression(\"React.Component\");\n\nexport default isReactComponent;\n", "export default function isCompatTag(tagName?: string): boolean {\n  // Must start with a lowercase ASCII letter\n  return !!tagName && /^[a-z]/.test(tagName);\n}\n", "import { FLIPPED_ALIAS_KEYS, ALIAS_KEYS } from \"../definitions/index.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default function isType<T extends t.Node[\"type\"]>(\n  nodeType: string,\n  targetType: T,\n): nodeType is T;\n\nexport default function isType(\n  nodeType: string | null | undefined,\n  targetType: string,\n): boolean;\n\n/**\n * Test if a `nodeType` is a `targetType` or if `targetType` is an alias of `nodeType`.\n */\nexport default function isType(nodeType: string, targetType: string): boolean {\n  if (nodeType === targetType) return true;\n\n  // If nodeType is nullish, it can't be an alias of targetType.\n  if (nodeType == null) return false;\n\n  // This is a fast-path. If the test above failed, but an alias key is found, then the\n  // targetType was a primary node type, so there's no need to check the aliases.\n  // @ts-expect-error targetType may not index ALIAS_KEYS\n  if (ALIAS_KEYS[targetType]) return false;\n\n  const aliases: Array<string> | undefined = FLIPPED_ALIAS_KEYS[targetType];\n  if (aliases) {\n    if (aliases[0] === nodeType) return true;\n\n    for (const alias of aliases) {\n      if (nodeType === alias) return true;\n    }\n  }\n\n  return false;\n}\n", "import { PLACEHOLDERS_ALIAS } from \"../definitions/index.ts\";\n\n/**\n * Test if a `placeholderType` is a `targetType` or if `targetType` is an alias of `placeholderType`.\n */\nexport default function isPlaceholderType(\n  placeholderType: string,\n  targetType: string,\n): boolean {\n  if (placeholderType === targetType) return true;\n\n  const aliases: Array<string> | undefined =\n    PLACEHOLDERS_ALIAS[placeholderType];\n  if (aliases) {\n    for (const alias of aliases) {\n      if (targetType === alias) return true;\n    }\n  }\n\n  return false;\n}\n", "import shallowEqual from \"../utils/shallowEqual.ts\";\nimport isType from \"./isType.ts\";\nimport isPlaceholderType from \"./isPlaceholderType.ts\";\nimport { FLIPPED_ALIAS_KEYS } from \"../definitions/index.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default function is<T extends t.Node[\"type\"]>(\n  type: T,\n  node: t.Node | null | undefined,\n  opts?: undefined,\n): node is Extract<t.Node, { type: T }>;\n\nexport default function is<\n  T extends t.Node[\"type\"],\n  P extends Extract<t.Node, { type: T }>,\n>(type: T, n: t.Node | null | undefined, required: Partial<P>): n is P;\n\nexport default function is<P extends t.Node>(\n  type: string,\n  node: t.Node | null | undefined,\n  opts: Partial<P>,\n): node is P;\n\nexport default function is(\n  type: string,\n  node: t.Node | null | undefined,\n  opts?: Partial<t.Node>,\n): node is t.Node;\n/**\n * Returns whether `node` is of given `type`.\n *\n * For better performance, use this instead of `is[Type]` when `type` is unknown.\n */\nexport default function is(\n  type: string,\n  node: t.Node | null | undefined,\n  opts?: Partial<t.Node>,\n): node is t.Node {\n  if (!node) return false;\n\n  const matches = isType(node.type, type);\n  if (!matches) {\n    if (!opts && node.type === \"Placeholder\" && type in FLIPPED_ALIAS_KEYS) {\n      // We can only return true if the placeholder doesn't replace a real node,\n      // but it replaces a category of nodes (an alias).\n      //\n      // t.is(\"Identifier\", node) gives some guarantees about node's shape, so we\n      // can't say that Placeholder(expectedNode: \"Identifier\") is an identifier\n      // because it doesn't have the same properties.\n      // On the other hand, t.is(\"Expression\", node) doesn't say anything about\n      // the shape of node because Expression can be many different nodes: we can,\n      // and should, safely report expression placeholders as Expressions.\n      return isPlaceholderType(node.expectedNode, type);\n    }\n    return false;\n  }\n\n  if (opts === undefined) {\n    return true;\n  } else {\n    return shallowEqual(node, opts);\n  }\n}\n", "// We inline this package\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charCodes from \"charcodes\";\n\n// ## Character categories\n\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point between 0x80 and 0xffff.\n// Generated by `scripts/generate-identifier-regex.cjs`.\n\n/* prettier-ignore */\nlet nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u0870-\\u0887\\u0889-\\u088e\\u08a0-\\u08c9\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c5d\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cdd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u1711\\u171f-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4c\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c8a\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7cd\\ua7d0\\ua7d1\\ua7d3\\ua7d5-\\ua7dc\\ua7f2-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\n/* prettier-ignore */\nlet nonASCIIidentifierChars = \"\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u0897-\\u089f\\u08ca-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3c\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0cf3\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ece\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1715\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u180f-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf-\\u1ace\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1dff\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\u30fb\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\\uff65\";\n\nconst nonASCIIidentifierStart = new RegExp(\n  \"[\" + nonASCIIidentifierStartChars + \"]\",\n);\nconst nonASCIIidentifier = new RegExp(\n  \"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\",\n);\n\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\n\n// These are a run-length and offset-encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range. They were\n// generated by `scripts/generate-identifier-regex.cjs`.\n/* prettier-ignore */\nconst astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,13,10,2,14,2,6,2,1,2,10,2,14,2,6,2,1,4,51,13,310,10,21,11,7,25,5,2,41,2,8,70,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,39,27,10,22,251,41,7,1,17,2,60,28,11,0,9,21,43,17,47,20,28,22,13,52,58,1,3,0,14,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,20,1,64,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,31,9,2,0,3,0,2,37,2,0,26,0,2,0,45,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,38,6,186,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,19,72,200,32,32,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,16,0,2,12,2,33,125,0,80,921,103,110,18,195,2637,96,16,1071,18,5,26,3994,6,582,6842,29,1763,568,8,30,18,78,18,29,19,47,17,3,32,20,6,18,433,44,212,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,42,9,8936,3,2,6,2,1,2,290,16,0,30,2,3,0,15,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,1845,30,7,5,262,61,147,44,11,6,17,0,322,29,19,43,485,27,229,29,3,0,496,6,2,3,2,1,2,14,2,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42719,33,4153,7,221,3,5761,15,7472,16,621,2467,541,1507,4938,6,4191];\n/* prettier-ignore */\nconst astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,7,9,32,4,318,1,80,3,71,10,50,3,123,2,54,14,32,10,3,1,11,3,46,10,8,0,46,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,3,0,158,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,68,8,2,0,3,0,2,3,2,4,2,0,15,1,83,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,7,19,58,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,343,9,54,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,10,1,2,0,49,6,4,4,14,10,5350,0,7,14,11465,27,2343,9,87,9,39,4,60,6,26,9,535,9,470,0,2,54,8,3,82,0,12,1,19628,1,4178,9,519,45,3,22,543,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,101,0,161,6,10,9,357,0,62,13,499,13,245,1,2,9,726,6,110,6,6,9,4759,9,787719,239];\n\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction isInAstralSet(code: number, set: readonly number[]): boolean {\n  let pos = 0x10000;\n  for (let i = 0, length = set.length; i < length; i += 2) {\n    pos += set[i];\n    if (pos > code) return false;\n\n    pos += set[i + 1];\n    if (pos >= code) return true;\n  }\n  return false;\n}\n\n// Test whether a given character code starts an identifier.\n\nexport function isIdentifierStart(code: number): boolean {\n  if (code < charCodes.uppercaseA) return code === charCodes.dollarSign;\n  if (code <= charCodes.uppercaseZ) return true;\n  if (code < charCodes.lowercaseA) return code === charCodes.underscore;\n  if (code <= charCodes.lowercaseZ) return true;\n  if (code <= 0xffff) {\n    return (\n      code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code))\n    );\n  }\n  return isInAstralSet(code, astralIdentifierStartCodes);\n}\n\n// Test whether a given character is part of an identifier.\n\nexport function isIdentifierChar(code: number): boolean {\n  if (code < charCodes.digit0) return code === charCodes.dollarSign;\n  if (code < charCodes.colon) return true;\n  if (code < charCodes.uppercaseA) return false;\n  if (code <= charCodes.uppercaseZ) return true;\n  if (code < charCodes.lowercaseA) return code === charCodes.underscore;\n  if (code <= charCodes.lowercaseZ) return true;\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  }\n  return (\n    isInAstralSet(code, astralIdentifierStartCodes) ||\n    isInAstralSet(code, astralIdentifierCodes)\n  );\n}\n\n// Test whether a given string is a valid identifier name\n\nexport function isIdentifierName(name: string): boolean {\n  let isFirst = true;\n  for (let i = 0; i < name.length; i++) {\n    // The implementation is based on\n    // https://source.chromium.org/chromium/chromium/src/+/master:v8/src/builtins/builtins-string-gen.cc;l=1455;drc=221e331b49dfefadbc6fa40b0c68e6f97606d0b3;bpv=0;bpt=1\n    // We reimplement `codePointAt` because `codePointAt` is a V8 builtin which is not inlined by TurboFan (as of M91)\n    // since `name` is mostly ASCII, an inlined `charCodeAt` wins here\n    let cp = name.charCodeAt(i);\n    if ((cp & 0xfc00) === 0xd800 && i + 1 < name.length) {\n      const trail = name.charCodeAt(++i);\n      if ((trail & 0xfc00) === 0xdc00) {\n        cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);\n      }\n    }\n    if (isFirst) {\n      isFirst = false;\n      if (!isIdentifierStart(cp)) {\n        return false;\n      }\n    } else if (!isIdentifierChar(cp)) {\n      return false;\n    }\n  }\n  return !isFirst;\n}\n", "const reservedWords = {\n  keyword: [\n    \"break\",\n    \"case\",\n    \"catch\",\n    \"continue\",\n    \"debugger\",\n    \"default\",\n    \"do\",\n    \"else\",\n    \"finally\",\n    \"for\",\n    \"function\",\n    \"if\",\n    \"return\",\n    \"switch\",\n    \"throw\",\n    \"try\",\n    \"var\",\n    \"const\",\n    \"while\",\n    \"with\",\n    \"new\",\n    \"this\",\n    \"super\",\n    \"class\",\n    \"extends\",\n    \"export\",\n    \"import\",\n    \"null\",\n    \"true\",\n    \"false\",\n    \"in\",\n    \"instanceof\",\n    \"typeof\",\n    \"void\",\n    \"delete\",\n  ],\n  strict: [\n    \"implements\",\n    \"interface\",\n    \"let\",\n    \"package\",\n    \"private\",\n    \"protected\",\n    \"public\",\n    \"static\",\n    \"yield\",\n  ],\n  strictBind: [\"eval\", \"arguments\"],\n};\nconst keywords = new Set(reservedWords.keyword);\nconst reservedWordsStrictSet = new Set(reservedWords.strict);\nconst reservedWordsStrictBindSet = new Set(reservedWords.strictBind);\n\n/**\n * Checks if word is a reserved word in non-strict mode\n */\nexport function isReservedWord(word: string, inModule: boolean): boolean {\n  return (inModule && word === \"await\") || word === \"enum\";\n}\n\n/**\n * Checks if word is a reserved word in non-binding strict mode\n *\n * Includes non-strict reserved words\n */\nexport function isStrictReservedWord(word: string, inModule: boolean): boolean {\n  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);\n}\n\n/**\n * Checks if word is a reserved word in binding strict mode, but it is allowed as\n * a normal identifier.\n */\nexport function isStrictBindOnlyReservedWord(word: string): boolean {\n  return reservedWordsStrictBindSet.has(word);\n}\n\n/**\n * Checks if word is a reserved word in binding strict mode\n *\n * Includes non-strict reserved words and non-binding strict reserved words\n */\nexport function isStrictBindReservedWord(\n  word: string,\n  inModule: boolean,\n): boolean {\n  return (\n    isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word)\n  );\n}\n\nexport function isKeyword(word: string): boolean {\n  return keywords.has(word);\n}\n", "export {\n  isIdentifierName,\n  isIdentifierChar,\n  isIdentifierStart,\n} from \"./identifier.ts\";\nexport {\n  isReservedWord,\n  isStrictBindOnlyReservedWord,\n  isStrictBindReservedWord,\n  isStrictReservedWord,\n  isKeyword,\n} from \"./keyword.ts\";\n", "import {\n  isIdentifierName,\n  isStrictReservedWord,\n  isKeyword,\n} from \"@babel/helper-validator-identifier\";\n\n/**\n * Check if the input `name` is a valid identifier name\n * and isn't a reserved word.\n */\nexport default function isValidIdentifier(\n  name: string,\n  reserved: boolean = true,\n): boolean {\n  if (typeof name !== \"string\") return false;\n\n  if (reserved) {\n    // \"await\" is invalid in module, valid in script; better be safe (see #4952)\n    if (isKeyword(name) || isStrictReservedWord(name, true)) {\n      return false;\n    }\n  }\n\n  return isIdentifierName(name);\n}\n", "// We inline this package\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charCodes from \"charcodes\";\n\n// The following character codes are forbidden from being\n// an immediate sibling of NumericLiteralSeparator _\nconst forbiddenNumericSeparatorSiblings = {\n  decBinOct: new Set<number>([\n    charCodes.dot,\n    charCodes.uppercaseB,\n    charCodes.uppercaseE,\n    charCodes.uppercaseO,\n    charCodes.underscore, // multiple separators are not allowed\n    charCodes.lowercaseB,\n    charCodes.lowercaseE,\n    charCodes.lowercaseO,\n  ]),\n  hex: new Set<number>([\n    charCodes.dot,\n    charCodes.uppercaseX,\n    charCodes.underscore, // multiple separators are not allowed\n    charCodes.lowercaseX,\n  ]),\n};\n\nconst isAllowedNumericSeparatorSibling = {\n  // 0 - 1\n  bin: (ch: number) => ch === charCodes.digit0 || ch === charCodes.digit1,\n\n  // 0 - 7\n  oct: (ch: number) => ch >= charCodes.digit0 && ch <= charCodes.digit7,\n\n  // 0 - 9\n  dec: (ch: number) => ch >= charCodes.digit0 && ch <= charCodes.digit9,\n\n  // 0 - 9, A - F, a - f,\n  hex: (ch: number) =>\n    (ch >= charCodes.digit0 && ch <= charCodes.digit9) ||\n    (ch >= charCodes.uppercaseA && ch <= charCodes.uppercaseF) ||\n    (ch >= charCodes.lowercaseA && ch <= charCodes.lowercaseF),\n};\n\nexport type StringContentsErrorHandlers = EscapedCharErrorHandlers & {\n  unterminated(\n    initialPos: number,\n    initialLineStart: number,\n    initialCurLine: number,\n  ): void;\n};\n\nexport function readStringContents(\n  type: \"single\" | \"double\" | \"template\",\n  input: string,\n  pos: number,\n  lineStart: number,\n  curLine: number,\n  errors: StringContentsErrorHandlers,\n) {\n  const initialPos = pos;\n  const initialLineStart = lineStart;\n  const initialCurLine = curLine;\n\n  let out = \"\";\n  let firstInvalidLoc = null;\n  let chunkStart = pos;\n  const { length } = input;\n  for (;;) {\n    if (pos >= length) {\n      errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n    const ch = input.charCodeAt(pos);\n    if (isStringEnd(type, ch, input, pos)) {\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n    if (ch === charCodes.backslash) {\n      out += input.slice(chunkStart, pos);\n      const res = readEscapedChar(\n        input,\n        pos,\n        lineStart,\n        curLine,\n        type === \"template\",\n        errors,\n      );\n      if (res.ch === null && !firstInvalidLoc) {\n        firstInvalidLoc = { pos, lineStart, curLine };\n      } else {\n        out += res.ch;\n      }\n      ({ pos, lineStart, curLine } = res);\n      chunkStart = pos;\n    } else if (\n      ch === charCodes.lineSeparator ||\n      ch === charCodes.paragraphSeparator\n    ) {\n      ++pos;\n      ++curLine;\n      lineStart = pos;\n    } else if (ch === charCodes.lineFeed || ch === charCodes.carriageReturn) {\n      if (type === \"template\") {\n        out += input.slice(chunkStart, pos) + \"\\n\";\n        ++pos;\n        if (\n          ch === charCodes.carriageReturn &&\n          input.charCodeAt(pos) === charCodes.lineFeed\n        ) {\n          ++pos;\n        }\n        ++curLine;\n        chunkStart = lineStart = pos;\n      } else {\n        errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      }\n    } else {\n      ++pos;\n    }\n  }\n  return process.env.BABEL_8_BREAKING\n    ? { pos, str: out, firstInvalidLoc, lineStart, curLine }\n    : {\n        pos,\n        str: out,\n        firstInvalidLoc,\n        lineStart,\n        curLine,\n        containsInvalid: !!firstInvalidLoc,\n      };\n}\n\nfunction isStringEnd(\n  type: \"single\" | \"double\" | \"template\",\n  ch: number,\n  input: string,\n  pos: number,\n) {\n  if (type === \"template\") {\n    return (\n      ch === charCodes.graveAccent ||\n      (ch === charCodes.dollarSign &&\n        input.charCodeAt(pos + 1) === charCodes.leftCurlyBrace)\n    );\n  }\n  return (\n    ch === (type === \"double\" ? charCodes.quotationMark : charCodes.apostrophe)\n  );\n}\n\ntype EscapedCharErrorHandlers = HexCharErrorHandlers &\n  CodePointErrorHandlers & {\n    strictNumericEscape(pos: number, lineStart: number, curLine: number): void;\n  };\n\nfunction readEscapedChar(\n  input: string,\n  pos: number,\n  lineStart: number,\n  curLine: number,\n  inTemplate: boolean,\n  errors: EscapedCharErrorHandlers,\n) {\n  const throwOnInvalid = !inTemplate;\n  pos++; // skip '\\'\n\n  const res = (ch: string | null) => ({ pos, ch, lineStart, curLine });\n\n  const ch = input.charCodeAt(pos++);\n  switch (ch) {\n    case charCodes.lowercaseN:\n      return res(\"\\n\");\n    case charCodes.lowercaseR:\n      return res(\"\\r\");\n    case charCodes.lowercaseX: {\n      let code;\n      ({ code, pos } = readHexChar(\n        input,\n        pos,\n        lineStart,\n        curLine,\n        2,\n        false,\n        throwOnInvalid,\n        errors,\n      ));\n      return res(code === null ? null : String.fromCharCode(code));\n    }\n    case charCodes.lowercaseU: {\n      let code;\n      ({ code, pos } = readCodePoint(\n        input,\n        pos,\n        lineStart,\n        curLine,\n        throwOnInvalid,\n        errors,\n      ));\n      return res(code === null ? null : String.fromCodePoint(code));\n    }\n    case charCodes.lowercaseT:\n      return res(\"\\t\");\n    case charCodes.lowercaseB:\n      return res(\"\\b\");\n    case charCodes.lowercaseV:\n      return res(\"\\u000b\");\n    case charCodes.lowercaseF:\n      return res(\"\\f\");\n    case charCodes.carriageReturn:\n      if (input.charCodeAt(pos) === charCodes.lineFeed) {\n        ++pos;\n      }\n    // fall through\n    case charCodes.lineFeed:\n      lineStart = pos;\n      ++curLine;\n    // fall through\n    case charCodes.lineSeparator:\n    case charCodes.paragraphSeparator:\n      return res(\"\");\n    case charCodes.digit8:\n    case charCodes.digit9:\n      if (inTemplate) {\n        return res(null);\n      } else {\n        errors.strictNumericEscape(pos - 1, lineStart, curLine);\n      }\n    // fall through\n    default:\n      if (ch >= charCodes.digit0 && ch <= charCodes.digit7) {\n        const startPos = pos - 1;\n        const match = /^[0-7]+/.exec(input.slice(startPos, pos + 2));\n\n        let octalStr = match[0];\n\n        let octal = parseInt(octalStr, 8);\n        if (octal > 255) {\n          octalStr = octalStr.slice(0, -1);\n          octal = parseInt(octalStr, 8);\n        }\n        pos += octalStr.length - 1;\n        const next = input.charCodeAt(pos);\n        if (\n          octalStr !== \"0\" ||\n          next === charCodes.digit8 ||\n          next === charCodes.digit9\n        ) {\n          if (inTemplate) {\n            return res(null);\n          } else {\n            errors.strictNumericEscape(startPos, lineStart, curLine);\n          }\n        }\n\n        return res(String.fromCharCode(octal));\n      }\n\n      return res(String.fromCharCode(ch));\n  }\n}\n\ntype HexCharErrorHandlers = IntErrorHandlers & {\n  invalidEscapeSequence(pos: number, lineStart: number, curLine: number): void;\n};\n\n// Used to read character escape sequences ('\\x', '\\u').\nfunction readHexChar(\n  input: string,\n  pos: number,\n  lineStart: number,\n  curLine: number,\n  len: number,\n  forceLen: boolean,\n  throwOnInvalid: boolean,\n  errors: HexCharErrorHandlers,\n) {\n  const initialPos = pos;\n  let n;\n  ({ n, pos } = readInt(\n    input,\n    pos,\n    lineStart,\n    curLine,\n    16,\n    len,\n    forceLen,\n    false,\n    errors,\n    /* bailOnError */ !throwOnInvalid,\n  ));\n  if (n === null) {\n    if (throwOnInvalid) {\n      errors.invalidEscapeSequence(initialPos, lineStart, curLine);\n    } else {\n      pos = initialPos - 1;\n    }\n  }\n  return { code: n, pos };\n}\n\nexport type IntErrorHandlers = {\n  numericSeparatorInEscapeSequence(\n    pos: number,\n    lineStart: number,\n    curLine: number,\n  ): void;\n  unexpectedNumericSeparator(\n    pos: number,\n    lineStart: number,\n    curLine: number,\n  ): void;\n  // It can return \"true\" to indicate that the error was handled\n  // and the int parsing should continue.\n  invalidDigit(\n    pos: number,\n    lineStart: number,\n    curLine: number,\n    radix: number,\n  ): boolean;\n};\n\nexport function readInt(\n  input: string,\n  pos: number,\n  lineStart: number,\n  curLine: number,\n  radix: number,\n  len: number | undefined,\n  forceLen: boolean,\n  allowNumSeparator: boolean | \"bail\",\n  errors: IntErrorHandlers,\n  bailOnError: boolean,\n) {\n  const start = pos;\n  const forbiddenSiblings =\n    radix === 16\n      ? forbiddenNumericSeparatorSiblings.hex\n      : forbiddenNumericSeparatorSiblings.decBinOct;\n  const isAllowedSibling =\n    radix === 16\n      ? isAllowedNumericSeparatorSibling.hex\n      : radix === 10\n        ? isAllowedNumericSeparatorSibling.dec\n        : radix === 8\n          ? isAllowedNumericSeparatorSibling.oct\n          : isAllowedNumericSeparatorSibling.bin;\n\n  let invalid = false;\n  let total = 0;\n\n  for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    const code = input.charCodeAt(pos);\n    let val;\n\n    if (code === charCodes.underscore && allowNumSeparator !== \"bail\") {\n      const prev = input.charCodeAt(pos - 1);\n      const next = input.charCodeAt(pos + 1);\n\n      if (!allowNumSeparator) {\n        if (bailOnError) return { n: null, pos };\n        errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);\n      } else if (\n        Number.isNaN(next) ||\n        !isAllowedSibling(next) ||\n        forbiddenSiblings.has(prev) ||\n        forbiddenSiblings.has(next)\n      ) {\n        if (bailOnError) return { n: null, pos };\n        errors.unexpectedNumericSeparator(pos, lineStart, curLine);\n      }\n\n      // Ignore this _ character\n      ++pos;\n      continue;\n    }\n\n    if (code >= charCodes.lowercaseA) {\n      val = code - charCodes.lowercaseA + charCodes.lineFeed;\n    } else if (code >= charCodes.uppercaseA) {\n      val = code - charCodes.uppercaseA + charCodes.lineFeed;\n    } else if (charCodes.isDigit(code)) {\n      val = code - charCodes.digit0; // 0-9\n    } else {\n      val = Infinity;\n    }\n    if (val >= radix) {\n      // If we found a digit which is too big, errors.invalidDigit can return true to avoid\n      // breaking the loop (this is used for error recovery).\n      if (val <= 9 && bailOnError) {\n        return { n: null, pos };\n      } else if (\n        val <= 9 &&\n        errors.invalidDigit(pos, lineStart, curLine, radix)\n      ) {\n        val = 0;\n      } else if (forceLen) {\n        val = 0;\n        invalid = true;\n      } else {\n        break;\n      }\n    }\n    ++pos;\n    total = total * radix + val;\n  }\n  if (pos === start || (len != null && pos - start !== len) || invalid) {\n    return { n: null, pos };\n  }\n\n  return { n: total, pos };\n}\n\nexport type CodePointErrorHandlers = HexCharErrorHandlers & {\n  invalidCodePoint(pos: number, lineStart: number, curLine: number): void;\n};\n\nexport function readCodePoint(\n  input: string,\n  pos: number,\n  lineStart: number,\n  curLine: number,\n  throwOnInvalid: boolean,\n  errors: CodePointErrorHandlers,\n) {\n  const ch = input.charCodeAt(pos);\n  let code;\n\n  if (ch === charCodes.leftCurlyBrace) {\n    ++pos;\n    ({ code, pos } = readHexChar(\n      input,\n      pos,\n      lineStart,\n      curLine,\n      input.indexOf(\"}\", pos) - pos,\n      true,\n      throwOnInvalid,\n      errors,\n    ));\n    ++pos;\n    if (code !== null && code > 0x10ffff) {\n      if (throwOnInvalid) {\n        errors.invalidCodePoint(pos, lineStart, curLine);\n      } else {\n        return { code: null, pos };\n      }\n    }\n  } else {\n    ({ code, pos } = readHexChar(\n      input,\n      pos,\n      lineStart,\n      curLine,\n      4,\n      false,\n      throwOnInvalid,\n      errors,\n    ));\n  }\n  return { code, pos };\n}\n", "export const STATEMENT_OR_BLOCK_KEYS = [\"consequent\", \"body\", \"alternate\"];\nexport const FLATTENABLE_KEYS = [\"body\", \"expressions\"];\nexport const FOR_INIT_KEYS = [\"left\", \"init\"];\nexport const COMMENT_KEYS = [\n  \"leadingComments\",\n  \"trailingComments\",\n  \"innerComments\",\n] as const;\n\nexport const LOGICAL_OPERATORS = [\"||\", \"&&\", \"??\"];\nexport const UPDATE_OPERATORS = [\"++\", \"--\"];\n\nexport const BOOLEAN_NUMBER_BINARY_OPERATORS = [\">\", \"<\", \">=\", \"<=\"];\nexport const EQUALITY_BINARY_OPERATORS = [\"==\", \"===\", \"!=\", \"!==\"];\nexport const COMPARISON_BINARY_OPERATORS = [\n  ...EQUALITY_BINARY_OPERATORS,\n  \"in\",\n  \"instanceof\",\n];\nexport const BOOLEAN_BINARY_OPERATORS = [\n  ...COMPARISON_BINARY_OPERATORS,\n  ...BOOLEAN_NUMBER_BINARY_OPERATORS,\n];\nexport const NUMBER_BINARY_OPERATORS = [\n  \"-\",\n  \"/\",\n  \"%\",\n  \"*\",\n  \"**\",\n  \"&\",\n  \"|\",\n  \">>\",\n  \">>>\",\n  \"<<\",\n  \"^\",\n];\nexport const BINARY_OPERATORS = [\n  \"+\",\n  ...NUMBER_BINARY_OPERATORS,\n  ...BOOLEAN_BINARY_OPERATORS,\n  \"|>\",\n];\n\nexport const ASSIGNMENT_OPERATORS = [\n  \"=\",\n  \"+=\",\n  ...NUMBER_BINARY_OPERATORS.map(op => op + \"=\"),\n  ...LOGICAL_OPERATORS.map(op => op + \"=\"),\n];\n\nexport const BOOLEAN_UNARY_OPERATORS = [\"delete\", \"!\"];\nexport const NUMBER_UNARY_OPERATORS = [\"+\", \"-\", \"~\"];\nexport const STRING_UNARY_OPERATORS = [\"typeof\"];\nexport const UNARY_OPERATORS = [\n  \"void\",\n  \"throw\",\n  ...BOOLEAN_UNARY_OPERATORS,\n  ...NUMBER_UNARY_OPERATORS,\n  ...STRING_UNARY_OPERATORS,\n];\n\nexport const INHERIT_KEYS = {\n  optional: [\"typeAnnotation\", \"typeParameters\", \"returnType\"],\n  force: [\"start\", \"loc\", \"end\"],\n} as const;\n\nexport const BLOCK_SCOPED_SYMBOL = Symbol.for(\"var used to be block scoped\");\nexport const NOT_LOCAL_BINDING = Symbol.for(\n  \"should not be considered a local binding\",\n);\n", "import is from \"../validators/is.ts\";\nimport { validateField, validateChild } from \"../validators/validate.ts\";\nimport type * as t from \"../index.ts\";\n\nexport const VISITOR_KEYS: Record<string, string[]> = {};\nexport const ALIAS_KEYS: Partial<Record<NodeTypesWithoutComment, string[]>> =\n  {};\nexport const FLIPPED_ALIAS_KEYS: Record<string, NodeTypesWithoutComment[]> = {};\nexport const NODE_FIELDS: Record<string, FieldDefinitions> = {};\nexport const BUILDER_KEYS: Record<string, string[]> = {};\nexport const DEPRECATED_KEYS: Record<string, NodeTypesWithoutComment> = {};\nexport const NODE_PARENT_VALIDATIONS: Record<string, Validator> = {};\n\nfunction getType(val: any) {\n  if (Array.isArray(val)) {\n    return \"array\";\n  } else if (val === null) {\n    return \"null\";\n  } else {\n    return typeof val;\n  }\n}\n\ntype NodeTypesWithoutComment = t.Node[\"type\"] | keyof t.Aliases;\n\ntype NodeTypes = NodeTypesWithoutComment | t.Comment[\"type\"];\n\ntype PrimitiveTypes = ReturnType<typeof getType>;\n\ntype FieldDefinitions = {\n  [x: string]: FieldOptions;\n};\n\ntype DefineTypeOpts = {\n  fields?: FieldDefinitions;\n  visitor?: Array<string>;\n  aliases?: Array<string>;\n  builder?: Array<string>;\n  inherits?: NodeTypes;\n  deprecatedAlias?: string;\n  validate?: Validator;\n};\n\nexport type Validator = (\n  | { type: PrimitiveTypes }\n  | { each: Validator }\n  | { chainOf: Validator[] }\n  | { oneOf: any[] }\n  | { oneOfNodeTypes: NodeTypes[] }\n  | { oneOfNodeOrValueTypes: (NodeTypes | PrimitiveTypes)[] }\n  | { shapeOf: { [x: string]: FieldOptions } }\n  | object\n) &\n  ((node: t.Node, key: string, val: any) => void);\n\nexport type FieldOptions = {\n  default?: string | number | boolean | [];\n  optional?: boolean;\n  deprecated?: boolean;\n  validate?: Validator;\n};\n\nexport function validate(validate: Validator): FieldOptions {\n  return { validate };\n}\n\nexport function validateType(...typeNames: NodeTypes[]) {\n  return validate(assertNodeType(...typeNames));\n}\n\nexport function validateOptional(validate: Validator): FieldOptions {\n  return { validate, optional: true };\n}\n\nexport function validateOptionalType(...typeNames: NodeTypes[]): FieldOptions {\n  return { validate: assertNodeType(...typeNames), optional: true };\n}\n\nexport function arrayOf(elementType: Validator): Validator {\n  return chain(assertValueType(\"array\"), assertEach(elementType));\n}\n\nexport function arrayOfType(...typeNames: NodeTypes[]) {\n  return arrayOf(assertNodeType(...typeNames));\n}\n\nexport function validateArrayOfType(...typeNames: NodeTypes[]) {\n  return validate(arrayOfType(...typeNames));\n}\n\nexport function assertEach(callback: Validator): Validator {\n  const childValidator = process.env.BABEL_TYPES_8_BREAKING\n    ? validateChild\n    : () => {};\n\n  function validator(node: t.Node, key: string, val: any) {\n    if (!Array.isArray(val)) return;\n\n    for (let i = 0; i < val.length; i++) {\n      const subkey = `${key}[${i}]`;\n      const v = val[i];\n      callback(node, subkey, v);\n      childValidator(node, subkey, v);\n    }\n  }\n  validator.each = callback;\n  return validator;\n}\n\nexport function assertOneOf(...values: Array<any>): Validator {\n  function validate(node: any, key: string, val: any) {\n    if (!values.includes(val)) {\n      throw new TypeError(\n        `Property ${key} expected value to be one of ${JSON.stringify(\n          values,\n        )} but got ${JSON.stringify(val)}`,\n      );\n    }\n  }\n\n  validate.oneOf = values;\n\n  return validate;\n}\n\nexport function assertNodeType(...types: NodeTypes[]): Validator {\n  function validate(node: t.Node, key: string, val: any) {\n    for (const type of types) {\n      if (is(type, val)) {\n        validateChild(node, key, val);\n        return;\n      }\n    }\n\n    throw new TypeError(\n      `Property ${key} of ${\n        node.type\n      } expected node to be of a type ${JSON.stringify(\n        types,\n      )} but instead got ${JSON.stringify(val?.type)}`,\n    );\n  }\n\n  validate.oneOfNodeTypes = types;\n\n  return validate;\n}\n\nexport function assertNodeOrValueType(\n  ...types: (NodeTypes | PrimitiveTypes)[]\n): Validator {\n  function validate(node: t.Node, key: string, val: any) {\n    for (const type of types) {\n      if (getType(val) === type || is(type, val)) {\n        validateChild(node, key, val);\n        return;\n      }\n    }\n\n    throw new TypeError(\n      `Property ${key} of ${\n        node.type\n      } expected node to be of a type ${JSON.stringify(\n        types,\n      )} but instead got ${JSON.stringify(val?.type)}`,\n    );\n  }\n\n  validate.oneOfNodeOrValueTypes = types;\n\n  return validate;\n}\n\nexport function assertValueType(type: PrimitiveTypes): Validator {\n  function validate(node: t.Node, key: string, val: any) {\n    const valid = getType(val) === type;\n\n    if (!valid) {\n      throw new TypeError(\n        `Property ${key} expected type of ${type} but got ${getType(val)}`,\n      );\n    }\n  }\n\n  validate.type = type;\n\n  return validate;\n}\n\nexport function assertShape(shape: { [x: string]: FieldOptions }): Validator {\n  function validate(node: t.Node, key: string, val: any) {\n    const errors = [];\n    for (const property of Object.keys(shape)) {\n      try {\n        validateField(node, property, val[property], shape[property]);\n      } catch (error) {\n        if (error instanceof TypeError) {\n          errors.push(error.message);\n          continue;\n        }\n        throw error;\n      }\n    }\n    if (errors.length) {\n      throw new TypeError(\n        `Property ${key} of ${\n          node.type\n        } expected to have the following:\\n${errors.join(\"\\n\")}`,\n      );\n    }\n  }\n\n  validate.shapeOf = shape;\n\n  return validate;\n}\n\nexport function assertOptionalChainStart(): Validator {\n  function validate(node: t.Node) {\n    let current = node;\n    while (node) {\n      const { type } = current;\n      if (type === \"OptionalCallExpression\") {\n        if (current.optional) return;\n        current = current.callee;\n        continue;\n      }\n\n      if (type === \"OptionalMemberExpression\") {\n        if (current.optional) return;\n        current = current.object;\n        continue;\n      }\n\n      break;\n    }\n\n    throw new TypeError(\n      `Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${current?.type}`,\n    );\n  }\n\n  return validate;\n}\n\nexport function chain(...fns: Array<Validator>): Validator {\n  function validate(...args: Parameters<Validator>) {\n    for (const fn of fns) {\n      fn(...args);\n    }\n  }\n  validate.chainOf = fns;\n\n  if (\n    fns.length >= 2 &&\n    \"type\" in fns[0] &&\n    fns[0].type === \"array\" &&\n    !(\"each\" in fns[1])\n  ) {\n    throw new Error(\n      `An assertValueType(\"array\") validator can only be followed by an assertEach(...) validator.`,\n    );\n  }\n\n  return validate;\n}\n\nconst validTypeOpts = new Set([\n  \"aliases\",\n  \"builder\",\n  \"deprecatedAlias\",\n  \"fields\",\n  \"inherits\",\n  \"visitor\",\n  \"validate\",\n]);\nconst validFieldKeys = new Set([\n  \"default\",\n  \"optional\",\n  \"deprecated\",\n  \"validate\",\n]);\n\nconst store = {} as Record<string, DefineTypeOpts>;\n\n// Wraps defineType to ensure these aliases are included.\nexport function defineAliasedType(...aliases: string[]) {\n  return (type: string, opts: DefineTypeOpts = {}) => {\n    let defined = opts.aliases;\n    if (!defined) {\n      if (opts.inherits) defined = store[opts.inherits].aliases?.slice();\n      defined ??= [];\n      opts.aliases = defined;\n    }\n    const additional = aliases.filter(a => !defined.includes(a));\n    defined.unshift(...additional);\n    defineType(type, opts);\n  };\n}\n\nexport default function defineType(type: string, opts: DefineTypeOpts = {}) {\n  const inherits = (opts.inherits && store[opts.inherits]) || {};\n\n  let fields = opts.fields;\n  if (!fields) {\n    fields = {};\n    if (inherits.fields) {\n      const keys = Object.getOwnPropertyNames(inherits.fields);\n      for (const key of keys) {\n        const field = inherits.fields[key];\n        const def = field.default;\n        if (\n          Array.isArray(def) ? def.length > 0 : def && typeof def === \"object\"\n        ) {\n          throw new Error(\n            \"field defaults can only be primitives or empty arrays currently\",\n          );\n        }\n        fields[key] = {\n          default: Array.isArray(def) ? [] : def,\n          optional: field.optional,\n          deprecated: field.deprecated,\n          validate: field.validate,\n        };\n      }\n    }\n  }\n\n  const visitor: Array<string> = opts.visitor || inherits.visitor || [];\n  const aliases: Array<string> = opts.aliases || inherits.aliases || [];\n  const builder: Array<string> =\n    opts.builder || inherits.builder || opts.visitor || [];\n\n  for (const k of Object.keys(opts)) {\n    if (!validTypeOpts.has(k)) {\n      throw new Error(`Unknown type option \"${k}\" on ${type}`);\n    }\n  }\n\n  if (opts.deprecatedAlias) {\n    DEPRECATED_KEYS[opts.deprecatedAlias] = type as NodeTypesWithoutComment;\n  }\n\n  // ensure all field keys are represented in `fields`\n  for (const key of visitor.concat(builder)) {\n    fields[key] = fields[key] || {};\n  }\n\n  for (const key of Object.keys(fields)) {\n    const field = fields[key];\n\n    if (field.default !== undefined && !builder.includes(key)) {\n      field.optional = true;\n    }\n    if (field.default === undefined) {\n      field.default = null;\n    } else if (!field.validate && field.default != null) {\n      field.validate = assertValueType(getType(field.default));\n    }\n\n    for (const k of Object.keys(field)) {\n      if (!validFieldKeys.has(k)) {\n        throw new Error(`Unknown field key \"${k}\" on ${type}.${key}`);\n      }\n    }\n  }\n\n  VISITOR_KEYS[type] = opts.visitor = visitor;\n  BUILDER_KEYS[type] = opts.builder = builder;\n  NODE_FIELDS[type] = opts.fields = fields;\n  ALIAS_KEYS[type as NodeTypesWithoutComment] = opts.aliases = aliases;\n  aliases.forEach(alias => {\n    FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];\n    FLIPPED_ALIAS_KEYS[alias].push(type as NodeTypesWithoutComment);\n  });\n\n  if (opts.validate) {\n    NODE_PARENT_VALIDATIONS[type] = opts.validate;\n  }\n\n  store[type] = opts;\n}\n", "import is from \"../validators/is.ts\";\nimport isValidIdentifier from \"../validators/isValidIdentifier.ts\";\nimport { isKeyword, isReservedWord } from \"@babel/helper-validator-identifier\";\nimport type * as t from \"../index.ts\";\nimport { readStringContents } from \"@babel/helper-string-parser\";\n\nimport {\n  BINARY_OPERATORS,\n  LOGICAL_OPERATORS,\n  ASSIGNMENT_OPERATORS,\n  UNARY_OPERATORS,\n  UPDATE_OPERATORS,\n} from \"../constants/index.ts\";\n\nimport {\n  defineAliasedType,\n  assertShape,\n  assertOptionalChainStart,\n  assertValueType,\n  assertNodeType,\n  assertNodeOrValueType,\n  assertEach,\n  chain,\n  assertOneOf,\n  validateOptional,\n  type Validator,\n  arrayOf,\n  arrayOfType,\n  validateArrayOfType,\n  validateType,\n} from \"./utils.ts\";\n\nconst defineType = defineAliasedType(\"Standardized\");\n\ndefineType(\"ArrayExpression\", {\n  fields: {\n    elements: {\n      validate: arrayOf(\n        assertNodeOrValueType(\"null\", \"Expression\", \"SpreadElement\"),\n      ),\n      default:\n        !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n          ? []\n          : undefined,\n    },\n  },\n  visitor: [\"elements\"],\n  aliases: [\"Expression\"],\n});\n\ndefineType(\"AssignmentExpression\", {\n  fields: {\n    operator: {\n      validate:\n        !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n          ? assertValueType(\"string\")\n          : Object.assign(\n              (function () {\n                const identifier = assertOneOf(...ASSIGNMENT_OPERATORS);\n                const pattern = assertOneOf(\"=\");\n\n                return function (node: t.AssignmentExpression, key, val) {\n                  const validator = is(\"Pattern\", node.left)\n                    ? pattern\n                    : identifier;\n                  validator(node, key, val);\n                } as Validator;\n              })(),\n              { type: \"string\" },\n            ),\n    },\n    left: {\n      validate:\n        !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n          ? assertNodeType(\"LVal\", \"OptionalMemberExpression\")\n          : assertNodeType(\n              \"Identifier\",\n              \"MemberExpression\",\n              \"OptionalMemberExpression\",\n              \"ArrayPattern\",\n              \"ObjectPattern\",\n              \"TSAsExpression\",\n              \"TSSatisfiesExpression\",\n              \"TSTypeAssertion\",\n              \"TSNonNullExpression\",\n            ),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Expression\"],\n});\n\ndefineType(\"BinaryExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  fields: {\n    operator: {\n      validate: assertOneOf(...BINARY_OPERATORS),\n    },\n    left: {\n      validate: (function () {\n        const expression = assertNodeType(\"Expression\");\n        const inOp = assertNodeType(\"Expression\", \"PrivateName\");\n\n        const validator: Validator = Object.assign(\n          function (node: t.BinaryExpression, key, val) {\n            const validator = node.operator === \"in\" ? inOp : expression;\n            validator(node, key, val);\n          } as Validator,\n          // todo(ts): can be discriminated union by `operator` property\n          { oneOfNodeTypes: [\"Expression\", \"PrivateName\"] },\n        );\n        return validator;\n      })(),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"],\n});\n\ndefineType(\"InterpreterDirective\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: assertValueType(\"string\"),\n    },\n  },\n});\n\ndefineType(\"Directive\", {\n  visitor: [\"value\"],\n  fields: {\n    value: {\n      validate: assertNodeType(\"DirectiveLiteral\"),\n    },\n  },\n});\n\ndefineType(\"DirectiveLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: assertValueType(\"string\"),\n    },\n  },\n});\n\ndefineType(\"BlockStatement\", {\n  builder: [\"body\", \"directives\"],\n  visitor: [\"directives\", \"body\"],\n  fields: {\n    directives: {\n      validate: arrayOfType(\"Directive\"),\n      default: [],\n    },\n    body: validateArrayOfType(\"Statement\"),\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\", \"Statement\"],\n});\n\ndefineType(\"BreakStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: assertNodeType(\"Identifier\"),\n      optional: true,\n    },\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n});\n\ndefineType(\"CallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\", \"typeArguments\"],\n  builder: [\"callee\", \"arguments\"],\n  aliases: [\"Expression\"],\n  fields: {\n    callee: {\n      validate: assertNodeType(\"Expression\", \"Super\", \"V8IntrinsicIdentifier\"),\n    },\n    arguments: validateArrayOfType(\n      \"Expression\",\n      \"SpreadElement\",\n      \"ArgumentPlaceholder\",\n    ),\n    ...(!process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n      ? {\n          optional: {\n            validate: assertValueType(\"boolean\"),\n            optional: true,\n          },\n        }\n      : {}),\n    typeArguments: {\n      validate: assertNodeType(\"TypeParameterInstantiation\"),\n      optional: true,\n    },\n    typeParameters: {\n      validate: assertNodeType(\"TSTypeParameterInstantiation\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"CatchClause\", {\n  visitor: [\"param\", \"body\"],\n  fields: {\n    param: {\n      validate: assertNodeType(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\"),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n  },\n  aliases: [\"Scopable\", \"BlockParent\"],\n});\n\ndefineType(\"ConditionalExpression\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  fields: {\n    test: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    consequent: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    alternate: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n  aliases: [\"Expression\", \"Conditional\"],\n});\n\ndefineType(\"ContinueStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: assertNodeType(\"Identifier\"),\n      optional: true,\n    },\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n});\n\ndefineType(\"DebuggerStatement\", {\n  aliases: [\"Statement\"],\n});\n\ndefineType(\"DoWhileStatement\", {\n  builder: [\"test\", \"body\"],\n  visitor: [\"body\", \"test\"],\n  fields: {\n    test: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"],\n});\n\ndefineType(\"EmptyStatement\", {\n  aliases: [\"Statement\"],\n});\n\ndefineType(\"ExpressionStatement\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n  aliases: [\"Statement\", \"ExpressionWrapper\"],\n});\n\ndefineType(\"File\", {\n  builder: [\"program\", \"comments\", \"tokens\"],\n  visitor: [\"program\"],\n  fields: {\n    program: {\n      validate: assertNodeType(\"Program\"),\n    },\n    comments: {\n      validate:\n        !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n          ? Object.assign(() => {}, {\n              each: { oneOfNodeTypes: [\"CommentBlock\", \"CommentLine\"] },\n            })\n          : assertEach(assertNodeType(\"CommentBlock\", \"CommentLine\")),\n      optional: true,\n    },\n    tokens: {\n      // todo(ts): add Token type\n      validate: assertEach(Object.assign(() => {}, { type: \"any\" })),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ForInStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  aliases: [\n    \"Scopable\",\n    \"Statement\",\n    \"For\",\n    \"BlockParent\",\n    \"Loop\",\n    \"ForXStatement\",\n  ],\n  fields: {\n    left: {\n      validate:\n        !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n          ? assertNodeType(\"VariableDeclaration\", \"LVal\")\n          : assertNodeType(\n              \"VariableDeclaration\",\n              \"Identifier\",\n              \"MemberExpression\",\n              \"ArrayPattern\",\n              \"ObjectPattern\",\n              \"TSAsExpression\",\n              \"TSSatisfiesExpression\",\n              \"TSTypeAssertion\",\n              \"TSNonNullExpression\",\n            ),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\ndefineType(\"ForStatement\", {\n  visitor: [\"init\", \"test\", \"update\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\"],\n  fields: {\n    init: {\n      validate: assertNodeType(\"VariableDeclaration\", \"Expression\"),\n      optional: true,\n    },\n    test: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    update: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\nexport const functionCommon = () => ({\n  params: validateArrayOfType(\"Identifier\", \"Pattern\", \"RestElement\"),\n  generator: {\n    default: false,\n  },\n  async: {\n    default: false,\n  },\n});\n\nexport const functionTypeAnnotationCommon = () => ({\n  returnType: {\n    validate: process.env.BABEL_8_BREAKING\n      ? assertNodeType(\"TypeAnnotation\", \"TSTypeAnnotation\")\n      : assertNodeType(\n          \"TypeAnnotation\",\n          \"TSTypeAnnotation\",\n          // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n          \"Noop\",\n        ),\n    optional: true,\n  },\n  typeParameters: {\n    validate: process.env.BABEL_8_BREAKING\n      ? assertNodeType(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\")\n      : assertNodeType(\n          \"TypeParameterDeclaration\",\n          \"TSTypeParameterDeclaration\",\n          // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n          \"Noop\",\n        ),\n    optional: true,\n  },\n});\n\nexport const functionDeclarationCommon = () => ({\n  ...functionCommon(),\n  declare: {\n    validate: assertValueType(\"boolean\"),\n    optional: true,\n  },\n  id: {\n    validate: assertNodeType(\"Identifier\"),\n    optional: true, // May be null for `export default function`\n  },\n});\n\ndefineType(\"FunctionDeclaration\", {\n  builder: [\"id\", \"params\", \"body\", \"generator\", \"async\"],\n  visitor: [\"id\", \"typeParameters\", \"params\", \"returnType\", \"body\"],\n  fields: {\n    ...functionDeclarationCommon(),\n    ...functionTypeAnnotationCommon(),\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n    predicate: {\n      validate: assertNodeType(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true,\n    },\n  },\n  aliases: [\n    \"Scopable\",\n    \"Function\",\n    \"BlockParent\",\n    \"FunctionParent\",\n    \"Statement\",\n    \"Pureish\",\n    \"Declaration\",\n  ],\n  validate:\n    !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n      ? undefined\n      : (function () {\n          const identifier = assertNodeType(\"Identifier\");\n\n          return function (parent, key, node) {\n            if (!is(\"ExportDefaultDeclaration\", parent)) {\n              identifier(node, \"id\", node.id);\n            }\n          };\n        })(),\n});\n\ndefineType(\"FunctionExpression\", {\n  inherits: \"FunctionDeclaration\",\n  aliases: [\n    \"Scopable\",\n    \"Function\",\n    \"BlockParent\",\n    \"FunctionParent\",\n    \"Expression\",\n    \"Pureish\",\n  ],\n  fields: {\n    ...functionCommon(),\n    ...functionTypeAnnotationCommon(),\n    id: {\n      validate: assertNodeType(\"Identifier\"),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n    predicate: {\n      validate: assertNodeType(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true,\n    },\n  },\n});\n\nexport const patternLikeCommon = () => ({\n  typeAnnotation: {\n    validate: process.env.BABEL_8_BREAKING\n      ? assertNodeType(\"TypeAnnotation\", \"TSTypeAnnotation\")\n      : assertNodeType(\n          \"TypeAnnotation\",\n          \"TSTypeAnnotation\",\n          // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n          \"Noop\",\n        ),\n    optional: true,\n  },\n  optional: {\n    validate: assertValueType(\"boolean\"),\n    optional: true,\n  },\n  decorators: {\n    validate: arrayOfType(\"Decorator\"),\n    optional: true,\n  },\n});\n\ndefineType(\"Identifier\", {\n  builder: [\"name\"],\n  visitor: [\"typeAnnotation\", \"decorators\" /* for legacy param decorators */],\n  aliases: [\"Expression\", \"PatternLike\", \"LVal\", \"TSEntityName\"],\n  fields: {\n    ...patternLikeCommon(),\n    name: {\n      validate:\n        process.env.BABEL_8_BREAKING || process.env.BABEL_TYPES_8_BREAKING\n          ? chain(\n              assertValueType(\"string\"),\n              Object.assign(\n                function (node, key, val) {\n                  if (!isValidIdentifier(val, false)) {\n                    throw new TypeError(\n                      `\"${val}\" is not a valid identifier name`,\n                    );\n                  }\n                } as Validator,\n                { type: \"string\" },\n              ),\n            )\n          : assertValueType(\"string\"),\n    },\n  },\n  validate:\n    process.env.BABEL_8_BREAKING || process.env.BABEL_TYPES_8_BREAKING\n      ? function (parent, key, node) {\n          const match = /\\.(\\w+)$/.exec(key);\n          if (!match) return;\n\n          const [, parentKey] = match;\n          const nonComp = { computed: false };\n\n          // We can't check if `parent.property === node`, because nodes are validated\n          // before replacing them in the AST.\n          if (parentKey === \"property\") {\n            if (is(\"MemberExpression\", parent, nonComp)) return;\n            if (is(\"OptionalMemberExpression\", parent, nonComp)) return;\n          } else if (parentKey === \"key\") {\n            if (is(\"Property\", parent, nonComp)) return;\n            if (is(\"Method\", parent, nonComp)) return;\n          } else if (parentKey === \"exported\") {\n            if (is(\"ExportSpecifier\", parent)) return;\n          } else if (parentKey === \"imported\") {\n            if (is(\"ImportSpecifier\", parent, { imported: node })) return;\n          } else if (parentKey === \"meta\") {\n            if (is(\"MetaProperty\", parent, { meta: node })) return;\n          }\n\n          if (\n            // Ideally we should call isStrictReservedWord if this node is a descendant\n            // of a block in strict mode. Also, we should pass the inModule option so\n            // we can disable \"await\" in module.\n            (isKeyword(node.name) || isReservedWord(node.name, false)) &&\n            // Even if \"this\" is a keyword, we are using the Identifier\n            // node to represent it.\n            node.name !== \"this\"\n          ) {\n            throw new TypeError(`\"${node.name}\" is not a valid identifier`);\n          }\n        }\n      : undefined,\n});\n\ndefineType(\"IfStatement\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  aliases: [\"Statement\", \"Conditional\"],\n  fields: {\n    test: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    consequent: {\n      validate: assertNodeType(\"Statement\"),\n    },\n    alternate: {\n      optional: true,\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\ndefineType(\"LabeledStatement\", {\n  visitor: [\"label\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    label: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\ndefineType(\"StringLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: assertValueType(\"string\"),\n    },\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"],\n});\n\ndefineType(\"NumericLiteral\", {\n  builder: [\"value\"],\n  deprecatedAlias: \"NumberLiteral\",\n  fields: {\n    value: {\n      validate: chain(\n        assertValueType(\"number\"),\n        Object.assign(\n          function (node, key, val) {\n            if (1 / val < 0 || !Number.isFinite(val)) {\n              const error = new Error(\n                \"NumericLiterals must be non-negative finite numbers. \" +\n                  `You can use t.valueToNode(${val}) instead.`,\n              );\n              if (process.env.BABEL_8_BREAKING) {\n                // TODO(@nicolo-ribaudo) Fix regenerator to not pass negative\n                // numbers here.\n                if (!IS_STANDALONE) {\n                  if (!new Error().stack.includes(\"regenerator\")) {\n                    throw error;\n                  }\n                }\n              } else {\n                // TODO: Enable this warning once regenerator is fixed.\n                // https://github.com/facebook/regenerator/pull/680\n                // console.warn(error);\n              }\n            }\n          } satisfies Validator,\n          { type: \"number\" },\n        ),\n      ),\n    },\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"],\n});\n\ndefineType(\"NullLiteral\", {\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"],\n});\n\ndefineType(\"BooleanLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: assertValueType(\"boolean\"),\n    },\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"],\n});\n\ndefineType(\"RegExpLiteral\", {\n  builder: [\"pattern\", \"flags\"],\n  deprecatedAlias: \"RegexLiteral\",\n  aliases: [\"Expression\", \"Pureish\", \"Literal\"],\n  fields: {\n    pattern: {\n      validate: assertValueType(\"string\"),\n    },\n    flags: {\n      validate:\n        process.env.BABEL_8_BREAKING || process.env.BABEL_TYPES_8_BREAKING\n          ? chain(\n              assertValueType(\"string\"),\n              Object.assign(\n                function (node, key, val) {\n                  const invalid = /[^gimsuy]/.exec(val);\n                  if (invalid) {\n                    throw new TypeError(\n                      `\"${invalid[0]}\" is not a valid RegExp flag`,\n                    );\n                  }\n                } as Validator,\n                { type: \"string\" },\n              ),\n            )\n          : assertValueType(\"string\"),\n      default: \"\",\n    },\n  },\n});\n\ndefineType(\"LogicalExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"],\n  fields: {\n    operator: {\n      validate: assertOneOf(...LOGICAL_OPERATORS),\n    },\n    left: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"MemberExpression\", {\n  builder: [\n    \"object\",\n    \"property\",\n    \"computed\",\n    ...(!process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n      ? [\"optional\"]\n      : []),\n  ],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\", \"LVal\"],\n  fields: {\n    object: {\n      validate: assertNodeType(\"Expression\", \"Super\"),\n    },\n    property: {\n      validate: (function () {\n        const normal = assertNodeType(\"Identifier\", \"PrivateName\");\n        const computed = assertNodeType(\"Expression\");\n\n        const validator: Validator = function (\n          node: t.MemberExpression,\n          key,\n          val,\n        ) {\n          const validator: Validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n        // @ts-expect-error todo(ts): can be discriminated union by `computed` property\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"PrivateName\"];\n        return validator;\n      })(),\n    },\n    computed: {\n      default: false,\n    },\n    ...(!process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n      ? {\n          optional: {\n            validate: assertValueType(\"boolean\"),\n            optional: true,\n          },\n        }\n      : {}),\n  },\n});\n\ndefineType(\"NewExpression\", { inherits: \"CallExpression\" });\n\ndefineType(\"Program\", {\n  // Note: We explicitly leave 'interpreter' out here because it is\n  // conceptually comment-like, and Babel does not traverse comments either.\n  visitor: [\"directives\", \"body\"],\n  builder: [\"body\", \"directives\", \"sourceType\", \"interpreter\"],\n  fields: {\n    sourceType: {\n      validate: assertOneOf(\"script\", \"module\"),\n      default: \"script\",\n    },\n    interpreter: {\n      validate: assertNodeType(\"InterpreterDirective\"),\n      default: null,\n      optional: true,\n    },\n    directives: {\n      validate: arrayOfType(\"Directive\"),\n      default: [],\n    },\n    body: validateArrayOfType(\"Statement\"),\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\"],\n});\n\ndefineType(\"ObjectExpression\", {\n  visitor: [\"properties\"],\n  aliases: [\"Expression\"],\n  fields: {\n    properties: validateArrayOfType(\n      \"ObjectMethod\",\n      \"ObjectProperty\",\n      \"SpreadElement\",\n    ),\n  },\n});\n\ndefineType(\"ObjectMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"generator\", \"async\"],\n  visitor: [\n    \"decorators\",\n    \"key\",\n    \"typeParameters\",\n    \"params\",\n    \"returnType\",\n    \"body\",\n  ],\n  fields: {\n    ...functionCommon(),\n    ...functionTypeAnnotationCommon(),\n    kind: {\n      validate: assertOneOf(\"method\", \"get\", \"set\"),\n      ...(!process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n        ? { default: \"method\" }\n        : {}),\n    },\n    computed: {\n      default: false,\n    },\n    key: {\n      validate: (function () {\n        const normal = assertNodeType(\n          \"Identifier\",\n          \"StringLiteral\",\n          \"NumericLiteral\",\n          \"BigIntLiteral\",\n        );\n        const computed = assertNodeType(\"Expression\");\n\n        const validator: Validator = function (node: t.ObjectMethod, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n        // @ts-expect-error todo(ts): can be discriminated union by `computed` property\n        validator.oneOfNodeTypes = [\n          \"Expression\",\n          \"Identifier\",\n          \"StringLiteral\",\n          \"NumericLiteral\",\n          \"BigIntLiteral\",\n        ];\n        return validator;\n      })(),\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n  },\n  aliases: [\n    \"UserWhitespacable\",\n    \"Function\",\n    \"Scopable\",\n    \"BlockParent\",\n    \"FunctionParent\",\n    \"Method\",\n    \"ObjectMember\",\n  ],\n});\n\ndefineType(\"ObjectProperty\", {\n  builder: [\n    \"key\",\n    \"value\",\n    \"computed\",\n    \"shorthand\",\n    ...(!process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n      ? [\"decorators\"]\n      : []),\n  ],\n  fields: {\n    computed: {\n      default: false,\n    },\n    key: {\n      validate: (function () {\n        const normal = process.env.BABEL_8_BREAKING\n          ? assertNodeType(\n              \"Identifier\",\n              \"StringLiteral\",\n              \"NumericLiteral\",\n              \"BigIntLiteral\",\n              \"PrivateName\",\n            )\n          : assertNodeType(\n              \"Identifier\",\n              \"StringLiteral\",\n              \"NumericLiteral\",\n              \"BigIntLiteral\",\n              // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n              \"DecimalLiteral\",\n              \"PrivateName\",\n            );\n        const computed = assertNodeType(\"Expression\");\n\n        const validator: Validator = Object.assign(\n          function (node: t.ObjectProperty, key, val) {\n            const validator = node.computed ? computed : normal;\n            validator(node, key, val);\n          } as Validator,\n          {\n            // todo(ts): can be discriminated union by `computed` property\n            oneOfNodeTypes: process.env.BABEL_8_BREAKING\n              ? [\n                  \"Expression\",\n                  \"Identifier\",\n                  \"StringLiteral\",\n                  \"NumericLiteral\",\n                  \"BigIntLiteral\",\n                  \"PrivateName\",\n                ]\n              : [\n                  \"Expression\",\n                  \"Identifier\",\n                  \"StringLiteral\",\n                  \"NumericLiteral\",\n                  \"BigIntLiteral\",\n                  \"DecimalLiteral\",\n                  \"PrivateName\",\n                ],\n          },\n        );\n        return validator;\n      })(),\n    },\n    value: {\n      // Value may be PatternLike if this is an AssignmentProperty\n      // https://github.com/babel/babylon/issues/434\n      validate: assertNodeType(\"Expression\", \"PatternLike\"),\n    },\n    shorthand: {\n      validate:\n        process.env.BABEL_8_BREAKING || process.env.BABEL_TYPES_8_BREAKING\n          ? chain(\n              assertValueType(\"boolean\"),\n              Object.assign(\n                function (node: t.ObjectProperty, key, shorthand) {\n                  if (!shorthand) return;\n\n                  if (node.computed) {\n                    throw new TypeError(\n                      \"Property shorthand of ObjectProperty cannot be true if computed is true\",\n                    );\n                  }\n\n                  if (!is(\"Identifier\", node.key)) {\n                    throw new TypeError(\n                      \"Property shorthand of ObjectProperty cannot be true if key is not an Identifier\",\n                    );\n                  }\n                } as Validator,\n                { type: \"boolean\" },\n              ),\n            )\n          : assertValueType(\"boolean\"),\n      default: false,\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n  },\n  visitor: [\"key\", \"value\", \"decorators\"],\n  aliases: [\"UserWhitespacable\", \"Property\", \"ObjectMember\"],\n  validate:\n    !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n      ? undefined\n      : (function () {\n          const pattern = assertNodeType(\n            \"Identifier\",\n            \"Pattern\",\n            \"TSAsExpression\",\n            \"TSSatisfiesExpression\",\n            \"TSNonNullExpression\",\n            \"TSTypeAssertion\",\n          );\n          const expression = assertNodeType(\"Expression\");\n\n          return function (parent, key, node) {\n            const validator = is(\"ObjectPattern\", parent)\n              ? pattern\n              : expression;\n            validator(node, \"value\", node.value);\n          };\n        })(),\n});\n\ndefineType(\"RestElement\", {\n  visitor: [\"argument\", \"typeAnnotation\"],\n  builder: [\"argument\"],\n  aliases: [\"LVal\", \"PatternLike\"],\n  deprecatedAlias: \"RestProperty\",\n  fields: {\n    ...patternLikeCommon(),\n    argument: {\n      validate:\n        !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n          ? assertNodeType(\"LVal\")\n          : assertNodeType(\n              \"Identifier\",\n              \"ArrayPattern\",\n              \"ObjectPattern\",\n              \"MemberExpression\",\n              \"TSAsExpression\",\n              \"TSSatisfiesExpression\",\n              \"TSTypeAssertion\",\n              \"TSNonNullExpression\",\n            ),\n    },\n  },\n  validate:\n    process.env.BABEL_8_BREAKING || process.env.BABEL_TYPES_8_BREAKING\n      ? function (parent: t.ArrayPattern | t.ObjectPattern, key) {\n          const match = /(\\w+)\\[(\\d+)\\]/.exec(key);\n          if (!match) throw new Error(\"Internal Babel error: malformed key.\");\n\n          const [, listKey, index] = match as unknown as [\n            string,\n            keyof typeof parent,\n            string,\n          ];\n          if ((parent[listKey] as t.Node[]).length > +index + 1) {\n            throw new TypeError(\n              `RestElement must be last element of ${listKey}`,\n            );\n          }\n        }\n      : undefined,\n});\n\ndefineType(\"ReturnStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"SequenceExpression\", {\n  visitor: [\"expressions\"],\n  fields: {\n    expressions: validateArrayOfType(\"Expression\"),\n  },\n  aliases: [\"Expression\"],\n});\n\ndefineType(\"ParenthesizedExpression\", {\n  visitor: [\"expression\"],\n  aliases: [\"Expression\", \"ExpressionWrapper\"],\n  fields: {\n    expression: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"SwitchCase\", {\n  visitor: [\"test\", \"consequent\"],\n  fields: {\n    test: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    consequent: validateArrayOfType(\"Statement\"),\n  },\n});\n\ndefineType(\"SwitchStatement\", {\n  visitor: [\"discriminant\", \"cases\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Scopable\"],\n  fields: {\n    discriminant: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    cases: validateArrayOfType(\"SwitchCase\"),\n  },\n});\n\ndefineType(\"ThisExpression\", {\n  aliases: [\"Expression\"],\n});\n\ndefineType(\"ThrowStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"TryStatement\", {\n  visitor: [\"block\", \"handler\", \"finalizer\"],\n  aliases: [\"Statement\"],\n  fields: {\n    block: {\n      validate:\n        process.env.BABEL_8_BREAKING || process.env.BABEL_TYPES_8_BREAKING\n          ? chain(\n              assertNodeType(\"BlockStatement\"),\n              Object.assign(\n                function (node: t.TryStatement) {\n                  // This validator isn't put at the top level because we can run it\n                  // even if this node doesn't have a parent.\n\n                  if (!node.handler && !node.finalizer) {\n                    throw new TypeError(\n                      \"TryStatement expects either a handler or finalizer, or both\",\n                    );\n                  }\n                } as Validator,\n                { oneOfNodeTypes: [\"BlockStatement\"] },\n              ),\n            )\n          : assertNodeType(\"BlockStatement\"),\n    },\n    handler: {\n      optional: true,\n      validate: assertNodeType(\"CatchClause\"),\n    },\n    finalizer: {\n      optional: true,\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n  },\n});\n\ndefineType(\"UnaryExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: true,\n    },\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    operator: {\n      validate: assertOneOf(...UNARY_OPERATORS),\n    },\n  },\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\", \"Expression\"],\n});\n\ndefineType(\"UpdateExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: false,\n    },\n    argument: {\n      validate:\n        !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n          ? assertNodeType(\"Expression\")\n          : assertNodeType(\"Identifier\", \"MemberExpression\"),\n    },\n    operator: {\n      validate: assertOneOf(...UPDATE_OPERATORS),\n    },\n  },\n  visitor: [\"argument\"],\n  aliases: [\"Expression\"],\n});\n\ndefineType(\"VariableDeclaration\", {\n  builder: [\"kind\", \"declarations\"],\n  visitor: [\"declarations\"],\n  aliases: [\"Statement\", \"Declaration\"],\n  fields: {\n    declare: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    kind: {\n      validate: assertOneOf(\n        \"var\",\n        \"let\",\n        \"const\",\n        // https://github.com/tc39/proposal-explicit-resource-management\n        \"using\",\n        // https://github.com/tc39/proposal-async-explicit-resource-management\n        \"await using\",\n      ),\n    },\n    declarations: validateArrayOfType(\"VariableDeclarator\"),\n  },\n  validate:\n    process.env.BABEL_8_BREAKING || process.env.BABEL_TYPES_8_BREAKING\n      ? (() => {\n          const withoutInit = assertNodeType(\"Identifier\");\n\n          return function (parent, key, node: t.VariableDeclaration) {\n            if (is(\"ForXStatement\", parent, { left: node })) {\n              if (node.declarations.length !== 1) {\n                throw new TypeError(\n                  `Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`,\n                );\n              }\n            } else {\n              node.declarations.forEach(decl => {\n                if (!decl.init) withoutInit(decl, \"id\", decl.id);\n              });\n            }\n          };\n        })()\n      : undefined,\n});\n\ndefineType(\"VariableDeclarator\", {\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: {\n      validate:\n        !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n          ? assertNodeType(\"LVal\")\n          : assertNodeType(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\"),\n    },\n    definite: {\n      optional: true,\n      validate: assertValueType(\"boolean\"),\n    },\n    init: {\n      optional: true,\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"WhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"],\n  fields: {\n    test: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\ndefineType(\"WithStatement\", {\n  visitor: [\"object\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    object: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\n// --- ES2015 ---\ndefineType(\"AssignmentPattern\", {\n  visitor: [\"left\", \"right\", \"decorators\" /* for legacy param decorators */],\n  builder: [\"left\", \"right\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: {\n    ...patternLikeCommon(),\n    left: {\n      validate: assertNodeType(\n        \"Identifier\",\n        \"ObjectPattern\",\n        \"ArrayPattern\",\n        \"MemberExpression\",\n        \"TSAsExpression\",\n        \"TSSatisfiesExpression\",\n        \"TSTypeAssertion\",\n        \"TSNonNullExpression\",\n      ),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    // For TypeScript\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ArrayPattern\", {\n  visitor: [\"elements\", \"typeAnnotation\"],\n  builder: [\"elements\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: {\n    ...patternLikeCommon(),\n    elements: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeOrValueType(\"null\", \"PatternLike\", \"LVal\")),\n      ),\n    },\n  },\n});\n\ndefineType(\"ArrowFunctionExpression\", {\n  builder: [\"params\", \"body\", \"async\"],\n  visitor: [\"typeParameters\", \"params\", \"returnType\", \"body\"],\n  aliases: [\n    \"Scopable\",\n    \"Function\",\n    \"BlockParent\",\n    \"FunctionParent\",\n    \"Expression\",\n    \"Pureish\",\n  ],\n  fields: {\n    ...functionCommon(),\n    ...functionTypeAnnotationCommon(),\n    expression: {\n      // https://github.com/babel/babylon/issues/505\n      validate: assertValueType(\"boolean\"),\n    },\n    body: {\n      validate: assertNodeType(\"BlockStatement\", \"Expression\"),\n    },\n    predicate: {\n      validate: assertNodeType(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ClassBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: validateArrayOfType(\n      \"ClassMethod\",\n      \"ClassPrivateMethod\",\n      \"ClassProperty\",\n      \"ClassPrivateProperty\",\n      \"ClassAccessorProperty\",\n      \"TSDeclareMethod\",\n      \"TSIndexSignature\",\n      \"StaticBlock\",\n    ),\n  },\n});\n\ndefineType(\"ClassExpression\", {\n  builder: [\"id\", \"superClass\", \"body\", \"decorators\"],\n  visitor: [\n    \"decorators\",\n    \"id\",\n    \"typeParameters\",\n    \"superClass\",\n    \"superTypeParameters\",\n    \"mixins\",\n    \"implements\",\n    \"body\",\n  ],\n  aliases: [\"Scopable\", \"Class\", \"Expression\"],\n  fields: {\n    id: {\n      validate: assertNodeType(\"Identifier\"),\n      optional: true,\n    },\n    typeParameters: {\n      validate: process.env.BABEL_8_BREAKING\n        ? assertNodeType(\n            \"TypeParameterDeclaration\",\n            \"TSTypeParameterDeclaration\",\n          )\n        : assertNodeType(\n            \"TypeParameterDeclaration\",\n            \"TSTypeParameterDeclaration\",\n            // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n            \"Noop\",\n          ),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"ClassBody\"),\n    },\n    superClass: {\n      optional: true,\n      validate: assertNodeType(\"Expression\"),\n    },\n    superTypeParameters: {\n      validate: assertNodeType(\n        \"TypeParameterInstantiation\",\n        \"TSTypeParameterInstantiation\",\n      ),\n      optional: true,\n    },\n    implements: {\n      validate: arrayOfType(\n        // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n        process.env.BABEL_8_BREAKING\n          ? \"TSClassImplements\"\n          : \"TSExpressionWithTypeArguments\",\n        \"ClassImplements\",\n      ),\n      optional: true,\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n    mixins: {\n      validate: assertNodeType(\"InterfaceExtends\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ClassDeclaration\", {\n  inherits: \"ClassExpression\",\n  aliases: [\"Scopable\", \"Class\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: {\n      validate: assertNodeType(\"Identifier\"),\n      // The id may be omitted if this is the child of an\n      // ExportDefaultDeclaration.\n      optional: true,\n    },\n    typeParameters: {\n      validate: process.env.BABEL_8_BREAKING\n        ? assertNodeType(\n            \"TypeParameterDeclaration\",\n            \"TSTypeParameterDeclaration\",\n          )\n        : assertNodeType(\n            \"TypeParameterDeclaration\",\n            \"TSTypeParameterDeclaration\",\n            // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n            \"Noop\",\n          ),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"ClassBody\"),\n    },\n    superClass: {\n      optional: true,\n      validate: assertNodeType(\"Expression\"),\n    },\n    superTypeParameters: {\n      validate: assertNodeType(\n        \"TypeParameterInstantiation\",\n        \"TSTypeParameterInstantiation\",\n      ),\n      optional: true,\n    },\n    implements: {\n      validate: arrayOfType(\n        // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n        process.env.BABEL_8_BREAKING\n          ? \"TSClassImplements\"\n          : \"TSExpressionWithTypeArguments\",\n        \"ClassImplements\",\n      ),\n      optional: true,\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n    mixins: {\n      validate: assertNodeType(\"InterfaceExtends\"),\n      optional: true,\n    },\n    declare: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    abstract: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n  },\n  validate:\n    !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n      ? undefined\n      : (function () {\n          const identifier = assertNodeType(\"Identifier\");\n          return function (parent, key, node) {\n            if (!is(\"ExportDefaultDeclaration\", parent)) {\n              identifier(node, \"id\", node.id);\n            }\n          };\n        })(),\n});\n\nexport const importAttributes = {\n  attributes: {\n    optional: true,\n    validate: arrayOfType(\"ImportAttribute\"),\n  },\n  assertions: {\n    deprecated: true,\n    optional: true,\n    validate: arrayOfType(\"ImportAttribute\"),\n  },\n};\n\ndefineType(\"ExportAllDeclaration\", {\n  builder: [\"source\"],\n  visitor: [\"source\", \"attributes\", \"assertions\"],\n  aliases: [\n    \"Statement\",\n    \"Declaration\",\n    \"ImportOrExportDeclaration\",\n    \"ExportDeclaration\",\n  ],\n  fields: {\n    source: {\n      validate: assertNodeType(\"StringLiteral\"),\n    },\n    exportKind: validateOptional(assertOneOf(\"type\", \"value\")),\n    ...importAttributes,\n  },\n});\n\ndefineType(\"ExportDefaultDeclaration\", {\n  visitor: [\"declaration\"],\n  aliases: [\n    \"Statement\",\n    \"Declaration\",\n    \"ImportOrExportDeclaration\",\n    \"ExportDeclaration\",\n  ],\n  fields: {\n    declaration: validateType(\n      \"TSDeclareFunction\",\n      \"FunctionDeclaration\",\n      \"ClassDeclaration\",\n      \"Expression\",\n    ),\n    exportKind: validateOptional(assertOneOf(\"value\")),\n  },\n});\n\ndefineType(\"ExportNamedDeclaration\", {\n  builder: [\"declaration\", \"specifiers\", \"source\"],\n  visitor: process.env\n    ? [\"declaration\", \"specifiers\", \"source\", \"attributes\"]\n    : [\"declaration\", \"specifiers\", \"source\", \"attributes\", \"assertions\"],\n  aliases: [\n    \"Statement\",\n    \"Declaration\",\n    \"ImportOrExportDeclaration\",\n    \"ExportDeclaration\",\n  ],\n  fields: {\n    declaration: {\n      optional: true,\n      validate:\n        process.env.BABEL_8_BREAKING || process.env.BABEL_TYPES_8_BREAKING\n          ? chain(\n              assertNodeType(\"Declaration\"),\n              Object.assign(\n                function (node: t.ExportNamedDeclaration, key, val) {\n                  // This validator isn't put at the top level because we can run it\n                  // even if this node doesn't have a parent.\n\n                  if (val && node.specifiers.length) {\n                    throw new TypeError(\n                      \"Only declaration or specifiers is allowed on ExportNamedDeclaration\",\n                    );\n                  }\n\n                  // This validator isn't put at the top level because we can run it\n                  // even if this node doesn't have a parent.\n\n                  if (val && node.source) {\n                    throw new TypeError(\n                      \"Cannot export a declaration from a source\",\n                    );\n                  }\n                } as Validator,\n                { oneOfNodeTypes: [\"Declaration\"] },\n              ),\n            )\n          : assertNodeType(\"Declaration\"),\n    },\n    ...importAttributes,\n    specifiers: {\n      default: [],\n      validate: arrayOf(\n        (function () {\n          const sourced = assertNodeType(\n            \"ExportSpecifier\",\n            \"ExportDefaultSpecifier\",\n            \"ExportNamespaceSpecifier\",\n          );\n          const sourceless = assertNodeType(\"ExportSpecifier\");\n\n          if (\n            !process.env.BABEL_8_BREAKING &&\n            !process.env.BABEL_TYPES_8_BREAKING\n          )\n            return sourced;\n\n          return Object.assign(\n            function (node: t.ExportNamedDeclaration, key, val) {\n              const validator = node.source ? sourced : sourceless;\n              validator(node, key, val);\n            } as Validator,\n            {\n              oneOfNodeTypes: [\n                \"ExportSpecifier\",\n                \"ExportDefaultSpecifier\",\n                \"ExportNamespaceSpecifier\",\n              ],\n            },\n          );\n        })(),\n      ),\n    },\n    source: {\n      validate: assertNodeType(\"StringLiteral\"),\n      optional: true,\n    },\n    exportKind: validateOptional(assertOneOf(\"type\", \"value\")),\n  },\n});\n\ndefineType(\"ExportSpecifier\", {\n  visitor: [\"local\", \"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n    exported: {\n      validate: assertNodeType(\"Identifier\", \"StringLiteral\"),\n    },\n    exportKind: {\n      // And TypeScript's \"export { type foo } from\"\n      validate: assertOneOf(\"type\", \"value\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ForOfStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  builder: [\"left\", \"right\", \"body\", \"await\"],\n  aliases: [\n    \"Scopable\",\n    \"Statement\",\n    \"For\",\n    \"BlockParent\",\n    \"Loop\",\n    \"ForXStatement\",\n  ],\n  fields: {\n    left: {\n      validate: (function () {\n        if (\n          !process.env.BABEL_8_BREAKING &&\n          !process.env.BABEL_TYPES_8_BREAKING\n        ) {\n          return assertNodeType(\"VariableDeclaration\", \"LVal\");\n        }\n\n        const declaration = assertNodeType(\"VariableDeclaration\");\n        const lval = assertNodeType(\n          \"Identifier\",\n          \"MemberExpression\",\n          \"ArrayPattern\",\n          \"ObjectPattern\",\n          \"TSAsExpression\",\n          \"TSSatisfiesExpression\",\n          \"TSTypeAssertion\",\n          \"TSNonNullExpression\",\n        );\n\n        return Object.assign(\n          function (node, key, val) {\n            if (is(\"VariableDeclaration\", val)) {\n              declaration(node, key, val);\n            } else {\n              lval(node, key, val);\n            }\n          } as Validator,\n          {\n            oneOfNodeTypes: [\n              \"VariableDeclaration\",\n              \"Identifier\",\n              \"MemberExpression\",\n              \"ArrayPattern\",\n              \"ObjectPattern\",\n              \"TSAsExpression\",\n              \"TSSatisfiesExpression\",\n              \"TSTypeAssertion\",\n              \"TSNonNullExpression\",\n            ],\n          },\n        );\n      })(),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n    await: {\n      default: false,\n    },\n  },\n});\n\ndefineType(\"ImportDeclaration\", {\n  builder: [\"specifiers\", \"source\"],\n  visitor: process.env.BABEL_8_BREAKING\n    ? [\"specifiers\", \"source\", \"attributes\"]\n    : [\"specifiers\", \"source\", \"attributes\", \"assertions\"],\n  aliases: [\"Statement\", \"Declaration\", \"ImportOrExportDeclaration\"],\n  fields: {\n    ...importAttributes,\n    module: {\n      optional: true,\n      validate: assertValueType(\"boolean\"),\n    },\n    phase: {\n      default: null,\n      validate: assertOneOf(\"source\", \"defer\"),\n    },\n    specifiers: validateArrayOfType(\n      \"ImportSpecifier\",\n      \"ImportDefaultSpecifier\",\n      \"ImportNamespaceSpecifier\",\n    ),\n    source: {\n      validate: assertNodeType(\"StringLiteral\"),\n    },\n    importKind: {\n      // Handle TypeScript/Flowtype's extension \"import type foo from\"\n      // TypeScript doesn't support typeof\n      validate: assertOneOf(\"type\", \"typeof\", \"value\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ImportDefaultSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\ndefineType(\"ImportNamespaceSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\ndefineType(\"ImportSpecifier\", {\n  visitor: [\"imported\", \"local\"],\n  builder: [\"local\", \"imported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n    imported: {\n      validate: assertNodeType(\"Identifier\", \"StringLiteral\"),\n    },\n    importKind: {\n      // Handle Flowtype's extension \"import {typeof foo} from\"\n      // And TypeScript's \"import { type foo } from\"\n      validate: assertOneOf(\"type\", \"typeof\", \"value\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ImportExpression\", {\n  visitor: [\"source\", \"options\"],\n  aliases: [\"Expression\"],\n  fields: {\n    phase: {\n      default: null,\n      validate: assertOneOf(\"source\", \"defer\"),\n    },\n    source: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    options: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"MetaProperty\", {\n  visitor: [\"meta\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    meta: {\n      validate:\n        process.env.BABEL_8_BREAKING || process.env.BABEL_TYPES_8_BREAKING\n          ? chain(\n              assertNodeType(\"Identifier\"),\n              Object.assign(\n                function (node: t.MetaProperty, key, val) {\n                  let property;\n                  switch (val.name) {\n                    case \"function\":\n                      property = \"sent\";\n                      break;\n                    case \"new\":\n                      property = \"target\";\n                      break;\n                    case \"import\":\n                      property = \"meta\";\n                      break;\n                  }\n                  if (!is(\"Identifier\", node.property, { name: property })) {\n                    throw new TypeError(\"Unrecognised MetaProperty\");\n                  }\n                } as Validator,\n                { oneOfNodeTypes: [\"Identifier\"] },\n              ),\n            )\n          : assertNodeType(\"Identifier\"),\n    },\n    property: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\nexport const classMethodOrPropertyCommon = () => ({\n  abstract: {\n    validate: assertValueType(\"boolean\"),\n    optional: true,\n  },\n  accessibility: {\n    validate: assertOneOf(\"public\", \"private\", \"protected\"),\n    optional: true,\n  },\n  static: {\n    default: false,\n  },\n  override: {\n    default: false,\n  },\n  computed: {\n    default: false,\n  },\n  optional: {\n    validate: assertValueType(\"boolean\"),\n    optional: true,\n  },\n  key: {\n    validate: chain(\n      (function () {\n        const normal = assertNodeType(\n          \"Identifier\",\n          \"StringLiteral\",\n          \"NumericLiteral\",\n          \"BigIntLiteral\",\n        );\n        const computed = assertNodeType(\"Expression\");\n\n        return function (node: any, key: string, val: any) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n      })(),\n      assertNodeType(\n        \"Identifier\",\n        \"StringLiteral\",\n        \"NumericLiteral\",\n        \"BigIntLiteral\",\n        \"Expression\",\n      ),\n    ),\n  },\n});\n\nexport const classMethodOrDeclareMethodCommon = () => ({\n  ...functionCommon(),\n  ...classMethodOrPropertyCommon(),\n  params: validateArrayOfType(\n    \"Identifier\",\n    \"Pattern\",\n    \"RestElement\",\n    \"TSParameterProperty\",\n  ),\n  kind: {\n    validate: assertOneOf(\"get\", \"set\", \"method\", \"constructor\"),\n    default: \"method\",\n  },\n  access: {\n    validate: chain(\n      assertValueType(\"string\"),\n      assertOneOf(\"public\", \"private\", \"protected\"),\n    ),\n    optional: true,\n  },\n  decorators: {\n    validate: arrayOfType(\"Decorator\"),\n    optional: true,\n  },\n});\n\ndefineType(\"ClassMethod\", {\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\"],\n  builder: [\n    \"kind\",\n    \"key\",\n    \"params\",\n    \"body\",\n    \"computed\",\n    \"static\",\n    \"generator\",\n    \"async\",\n  ],\n  visitor: [\n    \"decorators\",\n    \"key\",\n    \"typeParameters\",\n    \"params\",\n    \"returnType\",\n    \"body\",\n  ],\n  fields: {\n    ...classMethodOrDeclareMethodCommon(),\n    ...functionTypeAnnotationCommon(),\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n  },\n});\n\ndefineType(\"ObjectPattern\", {\n  visitor: [\n    \"properties\",\n    \"typeAnnotation\",\n    \"decorators\" /* for legacy param decorators */,\n  ],\n  builder: [\"properties\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: {\n    ...patternLikeCommon(),\n    properties: validateArrayOfType(\"RestElement\", \"ObjectProperty\"),\n  },\n});\n\ndefineType(\"SpreadElement\", {\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\"],\n  deprecatedAlias: \"SpreadProperty\",\n  fields: {\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\n  \"Super\",\n  process.env.BABEL_8_BREAKING\n    ? undefined\n    : {\n        aliases: [\"Expression\"],\n      },\n);\n\ndefineType(\"TaggedTemplateExpression\", {\n  visitor: [\"tag\", \"typeParameters\", \"quasi\"],\n  builder: [\"tag\", \"quasi\"],\n  aliases: [\"Expression\"],\n  fields: {\n    tag: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    quasi: {\n      validate: assertNodeType(\"TemplateLiteral\"),\n    },\n    typeParameters: {\n      validate: assertNodeType(\n        \"TypeParameterInstantiation\",\n        \"TSTypeParameterInstantiation\",\n      ),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"TemplateElement\", {\n  builder: [\"value\", \"tail\"],\n  fields: {\n    value: {\n      validate: chain(\n        assertShape({\n          raw: {\n            validate: assertValueType(\"string\"),\n          },\n          cooked: {\n            validate: assertValueType(\"string\"),\n            optional: true,\n          },\n        }),\n        function templateElementCookedValidator(node: t.TemplateElement) {\n          const raw = node.value.raw;\n\n          let unterminatedCalled = false;\n\n          const error = () => {\n            // unreachable\n            throw new Error(\"Internal @babel/types error.\");\n          };\n          const { str, firstInvalidLoc } = readStringContents(\n            \"template\",\n            raw,\n            0,\n            0,\n            0,\n            {\n              unterminated() {\n                unterminatedCalled = true;\n              },\n              strictNumericEscape: error,\n              invalidEscapeSequence: error,\n              numericSeparatorInEscapeSequence: error,\n              unexpectedNumericSeparator: error,\n              invalidDigit: error,\n              invalidCodePoint: error,\n            },\n          );\n          if (!unterminatedCalled) throw new Error(\"Invalid raw\");\n\n          node.value.cooked = firstInvalidLoc ? null : str;\n        },\n      ),\n    },\n    tail: {\n      default: false,\n    },\n  },\n});\n\ndefineType(\"TemplateLiteral\", {\n  visitor: [\"quasis\", \"expressions\"],\n  aliases: [\"Expression\", \"Literal\"],\n  fields: {\n    quasis: validateArrayOfType(\"TemplateElement\"),\n    expressions: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(\n          assertNodeType(\n            \"Expression\",\n            // For TypeScript template literal types\n            \"TSType\",\n          ),\n        ),\n        function (node: t.TemplateLiteral, key, val) {\n          if (node.quasis.length !== val.length + 1) {\n            throw new TypeError(\n              `Number of ${\n                node.type\n              } quasis should be exactly one more than the number of expressions.\\nExpected ${\n                val.length + 1\n              } quasis but got ${node.quasis.length}`,\n            );\n          }\n        } as Validator,\n      ),\n    },\n  },\n});\n\ndefineType(\"YieldExpression\", {\n  builder: [\"argument\", \"delegate\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    delegate: {\n      validate:\n        process.env.BABEL_8_BREAKING || process.env.BABEL_TYPES_8_BREAKING\n          ? chain(\n              assertValueType(\"boolean\"),\n              Object.assign(\n                function (node: t.YieldExpression, key, val) {\n                  if (val && !node.argument) {\n                    throw new TypeError(\n                      \"Property delegate of YieldExpression cannot be true if there is no argument\",\n                    );\n                  }\n                } as Validator,\n                { type: \"boolean\" },\n              ),\n            )\n          : assertValueType(\"boolean\"),\n      default: false,\n    },\n    argument: {\n      optional: true,\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\n// --- ES2017 ---\ndefineType(\"AwaitExpression\", {\n  builder: [\"argument\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\n// --- ES2019 ---\ndefineType(\"Import\", {\n  aliases: [\"Expression\"],\n});\n\n// --- ES2020 ---\ndefineType(\"BigIntLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: assertValueType(\"string\"),\n    },\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"],\n});\n\ndefineType(\"ExportNamespaceSpecifier\", {\n  visitor: [\"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    exported: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\ndefineType(\"OptionalMemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", \"optional\"],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    object: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    property: {\n      validate: (function () {\n        const normal = assertNodeType(\"Identifier\");\n        const computed = assertNodeType(\"Expression\");\n\n        const validator: Validator = Object.assign(\n          function (node: t.OptionalMemberExpression, key, val) {\n            const validator = node.computed ? computed : normal;\n            validator(node, key, val);\n          } as Validator,\n          // todo(ts): can be discriminated union by `computed` property\n          { oneOfNodeTypes: [\"Expression\", \"Identifier\"] },\n        );\n        return validator;\n      })(),\n    },\n    computed: {\n      default: false,\n    },\n    optional: {\n      validate:\n        !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n          ? assertValueType(\"boolean\")\n          : chain(assertValueType(\"boolean\"), assertOptionalChainStart()),\n    },\n  },\n});\n\ndefineType(\"OptionalCallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\", \"typeArguments\"],\n  builder: [\"callee\", \"arguments\", \"optional\"],\n  aliases: [\"Expression\"],\n  fields: {\n    callee: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    arguments: validateArrayOfType(\n      \"Expression\",\n      \"SpreadElement\",\n      \"ArgumentPlaceholder\",\n    ),\n    optional: {\n      validate:\n        !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n          ? assertValueType(\"boolean\")\n          : chain(assertValueType(\"boolean\"), assertOptionalChainStart()),\n    },\n    typeArguments: {\n      validate: assertNodeType(\"TypeParameterInstantiation\"),\n      optional: true,\n    },\n    typeParameters: {\n      validate: assertNodeType(\"TSTypeParameterInstantiation\"),\n      optional: true,\n    },\n  },\n});\n\n// --- ES2022 ---\ndefineType(\"ClassProperty\", {\n  visitor: [\"decorators\", \"key\", \"typeAnnotation\", \"value\"],\n  builder: [\n    \"key\",\n    \"value\",\n    \"typeAnnotation\",\n    \"decorators\",\n    \"computed\",\n    \"static\",\n  ],\n  aliases: [\"Property\"],\n  fields: {\n    ...classMethodOrPropertyCommon(),\n    value: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    definite: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    typeAnnotation: {\n      validate: process.env.BABEL_8_BREAKING\n        ? assertNodeType(\"TypeAnnotation\", \"TSTypeAnnotation\")\n        : assertNodeType(\n            \"TypeAnnotation\",\n            \"TSTypeAnnotation\",\n            // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n            \"Noop\",\n          ),\n      optional: true,\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n    readonly: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    declare: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    variance: {\n      validate: assertNodeType(\"Variance\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ClassAccessorProperty\", {\n  visitor: [\"decorators\", \"key\", \"typeAnnotation\", \"value\"],\n  builder: [\n    \"key\",\n    \"value\",\n    \"typeAnnotation\",\n    \"decorators\",\n    \"computed\",\n    \"static\",\n  ],\n  aliases: [\"Property\", \"Accessor\"],\n  fields: {\n    ...classMethodOrPropertyCommon(),\n    key: {\n      validate: chain(\n        (function () {\n          const normal = assertNodeType(\n            \"Identifier\",\n            \"StringLiteral\",\n            \"NumericLiteral\",\n            \"BigIntLiteral\",\n            \"PrivateName\",\n          );\n          const computed = assertNodeType(\"Expression\");\n\n          return function (node: any, key: string, val: any) {\n            const validator = node.computed ? computed : normal;\n            validator(node, key, val);\n          };\n        })(),\n        assertNodeType(\n          \"Identifier\",\n          \"StringLiteral\",\n          \"NumericLiteral\",\n          \"BigIntLiteral\",\n          \"Expression\",\n          \"PrivateName\",\n        ),\n      ),\n    },\n    value: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    definite: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    typeAnnotation: {\n      validate: process.env.BABEL_8_BREAKING\n        ? assertNodeType(\"TypeAnnotation\", \"TSTypeAnnotation\")\n        : assertNodeType(\n            \"TypeAnnotation\",\n            \"TSTypeAnnotation\",\n            // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n            \"Noop\",\n          ),\n      optional: true,\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n    readonly: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    declare: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    variance: {\n      validate: assertNodeType(\"Variance\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ClassPrivateProperty\", {\n  visitor: [\"decorators\", \"key\", \"typeAnnotation\", \"value\"],\n  builder: [\"key\", \"value\", \"decorators\", \"static\"],\n  aliases: [\"Property\", \"Private\"],\n  fields: {\n    key: {\n      validate: assertNodeType(\"PrivateName\"),\n    },\n    value: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    typeAnnotation: {\n      validate: process.env.BABEL_8_BREAKING\n        ? assertNodeType(\"TypeAnnotation\", \"TSTypeAnnotation\")\n        : assertNodeType(\n            \"TypeAnnotation\",\n            \"TSTypeAnnotation\",\n            // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n            \"Noop\",\n          ),\n      optional: true,\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n    static: {\n      validate: assertValueType(\"boolean\"),\n      default: false,\n    },\n    readonly: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    definite: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    variance: {\n      validate: assertNodeType(\"Variance\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ClassPrivateMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"static\"],\n  visitor: [\n    \"decorators\",\n    \"key\",\n    \"typeParameters\",\n    \"params\",\n    \"returnType\",\n    \"body\",\n  ],\n  aliases: [\n    \"Function\",\n    \"Scopable\",\n    \"BlockParent\",\n    \"FunctionParent\",\n    \"Method\",\n    \"Private\",\n  ],\n  fields: {\n    ...classMethodOrDeclareMethodCommon(),\n    ...functionTypeAnnotationCommon(),\n    kind: {\n      validate: assertOneOf(\"get\", \"set\", \"method\"),\n      default: \"method\",\n    },\n    key: {\n      validate: assertNodeType(\"PrivateName\"),\n    },\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n  },\n});\n\ndefineType(\"PrivateName\", {\n  visitor: [\"id\"],\n  aliases: [\"Private\"],\n  fields: {\n    id: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\ndefineType(\"StaticBlock\", {\n  visitor: [\"body\"],\n  fields: {\n    body: validateArrayOfType(\"Statement\"),\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"FunctionParent\"],\n});\n", "import { importAttributes } from \"./core.ts\";\nimport {\n  defineAliasedType,\n  arrayOfType,\n  assertOneOf,\n  assertValueType,\n  validate,\n  validateArrayOfType,\n  validateOptional,\n  validateOptionalType,\n  validateType,\n} from \"./utils.ts\";\n\nconst defineType = defineAliasedType(\"Flow\");\n\nconst defineInterfaceishType = (\n  name: \"DeclareClass\" | \"DeclareInterface\" | \"InterfaceDeclaration\",\n) => {\n  const isDeclareClass = name === \"DeclareClass\";\n\n  defineType(name, {\n    builder: [\"id\", \"typeParameters\", \"extends\", \"body\"],\n    visitor: [\n      \"id\",\n      \"typeParameters\",\n      \"extends\",\n      ...(isDeclareClass ? [\"mixins\", \"implements\"] : []),\n      \"body\",\n    ],\n    aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n    fields: {\n      id: validateType(\"Identifier\"),\n      typeParameters: validateOptionalType(\"TypeParameterDeclaration\"),\n      extends: validateOptional(arrayOfType(\"InterfaceExtends\")),\n      ...(isDeclareClass\n        ? {\n            mixins: validateOptional(arrayOfType(\"InterfaceExtends\")),\n            implements: validateOptional(arrayOfType(\"ClassImplements\")),\n          }\n        : {}),\n      body: validateType(\"ObjectTypeAnnotation\"),\n    },\n  });\n};\n\ndefineType(\"AnyTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"],\n});\n\ndefineType(\"ArrayTypeAnnotation\", {\n  visitor: [\"elementType\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    elementType: validateType(\"FlowType\"),\n  },\n});\n\ndefineType(\"BooleanTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"],\n});\n\ndefineType(\"BooleanLiteralTypeAnnotation\", {\n  builder: [\"value\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    value: validate(assertValueType(\"boolean\")),\n  },\n});\n\ndefineType(\"NullLiteralTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"],\n});\n\ndefineType(\"ClassImplements\", {\n  visitor: [\"id\", \"typeParameters\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    typeParameters: validateOptionalType(\"TypeParameterInstantiation\"),\n  },\n});\n\ndefineInterfaceishType(\"DeclareClass\");\n\ndefineType(\"DeclareFunction\", {\n  visitor: [\"id\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    predicate: validateOptionalType(\"DeclaredPredicate\"),\n  },\n});\n\ndefineInterfaceishType(\"DeclareInterface\");\n\ndefineType(\"DeclareModule\", {\n  builder: [\"id\", \"body\", \"kind\"],\n  visitor: [\"id\", \"body\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: validateType(\"Identifier\", \"StringLiteral\"),\n    body: validateType(\"BlockStatement\"),\n    kind: validateOptional(assertOneOf(\"CommonJS\", \"ES\")),\n  },\n});\n\ndefineType(\"DeclareModuleExports\", {\n  visitor: [\"typeAnnotation\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    typeAnnotation: validateType(\"TypeAnnotation\"),\n  },\n});\n\ndefineType(\"DeclareTypeAlias\", {\n  visitor: [\"id\", \"typeParameters\", \"right\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    typeParameters: validateOptionalType(\"TypeParameterDeclaration\"),\n    right: validateType(\"FlowType\"),\n  },\n});\n\ndefineType(\"DeclareOpaqueType\", {\n  visitor: [\"id\", \"typeParameters\", \"supertype\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    typeParameters: validateOptionalType(\"TypeParameterDeclaration\"),\n    supertype: validateOptionalType(\"FlowType\"),\n    impltype: validateOptionalType(\"FlowType\"),\n  },\n});\n\ndefineType(\"DeclareVariable\", {\n  visitor: [\"id\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n  },\n});\n\ndefineType(\"DeclareExportDeclaration\", {\n  visitor: [\"declaration\", \"specifiers\", \"source\", \"attributes\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    declaration: validateOptionalType(\"Flow\"),\n    specifiers: validateOptional(\n      arrayOfType(\"ExportSpecifier\", \"ExportNamespaceSpecifier\"),\n    ),\n    source: validateOptionalType(\"StringLiteral\"),\n    default: validateOptional(assertValueType(\"boolean\")),\n    ...importAttributes,\n  },\n});\n\ndefineType(\"DeclareExportAllDeclaration\", {\n  visitor: [\"source\", \"attributes\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    source: validateType(\"StringLiteral\"),\n    exportKind: validateOptional(assertOneOf(\"type\", \"value\")),\n    ...importAttributes,\n  },\n});\n\ndefineType(\"DeclaredPredicate\", {\n  visitor: [\"value\"],\n  aliases: [\"FlowPredicate\"],\n  fields: {\n    value: validateType(\"Flow\"),\n  },\n});\n\ndefineType(\"ExistsTypeAnnotation\", {\n  aliases: [\"FlowType\"],\n});\n\ndefineType(\"FunctionTypeAnnotation\", {\n  visitor: [\"typeParameters\", \"params\", \"rest\", \"returnType\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    typeParameters: validateOptionalType(\"TypeParameterDeclaration\"),\n    params: validateArrayOfType(\"FunctionTypeParam\"),\n    rest: validateOptionalType(\"FunctionTypeParam\"),\n    this: validateOptionalType(\"FunctionTypeParam\"),\n    returnType: validateType(\"FlowType\"),\n  },\n});\n\ndefineType(\"FunctionTypeParam\", {\n  visitor: [\"name\", \"typeAnnotation\"],\n  fields: {\n    name: validateOptionalType(\"Identifier\"),\n    typeAnnotation: validateType(\"FlowType\"),\n    optional: validateOptional(assertValueType(\"boolean\")),\n  },\n});\n\ndefineType(\"GenericTypeAnnotation\", {\n  visitor: [\"id\", \"typeParameters\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    id: validateType(\"Identifier\", \"QualifiedTypeIdentifier\"),\n    typeParameters: validateOptionalType(\"TypeParameterInstantiation\"),\n  },\n});\n\ndefineType(\"InferredPredicate\", {\n  aliases: [\"FlowPredicate\"],\n});\n\ndefineType(\"InterfaceExtends\", {\n  visitor: [\"id\", \"typeParameters\"],\n  fields: {\n    id: validateType(\"Identifier\", \"QualifiedTypeIdentifier\"),\n    typeParameters: validateOptionalType(\"TypeParameterInstantiation\"),\n  },\n});\n\ndefineInterfaceishType(\"InterfaceDeclaration\");\n\ndefineType(\"InterfaceTypeAnnotation\", {\n  visitor: [\"extends\", \"body\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    extends: validateOptional(arrayOfType(\"InterfaceExtends\")),\n    body: validateType(\"ObjectTypeAnnotation\"),\n  },\n});\n\ndefineType(\"IntersectionTypeAnnotation\", {\n  visitor: [\"types\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    types: validate(arrayOfType(\"FlowType\")),\n  },\n});\n\ndefineType(\"MixedTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"],\n});\n\ndefineType(\"EmptyTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"],\n});\n\ndefineType(\"NullableTypeAnnotation\", {\n  visitor: [\"typeAnnotation\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    typeAnnotation: validateType(\"FlowType\"),\n  },\n});\n\ndefineType(\"NumberLiteralTypeAnnotation\", {\n  builder: [\"value\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    value: validate(assertValueType(\"number\")),\n  },\n});\n\ndefineType(\"NumberTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"],\n});\n\ndefineType(\"ObjectTypeAnnotation\", {\n  visitor: [\"properties\", \"indexers\", \"callProperties\", \"internalSlots\"],\n  aliases: [\"FlowType\"],\n  builder: [\n    \"properties\",\n    \"indexers\",\n    \"callProperties\",\n    \"internalSlots\",\n    \"exact\",\n  ],\n  fields: {\n    properties: validate(\n      arrayOfType(\"ObjectTypeProperty\", \"ObjectTypeSpreadProperty\"),\n    ),\n    indexers: {\n      validate: arrayOfType(\"ObjectTypeIndexer\"),\n      optional: process.env.BABEL_8_BREAKING ? false : true,\n      default: [],\n    },\n    callProperties: {\n      validate: arrayOfType(\"ObjectTypeCallProperty\"),\n      optional: process.env.BABEL_8_BREAKING ? false : true,\n      default: [],\n    },\n    internalSlots: {\n      validate: arrayOfType(\"ObjectTypeInternalSlot\"),\n      optional: process.env.BABEL_8_BREAKING ? false : true,\n      default: [],\n    },\n    exact: {\n      validate: assertValueType(\"boolean\"),\n      default: false,\n    },\n    // If the inexact flag is present then this is an object type, and not a\n    // declare class, declare interface, or interface. If it is true, the\n    // object uses ... to express that it is inexact.\n    inexact: validateOptional(assertValueType(\"boolean\")),\n  },\n});\n\ndefineType(\"ObjectTypeInternalSlot\", {\n  visitor: [\"id\", \"value\"],\n  builder: [\"id\", \"value\", \"optional\", \"static\", \"method\"],\n  aliases: [\"UserWhitespacable\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    value: validateType(\"FlowType\"),\n    optional: validate(assertValueType(\"boolean\")),\n    static: validate(assertValueType(\"boolean\")),\n    method: validate(assertValueType(\"boolean\")),\n  },\n});\n\ndefineType(\"ObjectTypeCallProperty\", {\n  visitor: [\"value\"],\n  aliases: [\"UserWhitespacable\"],\n  fields: {\n    value: validateType(\"FlowType\"),\n    static: validate(assertValueType(\"boolean\")),\n  },\n});\n\ndefineType(\"ObjectTypeIndexer\", {\n  visitor: [\"variance\", \"id\", \"key\", \"value\"],\n  builder: [\"id\", \"key\", \"value\", \"variance\"],\n  aliases: [\"UserWhitespacable\"],\n  fields: {\n    id: validateOptionalType(\"Identifier\"),\n    key: validateType(\"FlowType\"),\n    value: validateType(\"FlowType\"),\n    static: validate(assertValueType(\"boolean\")),\n    variance: validateOptionalType(\"Variance\"),\n  },\n});\n\ndefineType(\"ObjectTypeProperty\", {\n  visitor: [\"key\", \"value\", \"variance\"],\n  aliases: [\"UserWhitespacable\"],\n  fields: {\n    key: validateType(\"Identifier\", \"StringLiteral\"),\n    value: validateType(\"FlowType\"),\n    kind: validate(assertOneOf(\"init\", \"get\", \"set\")),\n    static: validate(assertValueType(\"boolean\")),\n    proto: validate(assertValueType(\"boolean\")),\n    optional: validate(assertValueType(\"boolean\")),\n    variance: validateOptionalType(\"Variance\"),\n    method: validate(assertValueType(\"boolean\")),\n  },\n});\n\ndefineType(\"ObjectTypeSpreadProperty\", {\n  visitor: [\"argument\"],\n  aliases: [\"UserWhitespacable\"],\n  fields: {\n    argument: validateType(\"FlowType\"),\n  },\n});\n\ndefineType(\"OpaqueType\", {\n  visitor: [\"id\", \"typeParameters\", \"supertype\", \"impltype\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    typeParameters: validateOptionalType(\"TypeParameterDeclaration\"),\n    supertype: validateOptionalType(\"FlowType\"),\n    impltype: validateType(\"FlowType\"),\n  },\n});\n\ndefineType(\"QualifiedTypeIdentifier\", {\n  visitor: [\"qualification\", \"id\"],\n  builder: [\"id\", \"qualification\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    qualification: validateType(\"Identifier\", \"QualifiedTypeIdentifier\"),\n  },\n});\n\ndefineType(\"StringLiteralTypeAnnotation\", {\n  builder: [\"value\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    value: validate(assertValueType(\"string\")),\n  },\n});\n\ndefineType(\"StringTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"],\n});\n\ndefineType(\"SymbolTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"],\n});\n\ndefineType(\"ThisTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"],\n});\n\ndefineType(\"TupleTypeAnnotation\", {\n  visitor: [\"types\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    types: validate(arrayOfType(\"FlowType\")),\n  },\n});\n\ndefineType(\"TypeofTypeAnnotation\", {\n  visitor: [\"argument\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    argument: validateType(\"FlowType\"),\n  },\n});\n\ndefineType(\"TypeAlias\", {\n  visitor: [\"id\", \"typeParameters\", \"right\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    typeParameters: validateOptionalType(\"TypeParameterDeclaration\"),\n    right: validateType(\"FlowType\"),\n  },\n});\n\ndefineType(\"TypeAnnotation\", {\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: validateType(\"FlowType\"),\n  },\n});\n\ndefineType(\"TypeCastExpression\", {\n  visitor: [\"expression\", \"typeAnnotation\"],\n  aliases: [\"ExpressionWrapper\", \"Expression\"],\n  fields: {\n    expression: validateType(\"Expression\"),\n    typeAnnotation: validateType(\"TypeAnnotation\"),\n  },\n});\n\ndefineType(\"TypeParameter\", {\n  visitor: [\"bound\", \"default\", \"variance\"],\n  fields: {\n    name: validate(assertValueType(\"string\")),\n    bound: validateOptionalType(\"TypeAnnotation\"),\n    default: validateOptionalType(\"FlowType\"),\n    variance: validateOptionalType(\"Variance\"),\n  },\n});\n\ndefineType(\"TypeParameterDeclaration\", {\n  visitor: [\"params\"],\n  fields: {\n    params: validate(arrayOfType(\"TypeParameter\")),\n  },\n});\n\ndefineType(\"TypeParameterInstantiation\", {\n  visitor: [\"params\"],\n  fields: {\n    params: validate(arrayOfType(\"FlowType\")),\n  },\n});\n\ndefineType(\"UnionTypeAnnotation\", {\n  visitor: [\"types\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    types: validate(arrayOfType(\"FlowType\")),\n  },\n});\n\ndefineType(\"Variance\", {\n  builder: [\"kind\"],\n  fields: {\n    kind: validate(assertOneOf(\"minus\", \"plus\")),\n  },\n});\n\ndefineType(\"VoidTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"],\n});\n\n// Enums\ndefineType(\"EnumDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"body\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    body: validateType(\n      \"EnumBooleanBody\",\n      \"EnumNumberBody\",\n      \"EnumStringBody\",\n      \"EnumSymbolBody\",\n    ),\n  },\n});\n\ndefineType(\"EnumBooleanBody\", {\n  aliases: [\"EnumBody\"],\n  visitor: [\"members\"],\n  fields: {\n    explicitType: validate(assertValueType(\"boolean\")),\n    members: validateArrayOfType(\"EnumBooleanMember\"),\n    hasUnknownMembers: validate(assertValueType(\"boolean\")),\n  },\n});\n\ndefineType(\"EnumNumberBody\", {\n  aliases: [\"EnumBody\"],\n  visitor: [\"members\"],\n  fields: {\n    explicitType: validate(assertValueType(\"boolean\")),\n    members: validateArrayOfType(\"EnumNumberMember\"),\n    hasUnknownMembers: validate(assertValueType(\"boolean\")),\n  },\n});\n\ndefineType(\"EnumStringBody\", {\n  aliases: [\"EnumBody\"],\n  visitor: [\"members\"],\n  fields: {\n    explicitType: validate(assertValueType(\"boolean\")),\n    members: validateArrayOfType(\"EnumStringMember\", \"EnumDefaultedMember\"),\n    hasUnknownMembers: validate(assertValueType(\"boolean\")),\n  },\n});\n\ndefineType(\"EnumSymbolBody\", {\n  aliases: [\"EnumBody\"],\n  visitor: [\"members\"],\n  fields: {\n    members: validateArrayOfType(\"EnumDefaultedMember\"),\n    hasUnknownMembers: validate(assertValueType(\"boolean\")),\n  },\n});\n\ndefineType(\"EnumBooleanMember\", {\n  aliases: [\"EnumMember\"],\n  visitor: [\"id\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    init: validateType(\"BooleanLiteral\"),\n  },\n});\n\ndefineType(\"EnumNumberMember\", {\n  aliases: [\"EnumMember\"],\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    init: validateType(\"NumericLiteral\"),\n  },\n});\n\ndefineType(\"EnumStringMember\", {\n  aliases: [\"EnumMember\"],\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    init: validateType(\"StringLiteral\"),\n  },\n});\n\ndefineType(\"EnumDefaultedMember\", {\n  aliases: [\"EnumMember\"],\n  visitor: [\"id\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n  },\n});\n\ndefineType(\"IndexedAccessType\", {\n  visitor: [\"objectType\", \"indexType\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    objectType: validateType(\"FlowType\"),\n    indexType: validateType(\"FlowType\"),\n  },\n});\n\ndefineType(\"OptionalIndexedAccessType\", {\n  visitor: [\"objectType\", \"indexType\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    objectType: validateType(\"FlowType\"),\n    indexType: validateType(\"FlowType\"),\n    optional: validate(assertValueType(\"boolean\")),\n  },\n});\n", "import {\n  defineAliasedType,\n  assertNodeType,\n  assertValueType,\n  validateArrayOfType,\n} from \"./utils.ts\";\n\nconst defineType = defineAliasedType(\"JSX\");\n\ndefineType(\"JSXAttribute\", {\n  visitor: [\"name\", \"value\"],\n  aliases: [\"Immutable\"],\n  fields: {\n    name: {\n      validate: assertNodeType(\"JSXIdentifier\", \"JSXNamespacedName\"),\n    },\n    value: {\n      optional: true,\n      validate: assertNodeType(\n        \"JSXElement\",\n        \"JSXFragment\",\n        \"StringLiteral\",\n        \"JSXExpressionContainer\",\n      ),\n    },\n  },\n});\n\ndefineType(\"JSXClosingElement\", {\n  visitor: [\"name\"],\n  aliases: [\"Immutable\"],\n  fields: {\n    name: {\n      validate: assertNodeType(\n        \"JSXIdentifier\",\n        \"JSXMemberExpression\",\n        \"JSXNamespacedName\",\n      ),\n    },\n  },\n});\n\ndefineType(\"JSXElement\", {\n  builder: process.env.BABEL_8_BREAKING\n    ? [\"openingElement\", \"closingElement\", \"children\"]\n    : [\"openingElement\", \"closingElement\", \"children\", \"selfClosing\"],\n  visitor: [\"openingElement\", \"children\", \"closingElement\"],\n  aliases: [\"Immutable\", \"Expression\"],\n  fields: {\n    openingElement: {\n      validate: assertNodeType(\"JSXOpeningElement\"),\n    },\n    closingElement: {\n      optional: true,\n      validate: assertNodeType(\"JSXClosingElement\"),\n    },\n    children: validateArrayOfType(\n      \"JSXText\",\n      \"JSXExpressionContainer\",\n      \"JSXSpreadChild\",\n      \"JSXElement\",\n      \"JSXFragment\",\n    ),\n    ...(process.env.BABEL_8_BREAKING\n      ? {}\n      : {\n          selfClosing: {\n            validate: assertValueType(\"boolean\"),\n            optional: true,\n          },\n        }),\n  },\n});\n\ndefineType(\"JSXEmptyExpression\", {});\n\ndefineType(\"JSXExpressionContainer\", {\n  visitor: [\"expression\"],\n  aliases: [\"Immutable\"],\n  fields: {\n    expression: {\n      validate: assertNodeType(\"Expression\", \"JSXEmptyExpression\"),\n    },\n  },\n});\n\ndefineType(\"JSXSpreadChild\", {\n  visitor: [\"expression\"],\n  aliases: [\"Immutable\"],\n  fields: {\n    expression: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"JSXIdentifier\", {\n  builder: [\"name\"],\n  fields: {\n    name: {\n      validate: assertValueType(\"string\"),\n    },\n  },\n});\n\ndefineType(\"JSXMemberExpression\", {\n  visitor: [\"object\", \"property\"],\n  fields: {\n    object: {\n      validate: assertNodeType(\"JSXMemberExpression\", \"JSXIdentifier\"),\n    },\n    property: {\n      validate: assertNodeType(\"JSXIdentifier\"),\n    },\n  },\n});\n\ndefineType(\"JSXNamespacedName\", {\n  visitor: [\"namespace\", \"name\"],\n  fields: {\n    namespace: {\n      validate: assertNodeType(\"JSXIdentifier\"),\n    },\n    name: {\n      validate: assertNodeType(\"JSXIdentifier\"),\n    },\n  },\n});\n\ndefineType(\"JSXOpeningElement\", {\n  builder: [\"name\", \"attributes\", \"selfClosing\"],\n  visitor: [\"name\", \"attributes\"],\n  aliases: [\"Immutable\"],\n  fields: {\n    name: {\n      validate: assertNodeType(\n        \"JSXIdentifier\",\n        \"JSXMemberExpression\",\n        \"JSXNamespacedName\",\n      ),\n    },\n    selfClosing: {\n      default: false,\n    },\n    attributes: validateArrayOfType(\"JSXAttribute\", \"JSXSpreadAttribute\"),\n    typeParameters: {\n      validate: assertNodeType(\n        \"TypeParameterInstantiation\",\n        \"TSTypeParameterInstantiation\",\n      ),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"JSXSpreadAttribute\", {\n  visitor: [\"argument\"],\n  fields: {\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"JSXText\", {\n  aliases: [\"Immutable\"],\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: assertValueType(\"string\"),\n    },\n  },\n});\n\ndefineType(\"JSXFragment\", {\n  builder: [\"openingFragment\", \"closingFragment\", \"children\"],\n  visitor: [\"openingFragment\", \"children\", \"closingFragment\"],\n  aliases: [\"Immutable\", \"Expression\"],\n  fields: {\n    openingFragment: {\n      validate: assertNodeType(\"JSXOpeningFragment\"),\n    },\n    closingFragment: {\n      validate: assertNodeType(\"JSXClosingFragment\"),\n    },\n    children: validateArrayOfType(\n      \"JSXText\",\n      \"JSXExpressionContainer\",\n      \"JSXSpreadChild\",\n      \"JSXElement\",\n      \"JSXFragment\",\n    ),\n  },\n});\n\ndefineType(\"JSXOpeningFragment\", {\n  aliases: [\"Immutable\"],\n});\n\ndefineType(\"JSXClosingFragment\", {\n  aliases: [\"Immutable\"],\n});\n", "import { ALIAS_KEYS } from \"./utils.ts\";\n\nexport const PLACEHOLDERS = [\n  \"Identifier\",\n  \"StringLiteral\",\n  \"Expression\",\n  \"Statement\",\n  \"Declaration\",\n  \"BlockStatement\",\n  \"ClassBody\",\n  \"Pattern\",\n] as const;\n\nexport const PLACEHOLDERS_ALIAS: Record<string, string[]> = {\n  Declaration: [\"Statement\"],\n  Pattern: [\"PatternLike\", \"LVal\"],\n};\n\nfor (const type of PLACEHOLDERS) {\n  const alias = ALIAS_KEYS[type];\n  if (alias?.length) PLACEHOLDERS_ALIAS[type] = alias;\n}\n\nexport const PLACEHOLDERS_FLIPPED_ALIAS: Record<string, string[]> = {};\n\nObject.keys(PLACEHOLDERS_ALIAS).forEach(type => {\n  PLACEHOLDERS_ALIAS[type].forEach(alias => {\n    if (!Object.hasOwn(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {\n      PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];\n    }\n    PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);\n  });\n});\n", "import {\n  defineAliasedType,\n  assertNodeType,\n  assertOneOf,\n  assertValueType,\n} from \"./utils.ts\";\nimport { PLACEHOLDERS } from \"./placeholders.ts\";\nimport { patternLikeCommon } from \"./core.ts\";\n\nconst defineType = defineAliasedType(\"Miscellaneous\");\n\nif (!process.env.BABEL_8_BREAKING) {\n  defineType(\"Noop\", {\n    visitor: [],\n  });\n}\n\ndefineType(\"Placeholder\", {\n  visitor: [],\n  builder: [\"expectedNode\", \"name\"],\n  // aliases: [], defined in placeholders.js\n  fields: {\n    name: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n    expectedNode: {\n      validate: assertOneOf(...PLACEHOLDERS),\n    },\n    ...patternLikeCommon(),\n  },\n});\n\ndefineType(\"V8IntrinsicIdentifier\", {\n  builder: [\"name\"],\n  fields: {\n    name: {\n      validate: assertValueType(\"string\"),\n    },\n  },\n});\n", "import defineType, {\n  arrayOfType,\n  assertNodeType,\n  assertValueType,\n  validateArrayOfType,\n} from \"./utils.ts\";\n\ndefineType(\"ArgumentPlaceholder\", {});\n\ndefineType(\"BindExpression\", {\n  visitor: [\"object\", \"callee\"],\n  aliases: [\"Expression\"],\n  fields:\n    !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n      ? {\n          object: {\n            validate: Object.assign(() => {}, {\n              oneOfNodeTypes: [\"Expression\"],\n            }),\n          },\n          callee: {\n            validate: Object.assign(() => {}, {\n              oneOfNodeTypes: [\"Expression\"],\n            }),\n          },\n        }\n      : {\n          object: {\n            validate: assertNodeType(\"Expression\"),\n          },\n          callee: {\n            validate: assertNodeType(\"Expression\"),\n          },\n        },\n});\n\ndefineType(\"ImportAttribute\", {\n  visitor: [\"key\", \"value\"],\n  fields: {\n    key: {\n      validate: assertNodeType(\"Identifier\", \"StringLiteral\"),\n    },\n    value: {\n      validate: assertNodeType(\"StringLiteral\"),\n    },\n  },\n});\n\ndefineType(\"Decorator\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"DoExpression\", {\n  visitor: [\"body\"],\n  builder: [\"body\", \"async\"],\n  aliases: [\"Expression\"],\n  fields: {\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n    async: {\n      validate: assertValueType(\"boolean\"),\n      default: false,\n    },\n  },\n});\n\ndefineType(\"ExportDefaultSpecifier\", {\n  visitor: [\"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    exported: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\ndefineType(\"RecordExpression\", {\n  visitor: [\"properties\"],\n  aliases: [\"Expression\"],\n  fields: {\n    properties: validateArrayOfType(\"ObjectProperty\", \"SpreadElement\"),\n  },\n});\n\ndefineType(\"TupleExpression\", {\n  fields: {\n    elements: {\n      validate: arrayOfType(\"Expression\", \"SpreadElement\"),\n      default: [],\n    },\n  },\n  visitor: [\"elements\"],\n  aliases: [\"Expression\"],\n});\n\nif (!process.env.BABEL_8_BREAKING) {\n  defineType(\"DecimalLiteral\", {\n    builder: [\"value\"],\n    fields: {\n      value: {\n        validate: assertValueType(\"string\"),\n      },\n    },\n    aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"],\n  });\n}\n\n// https://github.com/tc39/proposal-js-module-blocks\ndefineType(\"ModuleExpression\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: assertNodeType(\"Program\"),\n    },\n  },\n  aliases: [\"Expression\"],\n});\n\n// https://github.com/tc39/proposal-pipeline-operator\n// https://github.com/js-choi/proposal-hack-pipes\ndefineType(\"TopicReference\", {\n  aliases: [\"Expression\"],\n});\n\n// https://github.com/tc39/proposal-pipeline-operator\n// https://github.com/js-choi/proposal-smart-pipes\ndefineType(\"PipelineTopicExpression\", {\n  builder: [\"expression\"],\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n  aliases: [\"Expression\"],\n});\n\ndefineType(\"PipelineBareFunction\", {\n  builder: [\"callee\"],\n  visitor: [\"callee\"],\n  fields: {\n    callee: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n  aliases: [\"Expression\"],\n});\n\ndefineType(\"PipelinePrimaryTopicReference\", {\n  aliases: [\"Expression\"],\n});\n", "import {\n  defineAliasedType,\n  arrayOfType,\n  assertNodeType,\n  assertOneOf,\n  assertValueType,\n  validate,\n  validateArrayOfType,\n  validateOptional,\n  validateOptionalType,\n  validateType,\n} from \"./utils.ts\";\nimport {\n  functionDeclarationCommon,\n  classMethodOrDeclareMethodCommon,\n} from \"./core.ts\";\nimport is from \"../validators/is.ts\";\n\nconst defineType = defineAliasedType(\"TypeScript\");\n\nconst bool = assertValueType(\"boolean\");\n\nconst tSFunctionTypeAnnotationCommon = () => ({\n  returnType: {\n    validate: process.env.BABEL_8_BREAKING\n      ? assertNodeType(\"TSTypeAnnotation\")\n      : // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n        assertNodeType(\"TSTypeAnnotation\", \"Noop\"),\n    optional: true,\n  },\n  typeParameters: {\n    validate: process.env.BABEL_8_BREAKING\n      ? assertNodeType(\"TSTypeParameterDeclaration\")\n      : // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n        assertNodeType(\"TSTypeParameterDeclaration\", \"Noop\"),\n    optional: true,\n  },\n});\n\ndefineType(\"TSParameterProperty\", {\n  aliases: [\"LVal\"], // TODO: This isn't usable in general as an LVal. Should have a \"Parameter\" alias.\n  visitor: [\"parameter\"],\n  fields: {\n    accessibility: {\n      validate: assertOneOf(\"public\", \"private\", \"protected\"),\n      optional: true,\n    },\n    readonly: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    parameter: {\n      validate: assertNodeType(\"Identifier\", \"AssignmentPattern\"),\n    },\n    override: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"TSDeclareFunction\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"typeParameters\", \"params\", \"returnType\"],\n  fields: {\n    ...functionDeclarationCommon(),\n    ...tSFunctionTypeAnnotationCommon(),\n  },\n});\n\ndefineType(\"TSDeclareMethod\", {\n  visitor: [\"decorators\", \"key\", \"typeParameters\", \"params\", \"returnType\"],\n  fields: {\n    ...classMethodOrDeclareMethodCommon(),\n    ...tSFunctionTypeAnnotationCommon(),\n  },\n});\n\ndefineType(\"TSQualifiedName\", {\n  aliases: [\"TSEntityName\"],\n  visitor: [\"left\", \"right\"],\n  fields: {\n    left: validateType(\"TSEntityName\"),\n    right: validateType(\"Identifier\"),\n  },\n});\n\nconst signatureDeclarationCommon = () => ({\n  typeParameters: validateOptionalType(\"TSTypeParameterDeclaration\"),\n  [process.env.BABEL_8_BREAKING ? \"params\" : \"parameters\"]: validateArrayOfType(\n    \"ArrayPattern\",\n    \"Identifier\",\n    \"ObjectPattern\",\n    \"RestElement\",\n  ),\n  [process.env.BABEL_8_BREAKING ? \"returnType\" : \"typeAnnotation\"]:\n    validateOptionalType(\"TSTypeAnnotation\"),\n});\n\nconst callConstructSignatureDeclaration = {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\n    \"typeParameters\",\n    process.env.BABEL_8_BREAKING ? \"params\" : \"parameters\",\n    process.env.BABEL_8_BREAKING ? \"returnType\" : \"typeAnnotation\",\n  ],\n  fields: signatureDeclarationCommon(),\n};\n\ndefineType(\"TSCallSignatureDeclaration\", callConstructSignatureDeclaration);\ndefineType(\n  \"TSConstructSignatureDeclaration\",\n  callConstructSignatureDeclaration,\n);\n\nconst namedTypeElementCommon = () => ({\n  key: validateType(\"Expression\"),\n  computed: { default: false },\n  optional: validateOptional(bool),\n});\n\ndefineType(\"TSPropertySignature\", {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"key\", \"typeAnnotation\"],\n  fields: {\n    ...namedTypeElementCommon(),\n    readonly: validateOptional(bool),\n    typeAnnotation: validateOptionalType(\"TSTypeAnnotation\"),\n    kind: {\n      validate: assertOneOf(\"get\", \"set\"),\n    },\n  },\n});\n\ndefineType(\"TSMethodSignature\", {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\n    \"key\",\n    \"typeParameters\",\n    process.env.BABEL_8_BREAKING ? \"params\" : \"parameters\",\n    process.env.BABEL_8_BREAKING ? \"returnType\" : \"typeAnnotation\",\n  ],\n  fields: {\n    ...signatureDeclarationCommon(),\n    ...namedTypeElementCommon(),\n    kind: {\n      validate: assertOneOf(\"method\", \"get\", \"set\"),\n    },\n  },\n});\n\ndefineType(\"TSIndexSignature\", {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"parameters\", \"typeAnnotation\"],\n  fields: {\n    readonly: validateOptional(bool),\n    static: validateOptional(bool),\n    parameters: validateArrayOfType(\"Identifier\"), // Length must be 1\n    typeAnnotation: validateOptionalType(\"TSTypeAnnotation\"),\n  },\n});\n\nconst tsKeywordTypes = [\n  \"TSAnyKeyword\",\n  \"TSBooleanKeyword\",\n  \"TSBigIntKeyword\",\n  \"TSIntrinsicKeyword\",\n  \"TSNeverKeyword\",\n  \"TSNullKeyword\",\n  \"TSNumberKeyword\",\n  \"TSObjectKeyword\",\n  \"TSStringKeyword\",\n  \"TSSymbolKeyword\",\n  \"TSUndefinedKeyword\",\n  \"TSUnknownKeyword\",\n  \"TSVoidKeyword\",\n] as const;\n\nfor (const type of tsKeywordTypes) {\n  defineType(type, {\n    aliases: [\"TSType\", \"TSBaseType\"],\n    visitor: [],\n    fields: {},\n  });\n}\n\ndefineType(\"TSThisType\", {\n  aliases: [\"TSType\", \"TSBaseType\"],\n  visitor: [],\n  fields: {},\n});\n\nconst fnOrCtrBase = {\n  aliases: [\"TSType\"],\n  visitor: [\n    \"typeParameters\",\n    process.env.BABEL_8_BREAKING ? \"params\" : \"parameters\",\n    process.env.BABEL_8_BREAKING ? \"returnType\" : \"typeAnnotation\",\n  ],\n};\n\ndefineType(\"TSFunctionType\", {\n  ...fnOrCtrBase,\n  fields: signatureDeclarationCommon(),\n});\ndefineType(\"TSConstructorType\", {\n  ...fnOrCtrBase,\n  fields: {\n    ...signatureDeclarationCommon(),\n    abstract: validateOptional(bool),\n  },\n});\n\ndefineType(\"TSTypeReference\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeName\", \"typeParameters\"],\n  fields: {\n    typeName: validateType(\"TSEntityName\"),\n    typeParameters: validateOptionalType(\"TSTypeParameterInstantiation\"),\n  },\n});\n\ndefineType(\"TSTypePredicate\", {\n  aliases: [\"TSType\"],\n  visitor: [\"parameterName\", \"typeAnnotation\"],\n  builder: [\"parameterName\", \"typeAnnotation\", \"asserts\"],\n  fields: {\n    parameterName: validateType(\"Identifier\", \"TSThisType\"),\n    typeAnnotation: validateOptionalType(\"TSTypeAnnotation\"),\n    asserts: validateOptional(bool),\n  },\n});\n\ndefineType(\"TSTypeQuery\", {\n  aliases: [\"TSType\"],\n  visitor: [\"exprName\", \"typeParameters\"],\n  fields: {\n    exprName: validateType(\"TSEntityName\", \"TSImportType\"),\n    typeParameters: validateOptionalType(\"TSTypeParameterInstantiation\"),\n  },\n});\n\ndefineType(\"TSTypeLiteral\", {\n  aliases: [\"TSType\"],\n  visitor: [\"members\"],\n  fields: {\n    members: validateArrayOfType(\"TSTypeElement\"),\n  },\n});\n\ndefineType(\"TSArrayType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"elementType\"],\n  fields: {\n    elementType: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSTupleType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"elementTypes\"],\n  fields: {\n    elementTypes: validateArrayOfType(\"TSType\", \"TSNamedTupleMember\"),\n  },\n});\n\ndefineType(\"TSOptionalType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSRestType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSNamedTupleMember\", {\n  visitor: [\"label\", \"elementType\"],\n  builder: [\"label\", \"elementType\", \"optional\"],\n  fields: {\n    label: validateType(\"Identifier\"),\n    optional: {\n      validate: bool,\n      default: false,\n    },\n    elementType: validateType(\"TSType\"),\n  },\n});\n\nconst unionOrIntersection = {\n  aliases: [\"TSType\"],\n  visitor: [\"types\"],\n  fields: {\n    types: validateArrayOfType(\"TSType\"),\n  },\n};\n\ndefineType(\"TSUnionType\", unionOrIntersection);\ndefineType(\"TSIntersectionType\", unionOrIntersection);\n\ndefineType(\"TSConditionalType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"checkType\", \"extendsType\", \"trueType\", \"falseType\"],\n  fields: {\n    checkType: validateType(\"TSType\"),\n    extendsType: validateType(\"TSType\"),\n    trueType: validateType(\"TSType\"),\n    falseType: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSInferType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeParameter\"],\n  fields: {\n    typeParameter: validateType(\"TSTypeParameter\"),\n  },\n});\n\ndefineType(\"TSParenthesizedType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSTypeOperator\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    operator: validate(assertValueType(\"string\")),\n    typeAnnotation: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSIndexedAccessType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"objectType\", \"indexType\"],\n  fields: {\n    objectType: validateType(\"TSType\"),\n    indexType: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSMappedType\", {\n  aliases: [\"TSType\"],\n  visitor: process.env.BABEL_8_BREAKING\n    ? [\"key\", \"constraint\", \"nameType\", \"typeAnnotation\"]\n    : [\"typeParameter\", \"nameType\", \"typeAnnotation\"],\n  builder: process.env.BABEL_8_BREAKING\n    ? [\"key\", \"constraint\", \"nameType\", \"typeAnnotation\"]\n    : [\"typeParameter\", \"typeAnnotation\", \"nameType\"],\n  fields: {\n    ...(process.env.BABEL_8_BREAKING\n      ? {\n          key: validateType(\"Identifier\"),\n          constraint: validateType(\"TSType\"),\n        }\n      : {\n          typeParameter: validateType(\"TSTypeParameter\"),\n        }),\n    readonly: validateOptional(assertOneOf(true, false, \"+\", \"-\")),\n    optional: validateOptional(assertOneOf(true, false, \"+\", \"-\")),\n    typeAnnotation: validateOptionalType(\"TSType\"),\n    nameType: validateOptionalType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSLiteralType\", {\n  aliases: [\"TSType\", \"TSBaseType\"],\n  visitor: [\"literal\"],\n  fields: {\n    literal: {\n      validate: (function () {\n        const unaryExpression = assertNodeType(\n          \"NumericLiteral\",\n          \"BigIntLiteral\",\n        );\n        const unaryOperator = assertOneOf(\"-\");\n\n        const literal = assertNodeType(\n          \"NumericLiteral\",\n          \"StringLiteral\",\n          \"BooleanLiteral\",\n          \"BigIntLiteral\",\n          \"TemplateLiteral\",\n        );\n        function validator(parent: any, key: string, node: any) {\n          // type A = -1 | 1;\n          if (is(\"UnaryExpression\", node)) {\n            // check operator first\n            unaryOperator(node, \"operator\", node.operator);\n            unaryExpression(node, \"argument\", node.argument);\n          } else {\n            // type A = 'foo' | 'bar' | false | 1;\n            literal(parent, key, node);\n          }\n        }\n\n        validator.oneOfNodeTypes = [\n          \"NumericLiteral\",\n          \"StringLiteral\",\n          \"BooleanLiteral\",\n          \"BigIntLiteral\",\n          \"TemplateLiteral\",\n          \"UnaryExpression\",\n        ];\n\n        return validator;\n      })(),\n    },\n  },\n});\n\nconst expressionWithTypeArguments = {\n  aliases: [\"TSType\"],\n  visitor: [\"expression\", \"typeParameters\"],\n  fields: {\n    expression: validateType(\"TSEntityName\"),\n    typeParameters: validateOptionalType(\"TSTypeParameterInstantiation\"),\n  },\n};\n\nif (process.env.BABEL_8_BREAKING) {\n  defineType(\"TSClassImplements\", expressionWithTypeArguments);\n  defineType(\"TSInterfaceHeritage\", expressionWithTypeArguments);\n} else {\n  defineType(\"TSExpressionWithTypeArguments\", expressionWithTypeArguments);\n}\n\ndefineType(\"TSInterfaceDeclaration\", {\n  // \"Statement\" alias prevents a semicolon from appearing after it in an export declaration.\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"typeParameters\", \"extends\", \"body\"],\n  fields: {\n    declare: validateOptional(bool),\n    id: validateType(\"Identifier\"),\n    typeParameters: validateOptionalType(\"TSTypeParameterDeclaration\"),\n    extends: validateOptional(\n      arrayOfType(\n        // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n        process.env.BABEL_8_BREAKING\n          ? \"TSClassImplements\"\n          : \"TSExpressionWithTypeArguments\",\n      ),\n    ),\n    body: validateType(\"TSInterfaceBody\"),\n  },\n});\n\ndefineType(\"TSInterfaceBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: validateArrayOfType(\"TSTypeElement\"),\n  },\n});\n\ndefineType(\"TSTypeAliasDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"typeParameters\", \"typeAnnotation\"],\n  fields: {\n    declare: validateOptional(bool),\n    id: validateType(\"Identifier\"),\n    typeParameters: validateOptionalType(\"TSTypeParameterDeclaration\"),\n    typeAnnotation: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSInstantiationExpression\", {\n  aliases: [\"Expression\"],\n  visitor: [\"expression\", \"typeParameters\"],\n  fields: {\n    expression: validateType(\"Expression\"),\n    typeParameters: validateOptionalType(\"TSTypeParameterInstantiation\"),\n  },\n});\n\nconst TSTypeExpression = {\n  aliases: [\"Expression\", \"LVal\", \"PatternLike\"],\n  visitor: [\"expression\", \"typeAnnotation\"],\n  fields: {\n    expression: validateType(\"Expression\"),\n    typeAnnotation: validateType(\"TSType\"),\n  },\n};\n\ndefineType(\"TSAsExpression\", TSTypeExpression);\ndefineType(\"TSSatisfiesExpression\", TSTypeExpression);\n\ndefineType(\"TSTypeAssertion\", {\n  aliases: [\"Expression\", \"LVal\", \"PatternLike\"],\n  visitor: [\"typeAnnotation\", \"expression\"],\n  fields: {\n    typeAnnotation: validateType(\"TSType\"),\n    expression: validateType(\"Expression\"),\n  },\n});\n\ndefineType(\"TSEnumDeclaration\", {\n  // \"Statement\" alias prevents a semicolon from appearing after it in an export declaration.\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"members\"],\n  fields: {\n    declare: validateOptional(bool),\n    const: validateOptional(bool),\n    id: validateType(\"Identifier\"),\n    members: validateArrayOfType(\"TSEnumMember\"),\n    initializer: validateOptionalType(\"Expression\"),\n  },\n});\n\ndefineType(\"TSEnumMember\", {\n  visitor: [\"id\", \"initializer\"],\n  fields: {\n    id: validateType(\"Identifier\", \"StringLiteral\"),\n    initializer: validateOptionalType(\"Expression\"),\n  },\n});\n\ndefineType(\"TSModuleDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"body\"],\n  fields: {\n    kind: {\n      validate: assertOneOf(\"global\", \"module\", \"namespace\"),\n    },\n    declare: validateOptional(bool),\n    ...(!process.env.BABEL_8_BREAKING && { global: validateOptional(bool) }),\n    id: process.env.BABEL_8_BREAKING\n      ? validateType(\"TSEntityName\", \"StringLiteral\")\n      : validateType(\"Identifier\", \"StringLiteral\"),\n    body: process.env.BABEL_8_BREAKING\n      ? validateType(\"TSModuleBlock\")\n      : validateType(\"TSModuleBlock\", \"TSModuleDeclaration\"),\n  },\n});\n\ndefineType(\"TSModuleBlock\", {\n  aliases: [\"Scopable\", \"Block\", \"BlockParent\", \"FunctionParent\"],\n  visitor: [\"body\"],\n  fields: {\n    body: validateArrayOfType(\"Statement\"),\n  },\n});\n\ndefineType(\"TSImportType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"argument\", \"qualifier\", \"typeParameters\"],\n  fields: {\n    argument: validateType(\"StringLiteral\"),\n    qualifier: validateOptionalType(\"TSEntityName\"),\n    typeParameters: validateOptionalType(\"TSTypeParameterInstantiation\"),\n    options: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"TSImportEqualsDeclaration\", {\n  aliases: [\"Statement\"],\n  visitor: [\"id\", \"moduleReference\"],\n  fields: {\n    isExport: validate(bool),\n    id: validateType(\"Identifier\"),\n    moduleReference: validateType(\"TSEntityName\", \"TSExternalModuleReference\"),\n    importKind: {\n      validate: assertOneOf(\"type\", \"value\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"TSExternalModuleReference\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: validateType(\"StringLiteral\"),\n  },\n});\n\ndefineType(\"TSNonNullExpression\", {\n  aliases: [\"Expression\", \"LVal\", \"PatternLike\"],\n  visitor: [\"expression\"],\n  fields: {\n    expression: validateType(\"Expression\"),\n  },\n});\n\ndefineType(\"TSExportAssignment\", {\n  aliases: [\"Statement\"],\n  visitor: [\"expression\"],\n  fields: {\n    expression: validateType(\"Expression\"),\n  },\n});\n\ndefineType(\"TSNamespaceExportDeclaration\", {\n  aliases: [\"Statement\"],\n  visitor: [\"id\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n  },\n});\n\ndefineType(\"TSTypeAnnotation\", {\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: {\n      validate: assertNodeType(\"TSType\"),\n    },\n  },\n});\n\ndefineType(\"TSTypeParameterInstantiation\", {\n  visitor: [\"params\"],\n  fields: {\n    params: validateArrayOfType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSTypeParameterDeclaration\", {\n  visitor: [\"params\"],\n  fields: {\n    params: validateArrayOfType(\"TSTypeParameter\"),\n  },\n});\n\ndefineType(\"TSTypeParameter\", {\n  builder: [\"constraint\", \"default\", \"name\"],\n  visitor: [\"constraint\", \"default\"],\n  fields: {\n    name: {\n      validate: !process.env.BABEL_8_BREAKING\n        ? assertValueType(\"string\")\n        : assertNodeType(\"Identifier\"),\n    },\n    in: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    out: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    const: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    constraint: {\n      validate: assertNodeType(\"TSType\"),\n      optional: true,\n    },\n    default: {\n      validate: assertNodeType(\"TSType\"),\n      optional: true,\n    },\n  },\n});\n", "export const DEPRECATED_ALIASES = {\n  ModuleDeclaration: \"ImportOrExportDeclaration\",\n};\n", "import \"./core.ts\";\nimport \"./flow.ts\";\nimport \"./jsx.ts\";\nimport \"./misc.ts\";\nimport \"./experimental.ts\";\nimport \"./typescript.ts\";\nimport {\n  VISITOR_KEYS,\n  ALIAS_KEYS,\n  FLIPPED_ALIAS_KEYS,\n  NODE_FIELDS,\n  BUILDER_KEYS,\n  DEPRECATED_KEYS,\n  NODE_PARENT_VALIDATIONS,\n} from \"./utils.ts\";\nimport {\n  PLACEHOLDERS,\n  PLACEHOLDERS_ALIAS,\n  PLACEHOLDERS_FLIPPED_ALIAS,\n} from \"./placeholders.ts\";\nimport { DEPRECATED_ALIASES } from \"./deprecated-aliases.ts\";\n\n(\n  Object.keys(DEPRECATED_ALIASES) as (keyof typeof DEPRECATED_ALIASES)[]\n).forEach(deprecatedAlias => {\n  FLIPPED_ALIAS_KEYS[deprecatedAlias] =\n    FLIPPED_ALIAS_KEYS[DEPRECATED_ALIASES[deprecatedAlias]];\n});\n\nconst TYPES: Array<string> = [].concat(\n  Object.keys(VISITOR_KEYS),\n  Object.keys(FLIPPED_ALIAS_KEYS),\n  Object.keys(DEPRECATED_KEYS),\n);\n\nexport {\n  VISITOR_KEYS,\n  ALIAS_KEYS,\n  FLIPPED_ALIAS_KEYS,\n  NODE_FIELDS,\n  BUILDER_KEYS,\n  DEPRECATED_ALIASES,\n  DEPRECATED_KEYS,\n  NODE_PARENT_VALIDATIONS,\n  PLACEHOLDERS,\n  PLACEHOLDERS_ALIAS,\n  PLACEHOLDERS_FLIPPED_ALIAS,\n  TYPES,\n};\n\nexport type { FieldOptions } from \"./utils.ts\";\n", "import {\n  NODE_FIELDS,\n  NODE_PARENT_VALIDATIONS,\n  type FieldOptions,\n} from \"../definitions/index.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default function validate(\n  node: t.Node | undefined | null,\n  key: string,\n  val: unknown,\n): void {\n  if (!node) return;\n\n  const fields = NODE_FIELDS[node.type];\n  if (!fields) return;\n\n  const field = fields[key];\n  validateField(node, key, val, field);\n  validateChild(node, key, val);\n}\n\nexport function validateInternal(\n  field: FieldOptions,\n  node: t.Node | undefined | null,\n  key: string,\n  val: unknown,\n  maybeNode?: 1,\n): void {\n  if (!field?.validate) return;\n  if (field.optional && val == null) return;\n\n  field.validate(node, key, val);\n\n  if (maybeNode) {\n    const type = (val as t.Node).type;\n    if (type == null) return;\n    NODE_PARENT_VALIDATIONS[type]?.(node, key, val);\n  }\n}\n\nexport function validateField(\n  node: t.Node | undefined | null,\n  key: string,\n  val: unknown,\n  field: FieldOptions | undefined | null,\n): void {\n  if (!field?.validate) return;\n  if (field.optional && val == null) return;\n\n  field.validate(node, key, val);\n}\n\nexport function validateChild(\n  node: t.Node | undefined | null,\n  key: string,\n  val?: unknown,\n) {\n  const type = (val as t.Node)?.type;\n  if (type == null) return;\n  NODE_PARENT_VALIDATIONS[type]?.(node, key, val);\n}\n", "/*\n * This file is auto-generated! Do not modify it directly.\n * To re-generate run 'make build'\n */\nimport * as _validate from \"../../validators/validate.ts\";\nimport type * as t from \"../../index.ts\";\nimport deprecationWarning from \"../../utils/deprecationWarning.ts\";\nimport * as utils from \"../../definitions/utils.ts\";\n\nconst { validateInternal: validate } = _validate;\nconst { NODE_FIELDS } = utils;\n\nexport function arrayExpression(\n  elements: Array<null | t.Expression | t.SpreadElement> = [],\n): t.ArrayExpression {\n  const node: t.ArrayExpression = {\n    type: \"ArrayExpression\",\n    elements,\n  };\n  const defs = NODE_FIELDS.ArrayExpression;\n  validate(defs.elements, node, \"elements\", elements, 1);\n  return node;\n}\nexport function assignmentExpression(\n  operator: string,\n  left: t.LVal | t.OptionalMemberExpression,\n  right: t.Expression,\n): t.AssignmentExpression {\n  const node: t.AssignmentExpression = {\n    type: \"AssignmentExpression\",\n    operator,\n    left,\n    right,\n  };\n  const defs = NODE_FIELDS.AssignmentExpression;\n  validate(defs.operator, node, \"operator\", operator);\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nexport function binaryExpression(\n  operator:\n    | \"+\"\n    | \"-\"\n    | \"/\"\n    | \"%\"\n    | \"*\"\n    | \"**\"\n    | \"&\"\n    | \"|\"\n    | \">>\"\n    | \">>>\"\n    | \"<<\"\n    | \"^\"\n    | \"==\"\n    | \"===\"\n    | \"!=\"\n    | \"!==\"\n    | \"in\"\n    | \"instanceof\"\n    | \">\"\n    | \"<\"\n    | \">=\"\n    | \"<=\"\n    | \"|>\",\n  left: t.Expression | t.PrivateName,\n  right: t.Expression,\n): t.BinaryExpression {\n  const node: t.BinaryExpression = {\n    type: \"BinaryExpression\",\n    operator,\n    left,\n    right,\n  };\n  const defs = NODE_FIELDS.BinaryExpression;\n  validate(defs.operator, node, \"operator\", operator);\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nexport function interpreterDirective(value: string): t.InterpreterDirective {\n  const node: t.InterpreterDirective = {\n    type: \"InterpreterDirective\",\n    value,\n  };\n  const defs = NODE_FIELDS.InterpreterDirective;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function directive(value: t.DirectiveLiteral): t.Directive {\n  const node: t.Directive = {\n    type: \"Directive\",\n    value,\n  };\n  const defs = NODE_FIELDS.Directive;\n  validate(defs.value, node, \"value\", value, 1);\n  return node;\n}\nexport function directiveLiteral(value: string): t.DirectiveLiteral {\n  const node: t.DirectiveLiteral = {\n    type: \"DirectiveLiteral\",\n    value,\n  };\n  const defs = NODE_FIELDS.DirectiveLiteral;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function blockStatement(\n  body: Array<t.Statement>,\n  directives: Array<t.Directive> = [],\n): t.BlockStatement {\n  const node: t.BlockStatement = {\n    type: \"BlockStatement\",\n    body,\n    directives,\n  };\n  const defs = NODE_FIELDS.BlockStatement;\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.directives, node, \"directives\", directives, 1);\n  return node;\n}\nexport function breakStatement(\n  label: t.Identifier | null = null,\n): t.BreakStatement {\n  const node: t.BreakStatement = {\n    type: \"BreakStatement\",\n    label,\n  };\n  const defs = NODE_FIELDS.BreakStatement;\n  validate(defs.label, node, \"label\", label, 1);\n  return node;\n}\nexport function callExpression(\n  callee: t.Expression | t.Super | t.V8IntrinsicIdentifier,\n  _arguments: Array<t.Expression | t.SpreadElement | t.ArgumentPlaceholder>,\n): t.CallExpression {\n  const node: t.CallExpression = {\n    type: \"CallExpression\",\n    callee,\n    arguments: _arguments,\n  };\n  const defs = NODE_FIELDS.CallExpression;\n  validate(defs.callee, node, \"callee\", callee, 1);\n  validate(defs.arguments, node, \"arguments\", _arguments, 1);\n  return node;\n}\nexport function catchClause(\n  param:\n    | t.Identifier\n    | t.ArrayPattern\n    | t.ObjectPattern\n    | null\n    | undefined = null,\n  body: t.BlockStatement,\n): t.CatchClause {\n  const node: t.CatchClause = {\n    type: \"CatchClause\",\n    param,\n    body,\n  };\n  const defs = NODE_FIELDS.CatchClause;\n  validate(defs.param, node, \"param\", param, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function conditionalExpression(\n  test: t.Expression,\n  consequent: t.Expression,\n  alternate: t.Expression,\n): t.ConditionalExpression {\n  const node: t.ConditionalExpression = {\n    type: \"ConditionalExpression\",\n    test,\n    consequent,\n    alternate,\n  };\n  const defs = NODE_FIELDS.ConditionalExpression;\n  validate(defs.test, node, \"test\", test, 1);\n  validate(defs.consequent, node, \"consequent\", consequent, 1);\n  validate(defs.alternate, node, \"alternate\", alternate, 1);\n  return node;\n}\nexport function continueStatement(\n  label: t.Identifier | null = null,\n): t.ContinueStatement {\n  const node: t.ContinueStatement = {\n    type: \"ContinueStatement\",\n    label,\n  };\n  const defs = NODE_FIELDS.ContinueStatement;\n  validate(defs.label, node, \"label\", label, 1);\n  return node;\n}\nexport function debuggerStatement(): t.DebuggerStatement {\n  return {\n    type: \"DebuggerStatement\",\n  };\n}\nexport function doWhileStatement(\n  test: t.Expression,\n  body: t.Statement,\n): t.DoWhileStatement {\n  const node: t.DoWhileStatement = {\n    type: \"DoWhileStatement\",\n    test,\n    body,\n  };\n  const defs = NODE_FIELDS.DoWhileStatement;\n  validate(defs.test, node, \"test\", test, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function emptyStatement(): t.EmptyStatement {\n  return {\n    type: \"EmptyStatement\",\n  };\n}\nexport function expressionStatement(\n  expression: t.Expression,\n): t.ExpressionStatement {\n  const node: t.ExpressionStatement = {\n    type: \"ExpressionStatement\",\n    expression,\n  };\n  const defs = NODE_FIELDS.ExpressionStatement;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nexport function file(\n  program: t.Program,\n  comments: Array<t.CommentBlock | t.CommentLine> | null = null,\n  tokens: Array<any> | null = null,\n): t.File {\n  const node: t.File = {\n    type: \"File\",\n    program,\n    comments,\n    tokens,\n  };\n  const defs = NODE_FIELDS.File;\n  validate(defs.program, node, \"program\", program, 1);\n  validate(defs.comments, node, \"comments\", comments, 1);\n  validate(defs.tokens, node, \"tokens\", tokens);\n  return node;\n}\nexport function forInStatement(\n  left: t.VariableDeclaration | t.LVal,\n  right: t.Expression,\n  body: t.Statement,\n): t.ForInStatement {\n  const node: t.ForInStatement = {\n    type: \"ForInStatement\",\n    left,\n    right,\n    body,\n  };\n  const defs = NODE_FIELDS.ForInStatement;\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function forStatement(\n  init: t.VariableDeclaration | t.Expression | null | undefined = null,\n  test: t.Expression | null | undefined = null,\n  update: t.Expression | null | undefined = null,\n  body: t.Statement,\n): t.ForStatement {\n  const node: t.ForStatement = {\n    type: \"ForStatement\",\n    init,\n    test,\n    update,\n    body,\n  };\n  const defs = NODE_FIELDS.ForStatement;\n  validate(defs.init, node, \"init\", init, 1);\n  validate(defs.test, node, \"test\", test, 1);\n  validate(defs.update, node, \"update\", update, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function functionDeclaration(\n  id: t.Identifier | null | undefined = null,\n  params: Array<t.Identifier | t.Pattern | t.RestElement>,\n  body: t.BlockStatement,\n  generator: boolean = false,\n  async: boolean = false,\n): t.FunctionDeclaration {\n  const node: t.FunctionDeclaration = {\n    type: \"FunctionDeclaration\",\n    id,\n    params,\n    body,\n    generator,\n    async,\n  };\n  const defs = NODE_FIELDS.FunctionDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.generator, node, \"generator\", generator);\n  validate(defs.async, node, \"async\", async);\n  return node;\n}\nexport function functionExpression(\n  id: t.Identifier | null | undefined = null,\n  params: Array<t.Identifier | t.Pattern | t.RestElement>,\n  body: t.BlockStatement,\n  generator: boolean = false,\n  async: boolean = false,\n): t.FunctionExpression {\n  const node: t.FunctionExpression = {\n    type: \"FunctionExpression\",\n    id,\n    params,\n    body,\n    generator,\n    async,\n  };\n  const defs = NODE_FIELDS.FunctionExpression;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.generator, node, \"generator\", generator);\n  validate(defs.async, node, \"async\", async);\n  return node;\n}\nexport function identifier(name: string): t.Identifier {\n  const node: t.Identifier = {\n    type: \"Identifier\",\n    name,\n  };\n  const defs = NODE_FIELDS.Identifier;\n  validate(defs.name, node, \"name\", name);\n  return node;\n}\nexport function ifStatement(\n  test: t.Expression,\n  consequent: t.Statement,\n  alternate: t.Statement | null = null,\n): t.IfStatement {\n  const node: t.IfStatement = {\n    type: \"IfStatement\",\n    test,\n    consequent,\n    alternate,\n  };\n  const defs = NODE_FIELDS.IfStatement;\n  validate(defs.test, node, \"test\", test, 1);\n  validate(defs.consequent, node, \"consequent\", consequent, 1);\n  validate(defs.alternate, node, \"alternate\", alternate, 1);\n  return node;\n}\nexport function labeledStatement(\n  label: t.Identifier,\n  body: t.Statement,\n): t.LabeledStatement {\n  const node: t.LabeledStatement = {\n    type: \"LabeledStatement\",\n    label,\n    body,\n  };\n  const defs = NODE_FIELDS.LabeledStatement;\n  validate(defs.label, node, \"label\", label, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function stringLiteral(value: string): t.StringLiteral {\n  const node: t.StringLiteral = {\n    type: \"StringLiteral\",\n    value,\n  };\n  const defs = NODE_FIELDS.StringLiteral;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function numericLiteral(value: number): t.NumericLiteral {\n  const node: t.NumericLiteral = {\n    type: \"NumericLiteral\",\n    value,\n  };\n  const defs = NODE_FIELDS.NumericLiteral;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function nullLiteral(): t.NullLiteral {\n  return {\n    type: \"NullLiteral\",\n  };\n}\nexport function booleanLiteral(value: boolean): t.BooleanLiteral {\n  const node: t.BooleanLiteral = {\n    type: \"BooleanLiteral\",\n    value,\n  };\n  const defs = NODE_FIELDS.BooleanLiteral;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function regExpLiteral(\n  pattern: string,\n  flags: string = \"\",\n): t.RegExpLiteral {\n  const node: t.RegExpLiteral = {\n    type: \"RegExpLiteral\",\n    pattern,\n    flags,\n  };\n  const defs = NODE_FIELDS.RegExpLiteral;\n  validate(defs.pattern, node, \"pattern\", pattern);\n  validate(defs.flags, node, \"flags\", flags);\n  return node;\n}\nexport function logicalExpression(\n  operator: \"||\" | \"&&\" | \"??\",\n  left: t.Expression,\n  right: t.Expression,\n): t.LogicalExpression {\n  const node: t.LogicalExpression = {\n    type: \"LogicalExpression\",\n    operator,\n    left,\n    right,\n  };\n  const defs = NODE_FIELDS.LogicalExpression;\n  validate(defs.operator, node, \"operator\", operator);\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nexport function memberExpression(\n  object: t.Expression | t.Super,\n  property: t.Expression | t.Identifier | t.PrivateName,\n  computed: boolean = false,\n  optional: boolean | null = null,\n): t.MemberExpression {\n  const node: t.MemberExpression = {\n    type: \"MemberExpression\",\n    object,\n    property,\n    computed,\n    optional,\n  };\n  const defs = NODE_FIELDS.MemberExpression;\n  validate(defs.object, node, \"object\", object, 1);\n  validate(defs.property, node, \"property\", property, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.optional, node, \"optional\", optional);\n  return node;\n}\nexport function newExpression(\n  callee: t.Expression | t.Super | t.V8IntrinsicIdentifier,\n  _arguments: Array<t.Expression | t.SpreadElement | t.ArgumentPlaceholder>,\n): t.NewExpression {\n  const node: t.NewExpression = {\n    type: \"NewExpression\",\n    callee,\n    arguments: _arguments,\n  };\n  const defs = NODE_FIELDS.NewExpression;\n  validate(defs.callee, node, \"callee\", callee, 1);\n  validate(defs.arguments, node, \"arguments\", _arguments, 1);\n  return node;\n}\nexport function program(\n  body: Array<t.Statement>,\n  directives: Array<t.Directive> = [],\n  sourceType: \"script\" | \"module\" = \"script\",\n  interpreter: t.InterpreterDirective | null = null,\n): t.Program {\n  const node: t.Program = {\n    type: \"Program\",\n    body,\n    directives,\n    sourceType,\n    interpreter,\n  };\n  const defs = NODE_FIELDS.Program;\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.directives, node, \"directives\", directives, 1);\n  validate(defs.sourceType, node, \"sourceType\", sourceType);\n  validate(defs.interpreter, node, \"interpreter\", interpreter, 1);\n  return node;\n}\nexport function objectExpression(\n  properties: Array<t.ObjectMethod | t.ObjectProperty | t.SpreadElement>,\n): t.ObjectExpression {\n  const node: t.ObjectExpression = {\n    type: \"ObjectExpression\",\n    properties,\n  };\n  const defs = NODE_FIELDS.ObjectExpression;\n  validate(defs.properties, node, \"properties\", properties, 1);\n  return node;\n}\nexport function objectMethod(\n  kind: \"method\" | \"get\" | \"set\" | undefined = \"method\",\n  key:\n    | t.Expression\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral,\n  params: Array<t.Identifier | t.Pattern | t.RestElement>,\n  body: t.BlockStatement,\n  computed: boolean = false,\n  generator: boolean = false,\n  async: boolean = false,\n): t.ObjectMethod {\n  const node: t.ObjectMethod = {\n    type: \"ObjectMethod\",\n    kind,\n    key,\n    params,\n    body,\n    computed,\n    generator,\n    async,\n  };\n  const defs = NODE_FIELDS.ObjectMethod;\n  validate(defs.kind, node, \"kind\", kind);\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.generator, node, \"generator\", generator);\n  validate(defs.async, node, \"async\", async);\n  return node;\n}\nexport function objectProperty(\n  key:\n    | t.Expression\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.DecimalLiteral\n    | t.PrivateName,\n  value: t.Expression | t.PatternLike,\n  computed: boolean = false,\n  shorthand: boolean = false,\n  decorators: Array<t.Decorator> | null = null,\n): t.ObjectProperty {\n  const node: t.ObjectProperty = {\n    type: \"ObjectProperty\",\n    key,\n    value,\n    computed,\n    shorthand,\n    decorators,\n  };\n  const defs = NODE_FIELDS.ObjectProperty;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.shorthand, node, \"shorthand\", shorthand);\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  return node;\n}\nexport function restElement(argument: t.LVal): t.RestElement {\n  const node: t.RestElement = {\n    type: \"RestElement\",\n    argument,\n  };\n  const defs = NODE_FIELDS.RestElement;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nexport function returnStatement(\n  argument: t.Expression | null = null,\n): t.ReturnStatement {\n  const node: t.ReturnStatement = {\n    type: \"ReturnStatement\",\n    argument,\n  };\n  const defs = NODE_FIELDS.ReturnStatement;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nexport function sequenceExpression(\n  expressions: Array<t.Expression>,\n): t.SequenceExpression {\n  const node: t.SequenceExpression = {\n    type: \"SequenceExpression\",\n    expressions,\n  };\n  const defs = NODE_FIELDS.SequenceExpression;\n  validate(defs.expressions, node, \"expressions\", expressions, 1);\n  return node;\n}\nexport function parenthesizedExpression(\n  expression: t.Expression,\n): t.ParenthesizedExpression {\n  const node: t.ParenthesizedExpression = {\n    type: \"ParenthesizedExpression\",\n    expression,\n  };\n  const defs = NODE_FIELDS.ParenthesizedExpression;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nexport function switchCase(\n  test: t.Expression | null | undefined = null,\n  consequent: Array<t.Statement>,\n): t.SwitchCase {\n  const node: t.SwitchCase = {\n    type: \"SwitchCase\",\n    test,\n    consequent,\n  };\n  const defs = NODE_FIELDS.SwitchCase;\n  validate(defs.test, node, \"test\", test, 1);\n  validate(defs.consequent, node, \"consequent\", consequent, 1);\n  return node;\n}\nexport function switchStatement(\n  discriminant: t.Expression,\n  cases: Array<t.SwitchCase>,\n): t.SwitchStatement {\n  const node: t.SwitchStatement = {\n    type: \"SwitchStatement\",\n    discriminant,\n    cases,\n  };\n  const defs = NODE_FIELDS.SwitchStatement;\n  validate(defs.discriminant, node, \"discriminant\", discriminant, 1);\n  validate(defs.cases, node, \"cases\", cases, 1);\n  return node;\n}\nexport function thisExpression(): t.ThisExpression {\n  return {\n    type: \"ThisExpression\",\n  };\n}\nexport function throwStatement(argument: t.Expression): t.ThrowStatement {\n  const node: t.ThrowStatement = {\n    type: \"ThrowStatement\",\n    argument,\n  };\n  const defs = NODE_FIELDS.ThrowStatement;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nexport function tryStatement(\n  block: t.BlockStatement,\n  handler: t.CatchClause | null = null,\n  finalizer: t.BlockStatement | null = null,\n): t.TryStatement {\n  const node: t.TryStatement = {\n    type: \"TryStatement\",\n    block,\n    handler,\n    finalizer,\n  };\n  const defs = NODE_FIELDS.TryStatement;\n  validate(defs.block, node, \"block\", block, 1);\n  validate(defs.handler, node, \"handler\", handler, 1);\n  validate(defs.finalizer, node, \"finalizer\", finalizer, 1);\n  return node;\n}\nexport function unaryExpression(\n  operator: \"void\" | \"throw\" | \"delete\" | \"!\" | \"+\" | \"-\" | \"~\" | \"typeof\",\n  argument: t.Expression,\n  prefix: boolean = true,\n): t.UnaryExpression {\n  const node: t.UnaryExpression = {\n    type: \"UnaryExpression\",\n    operator,\n    argument,\n    prefix,\n  };\n  const defs = NODE_FIELDS.UnaryExpression;\n  validate(defs.operator, node, \"operator\", operator);\n  validate(defs.argument, node, \"argument\", argument, 1);\n  validate(defs.prefix, node, \"prefix\", prefix);\n  return node;\n}\nexport function updateExpression(\n  operator: \"++\" | \"--\",\n  argument: t.Expression,\n  prefix: boolean = false,\n): t.UpdateExpression {\n  const node: t.UpdateExpression = {\n    type: \"UpdateExpression\",\n    operator,\n    argument,\n    prefix,\n  };\n  const defs = NODE_FIELDS.UpdateExpression;\n  validate(defs.operator, node, \"operator\", operator);\n  validate(defs.argument, node, \"argument\", argument, 1);\n  validate(defs.prefix, node, \"prefix\", prefix);\n  return node;\n}\nexport function variableDeclaration(\n  kind: \"var\" | \"let\" | \"const\" | \"using\" | \"await using\",\n  declarations: Array<t.VariableDeclarator>,\n): t.VariableDeclaration {\n  const node: t.VariableDeclaration = {\n    type: \"VariableDeclaration\",\n    kind,\n    declarations,\n  };\n  const defs = NODE_FIELDS.VariableDeclaration;\n  validate(defs.kind, node, \"kind\", kind);\n  validate(defs.declarations, node, \"declarations\", declarations, 1);\n  return node;\n}\nexport function variableDeclarator(\n  id: t.LVal,\n  init: t.Expression | null = null,\n): t.VariableDeclarator {\n  const node: t.VariableDeclarator = {\n    type: \"VariableDeclarator\",\n    id,\n    init,\n  };\n  const defs = NODE_FIELDS.VariableDeclarator;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.init, node, \"init\", init, 1);\n  return node;\n}\nexport function whileStatement(\n  test: t.Expression,\n  body: t.Statement,\n): t.WhileStatement {\n  const node: t.WhileStatement = {\n    type: \"WhileStatement\",\n    test,\n    body,\n  };\n  const defs = NODE_FIELDS.WhileStatement;\n  validate(defs.test, node, \"test\", test, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function withStatement(\n  object: t.Expression,\n  body: t.Statement,\n): t.WithStatement {\n  const node: t.WithStatement = {\n    type: \"WithStatement\",\n    object,\n    body,\n  };\n  const defs = NODE_FIELDS.WithStatement;\n  validate(defs.object, node, \"object\", object, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function assignmentPattern(\n  left:\n    | t.Identifier\n    | t.ObjectPattern\n    | t.ArrayPattern\n    | t.MemberExpression\n    | t.TSAsExpression\n    | t.TSSatisfiesExpression\n    | t.TSTypeAssertion\n    | t.TSNonNullExpression,\n  right: t.Expression,\n): t.AssignmentPattern {\n  const node: t.AssignmentPattern = {\n    type: \"AssignmentPattern\",\n    left,\n    right,\n  };\n  const defs = NODE_FIELDS.AssignmentPattern;\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nexport function arrayPattern(\n  elements: Array<null | t.PatternLike | t.LVal>,\n): t.ArrayPattern {\n  const node: t.ArrayPattern = {\n    type: \"ArrayPattern\",\n    elements,\n  };\n  const defs = NODE_FIELDS.ArrayPattern;\n  validate(defs.elements, node, \"elements\", elements, 1);\n  return node;\n}\nexport function arrowFunctionExpression(\n  params: Array<t.Identifier | t.Pattern | t.RestElement>,\n  body: t.BlockStatement | t.Expression,\n  async: boolean = false,\n): t.ArrowFunctionExpression {\n  const node: t.ArrowFunctionExpression = {\n    type: \"ArrowFunctionExpression\",\n    params,\n    body,\n    async,\n    expression: null,\n  };\n  const defs = NODE_FIELDS.ArrowFunctionExpression;\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.async, node, \"async\", async);\n  return node;\n}\nexport function classBody(\n  body: Array<\n    | t.ClassMethod\n    | t.ClassPrivateMethod\n    | t.ClassProperty\n    | t.ClassPrivateProperty\n    | t.ClassAccessorProperty\n    | t.TSDeclareMethod\n    | t.TSIndexSignature\n    | t.StaticBlock\n  >,\n): t.ClassBody {\n  const node: t.ClassBody = {\n    type: \"ClassBody\",\n    body,\n  };\n  const defs = NODE_FIELDS.ClassBody;\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function classExpression(\n  id: t.Identifier | null | undefined = null,\n  superClass: t.Expression | null | undefined = null,\n  body: t.ClassBody,\n  decorators: Array<t.Decorator> | null = null,\n): t.ClassExpression {\n  const node: t.ClassExpression = {\n    type: \"ClassExpression\",\n    id,\n    superClass,\n    body,\n    decorators,\n  };\n  const defs = NODE_FIELDS.ClassExpression;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.superClass, node, \"superClass\", superClass, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  return node;\n}\nexport function classDeclaration(\n  id: t.Identifier | null | undefined = null,\n  superClass: t.Expression | null | undefined = null,\n  body: t.ClassBody,\n  decorators: Array<t.Decorator> | null = null,\n): t.ClassDeclaration {\n  const node: t.ClassDeclaration = {\n    type: \"ClassDeclaration\",\n    id,\n    superClass,\n    body,\n    decorators,\n  };\n  const defs = NODE_FIELDS.ClassDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.superClass, node, \"superClass\", superClass, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  return node;\n}\nexport function exportAllDeclaration(\n  source: t.StringLiteral,\n): t.ExportAllDeclaration {\n  const node: t.ExportAllDeclaration = {\n    type: \"ExportAllDeclaration\",\n    source,\n  };\n  const defs = NODE_FIELDS.ExportAllDeclaration;\n  validate(defs.source, node, \"source\", source, 1);\n  return node;\n}\nexport function exportDefaultDeclaration(\n  declaration:\n    | t.TSDeclareFunction\n    | t.FunctionDeclaration\n    | t.ClassDeclaration\n    | t.Expression,\n): t.ExportDefaultDeclaration {\n  const node: t.ExportDefaultDeclaration = {\n    type: \"ExportDefaultDeclaration\",\n    declaration,\n  };\n  const defs = NODE_FIELDS.ExportDefaultDeclaration;\n  validate(defs.declaration, node, \"declaration\", declaration, 1);\n  return node;\n}\nexport function exportNamedDeclaration(\n  declaration: t.Declaration | null = null,\n  specifiers: Array<\n    t.ExportSpecifier | t.ExportDefaultSpecifier | t.ExportNamespaceSpecifier\n  > = [],\n  source: t.StringLiteral | null = null,\n): t.ExportNamedDeclaration {\n  const node: t.ExportNamedDeclaration = {\n    type: \"ExportNamedDeclaration\",\n    declaration,\n    specifiers,\n    source,\n  };\n  const defs = NODE_FIELDS.ExportNamedDeclaration;\n  validate(defs.declaration, node, \"declaration\", declaration, 1);\n  validate(defs.specifiers, node, \"specifiers\", specifiers, 1);\n  validate(defs.source, node, \"source\", source, 1);\n  return node;\n}\nexport function exportSpecifier(\n  local: t.Identifier,\n  exported: t.Identifier | t.StringLiteral,\n): t.ExportSpecifier {\n  const node: t.ExportSpecifier = {\n    type: \"ExportSpecifier\",\n    local,\n    exported,\n  };\n  const defs = NODE_FIELDS.ExportSpecifier;\n  validate(defs.local, node, \"local\", local, 1);\n  validate(defs.exported, node, \"exported\", exported, 1);\n  return node;\n}\nexport function forOfStatement(\n  left: t.VariableDeclaration | t.LVal,\n  right: t.Expression,\n  body: t.Statement,\n  _await: boolean = false,\n): t.ForOfStatement {\n  const node: t.ForOfStatement = {\n    type: \"ForOfStatement\",\n    left,\n    right,\n    body,\n    await: _await,\n  };\n  const defs = NODE_FIELDS.ForOfStatement;\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.await, node, \"await\", _await);\n  return node;\n}\nexport function importDeclaration(\n  specifiers: Array<\n    t.ImportSpecifier | t.ImportDefaultSpecifier | t.ImportNamespaceSpecifier\n  >,\n  source: t.StringLiteral,\n): t.ImportDeclaration {\n  const node: t.ImportDeclaration = {\n    type: \"ImportDeclaration\",\n    specifiers,\n    source,\n  };\n  const defs = NODE_FIELDS.ImportDeclaration;\n  validate(defs.specifiers, node, \"specifiers\", specifiers, 1);\n  validate(defs.source, node, \"source\", source, 1);\n  return node;\n}\nexport function importDefaultSpecifier(\n  local: t.Identifier,\n): t.ImportDefaultSpecifier {\n  const node: t.ImportDefaultSpecifier = {\n    type: \"ImportDefaultSpecifier\",\n    local,\n  };\n  const defs = NODE_FIELDS.ImportDefaultSpecifier;\n  validate(defs.local, node, \"local\", local, 1);\n  return node;\n}\nexport function importNamespaceSpecifier(\n  local: t.Identifier,\n): t.ImportNamespaceSpecifier {\n  const node: t.ImportNamespaceSpecifier = {\n    type: \"ImportNamespaceSpecifier\",\n    local,\n  };\n  const defs = NODE_FIELDS.ImportNamespaceSpecifier;\n  validate(defs.local, node, \"local\", local, 1);\n  return node;\n}\nexport function importSpecifier(\n  local: t.Identifier,\n  imported: t.Identifier | t.StringLiteral,\n): t.ImportSpecifier {\n  const node: t.ImportSpecifier = {\n    type: \"ImportSpecifier\",\n    local,\n    imported,\n  };\n  const defs = NODE_FIELDS.ImportSpecifier;\n  validate(defs.local, node, \"local\", local, 1);\n  validate(defs.imported, node, \"imported\", imported, 1);\n  return node;\n}\nexport function importExpression(\n  source: t.Expression,\n  options: t.Expression | null = null,\n): t.ImportExpression {\n  const node: t.ImportExpression = {\n    type: \"ImportExpression\",\n    source,\n    options,\n  };\n  const defs = NODE_FIELDS.ImportExpression;\n  validate(defs.source, node, \"source\", source, 1);\n  validate(defs.options, node, \"options\", options, 1);\n  return node;\n}\nexport function metaProperty(\n  meta: t.Identifier,\n  property: t.Identifier,\n): t.MetaProperty {\n  const node: t.MetaProperty = {\n    type: \"MetaProperty\",\n    meta,\n    property,\n  };\n  const defs = NODE_FIELDS.MetaProperty;\n  validate(defs.meta, node, \"meta\", meta, 1);\n  validate(defs.property, node, \"property\", property, 1);\n  return node;\n}\nexport function classMethod(\n  kind: \"get\" | \"set\" | \"method\" | \"constructor\" | undefined = \"method\",\n  key:\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.Expression,\n  params: Array<\n    t.Identifier | t.Pattern | t.RestElement | t.TSParameterProperty\n  >,\n  body: t.BlockStatement,\n  computed: boolean = false,\n  _static: boolean = false,\n  generator: boolean = false,\n  async: boolean = false,\n): t.ClassMethod {\n  const node: t.ClassMethod = {\n    type: \"ClassMethod\",\n    kind,\n    key,\n    params,\n    body,\n    computed,\n    static: _static,\n    generator,\n    async,\n  };\n  const defs = NODE_FIELDS.ClassMethod;\n  validate(defs.kind, node, \"kind\", kind);\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.static, node, \"static\", _static);\n  validate(defs.generator, node, \"generator\", generator);\n  validate(defs.async, node, \"async\", async);\n  return node;\n}\nexport function objectPattern(\n  properties: Array<t.RestElement | t.ObjectProperty>,\n): t.ObjectPattern {\n  const node: t.ObjectPattern = {\n    type: \"ObjectPattern\",\n    properties,\n  };\n  const defs = NODE_FIELDS.ObjectPattern;\n  validate(defs.properties, node, \"properties\", properties, 1);\n  return node;\n}\nexport function spreadElement(argument: t.Expression): t.SpreadElement {\n  const node: t.SpreadElement = {\n    type: \"SpreadElement\",\n    argument,\n  };\n  const defs = NODE_FIELDS.SpreadElement;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nfunction _super(): t.Super {\n  return {\n    type: \"Super\",\n  };\n}\nexport { _super as super };\nexport function taggedTemplateExpression(\n  tag: t.Expression,\n  quasi: t.TemplateLiteral,\n): t.TaggedTemplateExpression {\n  const node: t.TaggedTemplateExpression = {\n    type: \"TaggedTemplateExpression\",\n    tag,\n    quasi,\n  };\n  const defs = NODE_FIELDS.TaggedTemplateExpression;\n  validate(defs.tag, node, \"tag\", tag, 1);\n  validate(defs.quasi, node, \"quasi\", quasi, 1);\n  return node;\n}\nexport function templateElement(\n  value: { raw: string; cooked?: string },\n  tail: boolean = false,\n): t.TemplateElement {\n  const node: t.TemplateElement = {\n    type: \"TemplateElement\",\n    value,\n    tail,\n  };\n  const defs = NODE_FIELDS.TemplateElement;\n  validate(defs.value, node, \"value\", value);\n  validate(defs.tail, node, \"tail\", tail);\n  return node;\n}\nexport function templateLiteral(\n  quasis: Array<t.TemplateElement>,\n  expressions: Array<t.Expression | t.TSType>,\n): t.TemplateLiteral {\n  const node: t.TemplateLiteral = {\n    type: \"TemplateLiteral\",\n    quasis,\n    expressions,\n  };\n  const defs = NODE_FIELDS.TemplateLiteral;\n  validate(defs.quasis, node, \"quasis\", quasis, 1);\n  validate(defs.expressions, node, \"expressions\", expressions, 1);\n  return node;\n}\nexport function yieldExpression(\n  argument: t.Expression | null = null,\n  delegate: boolean = false,\n): t.YieldExpression {\n  const node: t.YieldExpression = {\n    type: \"YieldExpression\",\n    argument,\n    delegate,\n  };\n  const defs = NODE_FIELDS.YieldExpression;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  validate(defs.delegate, node, \"delegate\", delegate);\n  return node;\n}\nexport function awaitExpression(argument: t.Expression): t.AwaitExpression {\n  const node: t.AwaitExpression = {\n    type: \"AwaitExpression\",\n    argument,\n  };\n  const defs = NODE_FIELDS.AwaitExpression;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nfunction _import(): t.Import {\n  return {\n    type: \"Import\",\n  };\n}\nexport { _import as import };\nexport function bigIntLiteral(value: string): t.BigIntLiteral {\n  const node: t.BigIntLiteral = {\n    type: \"BigIntLiteral\",\n    value,\n  };\n  const defs = NODE_FIELDS.BigIntLiteral;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function exportNamespaceSpecifier(\n  exported: t.Identifier,\n): t.ExportNamespaceSpecifier {\n  const node: t.ExportNamespaceSpecifier = {\n    type: \"ExportNamespaceSpecifier\",\n    exported,\n  };\n  const defs = NODE_FIELDS.ExportNamespaceSpecifier;\n  validate(defs.exported, node, \"exported\", exported, 1);\n  return node;\n}\nexport function optionalMemberExpression(\n  object: t.Expression,\n  property: t.Expression | t.Identifier,\n  computed: boolean | undefined = false,\n  optional: boolean,\n): t.OptionalMemberExpression {\n  const node: t.OptionalMemberExpression = {\n    type: \"OptionalMemberExpression\",\n    object,\n    property,\n    computed,\n    optional,\n  };\n  const defs = NODE_FIELDS.OptionalMemberExpression;\n  validate(defs.object, node, \"object\", object, 1);\n  validate(defs.property, node, \"property\", property, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.optional, node, \"optional\", optional);\n  return node;\n}\nexport function optionalCallExpression(\n  callee: t.Expression,\n  _arguments: Array<t.Expression | t.SpreadElement | t.ArgumentPlaceholder>,\n  optional: boolean,\n): t.OptionalCallExpression {\n  const node: t.OptionalCallExpression = {\n    type: \"OptionalCallExpression\",\n    callee,\n    arguments: _arguments,\n    optional,\n  };\n  const defs = NODE_FIELDS.OptionalCallExpression;\n  validate(defs.callee, node, \"callee\", callee, 1);\n  validate(defs.arguments, node, \"arguments\", _arguments, 1);\n  validate(defs.optional, node, \"optional\", optional);\n  return node;\n}\nexport function classProperty(\n  key:\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.Expression,\n  value: t.Expression | null = null,\n  typeAnnotation: t.TypeAnnotation | t.TSTypeAnnotation | t.Noop | null = null,\n  decorators: Array<t.Decorator> | null = null,\n  computed: boolean = false,\n  _static: boolean = false,\n): t.ClassProperty {\n  const node: t.ClassProperty = {\n    type: \"ClassProperty\",\n    key,\n    value,\n    typeAnnotation,\n    decorators,\n    computed,\n    static: _static,\n  };\n  const defs = NODE_FIELDS.ClassProperty;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.static, node, \"static\", _static);\n  return node;\n}\nexport function classAccessorProperty(\n  key:\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.Expression\n    | t.PrivateName,\n  value: t.Expression | null = null,\n  typeAnnotation: t.TypeAnnotation | t.TSTypeAnnotation | t.Noop | null = null,\n  decorators: Array<t.Decorator> | null = null,\n  computed: boolean = false,\n  _static: boolean = false,\n): t.ClassAccessorProperty {\n  const node: t.ClassAccessorProperty = {\n    type: \"ClassAccessorProperty\",\n    key,\n    value,\n    typeAnnotation,\n    decorators,\n    computed,\n    static: _static,\n  };\n  const defs = NODE_FIELDS.ClassAccessorProperty;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.static, node, \"static\", _static);\n  return node;\n}\nexport function classPrivateProperty(\n  key: t.PrivateName,\n  value: t.Expression | null = null,\n  decorators: Array<t.Decorator> | null = null,\n  _static: boolean = false,\n): t.ClassPrivateProperty {\n  const node: t.ClassPrivateProperty = {\n    type: \"ClassPrivateProperty\",\n    key,\n    value,\n    decorators,\n    static: _static,\n  };\n  const defs = NODE_FIELDS.ClassPrivateProperty;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  validate(defs.static, node, \"static\", _static);\n  return node;\n}\nexport function classPrivateMethod(\n  kind: \"get\" | \"set\" | \"method\" | undefined = \"method\",\n  key: t.PrivateName,\n  params: Array<\n    t.Identifier | t.Pattern | t.RestElement | t.TSParameterProperty\n  >,\n  body: t.BlockStatement,\n  _static: boolean = false,\n): t.ClassPrivateMethod {\n  const node: t.ClassPrivateMethod = {\n    type: \"ClassPrivateMethod\",\n    kind,\n    key,\n    params,\n    body,\n    static: _static,\n  };\n  const defs = NODE_FIELDS.ClassPrivateMethod;\n  validate(defs.kind, node, \"kind\", kind);\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.static, node, \"static\", _static);\n  return node;\n}\nexport function privateName(id: t.Identifier): t.PrivateName {\n  const node: t.PrivateName = {\n    type: \"PrivateName\",\n    id,\n  };\n  const defs = NODE_FIELDS.PrivateName;\n  validate(defs.id, node, \"id\", id, 1);\n  return node;\n}\nexport function staticBlock(body: Array<t.Statement>): t.StaticBlock {\n  const node: t.StaticBlock = {\n    type: \"StaticBlock\",\n    body,\n  };\n  const defs = NODE_FIELDS.StaticBlock;\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function anyTypeAnnotation(): t.AnyTypeAnnotation {\n  return {\n    type: \"AnyTypeAnnotation\",\n  };\n}\nexport function arrayTypeAnnotation(\n  elementType: t.FlowType,\n): t.ArrayTypeAnnotation {\n  const node: t.ArrayTypeAnnotation = {\n    type: \"ArrayTypeAnnotation\",\n    elementType,\n  };\n  const defs = NODE_FIELDS.ArrayTypeAnnotation;\n  validate(defs.elementType, node, \"elementType\", elementType, 1);\n  return node;\n}\nexport function booleanTypeAnnotation(): t.BooleanTypeAnnotation {\n  return {\n    type: \"BooleanTypeAnnotation\",\n  };\n}\nexport function booleanLiteralTypeAnnotation(\n  value: boolean,\n): t.BooleanLiteralTypeAnnotation {\n  const node: t.BooleanLiteralTypeAnnotation = {\n    type: \"BooleanLiteralTypeAnnotation\",\n    value,\n  };\n  const defs = NODE_FIELDS.BooleanLiteralTypeAnnotation;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function nullLiteralTypeAnnotation(): t.NullLiteralTypeAnnotation {\n  return {\n    type: \"NullLiteralTypeAnnotation\",\n  };\n}\nexport function classImplements(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterInstantiation | null = null,\n): t.ClassImplements {\n  const node: t.ClassImplements = {\n    type: \"ClassImplements\",\n    id,\n    typeParameters,\n  };\n  const defs = NODE_FIELDS.ClassImplements;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  return node;\n}\nexport function declareClass(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null | undefined = null,\n  _extends: Array<t.InterfaceExtends> | null | undefined = null,\n  body: t.ObjectTypeAnnotation,\n): t.DeclareClass {\n  const node: t.DeclareClass = {\n    type: \"DeclareClass\",\n    id,\n    typeParameters,\n    extends: _extends,\n    body,\n  };\n  const defs = NODE_FIELDS.DeclareClass;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.extends, node, \"extends\", _extends, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function declareFunction(id: t.Identifier): t.DeclareFunction {\n  const node: t.DeclareFunction = {\n    type: \"DeclareFunction\",\n    id,\n  };\n  const defs = NODE_FIELDS.DeclareFunction;\n  validate(defs.id, node, \"id\", id, 1);\n  return node;\n}\nexport function declareInterface(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null | undefined = null,\n  _extends: Array<t.InterfaceExtends> | null | undefined = null,\n  body: t.ObjectTypeAnnotation,\n): t.DeclareInterface {\n  const node: t.DeclareInterface = {\n    type: \"DeclareInterface\",\n    id,\n    typeParameters,\n    extends: _extends,\n    body,\n  };\n  const defs = NODE_FIELDS.DeclareInterface;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.extends, node, \"extends\", _extends, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function declareModule(\n  id: t.Identifier | t.StringLiteral,\n  body: t.BlockStatement,\n  kind: \"CommonJS\" | \"ES\" | null = null,\n): t.DeclareModule {\n  const node: t.DeclareModule = {\n    type: \"DeclareModule\",\n    id,\n    body,\n    kind,\n  };\n  const defs = NODE_FIELDS.DeclareModule;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.kind, node, \"kind\", kind);\n  return node;\n}\nexport function declareModuleExports(\n  typeAnnotation: t.TypeAnnotation,\n): t.DeclareModuleExports {\n  const node: t.DeclareModuleExports = {\n    type: \"DeclareModuleExports\",\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.DeclareModuleExports;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport function declareTypeAlias(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null | undefined = null,\n  right: t.FlowType,\n): t.DeclareTypeAlias {\n  const node: t.DeclareTypeAlias = {\n    type: \"DeclareTypeAlias\",\n    id,\n    typeParameters,\n    right,\n  };\n  const defs = NODE_FIELDS.DeclareTypeAlias;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nexport function declareOpaqueType(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null = null,\n  supertype: t.FlowType | null = null,\n): t.DeclareOpaqueType {\n  const node: t.DeclareOpaqueType = {\n    type: \"DeclareOpaqueType\",\n    id,\n    typeParameters,\n    supertype,\n  };\n  const defs = NODE_FIELDS.DeclareOpaqueType;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.supertype, node, \"supertype\", supertype, 1);\n  return node;\n}\nexport function declareVariable(id: t.Identifier): t.DeclareVariable {\n  const node: t.DeclareVariable = {\n    type: \"DeclareVariable\",\n    id,\n  };\n  const defs = NODE_FIELDS.DeclareVariable;\n  validate(defs.id, node, \"id\", id, 1);\n  return node;\n}\nexport function declareExportDeclaration(\n  declaration: t.Flow | null = null,\n  specifiers: Array<\n    t.ExportSpecifier | t.ExportNamespaceSpecifier\n  > | null = null,\n  source: t.StringLiteral | null = null,\n  attributes: Array<t.ImportAttribute> | null = null,\n): t.DeclareExportDeclaration {\n  const node: t.DeclareExportDeclaration = {\n    type: \"DeclareExportDeclaration\",\n    declaration,\n    specifiers,\n    source,\n    attributes,\n  };\n  const defs = NODE_FIELDS.DeclareExportDeclaration;\n  validate(defs.declaration, node, \"declaration\", declaration, 1);\n  validate(defs.specifiers, node, \"specifiers\", specifiers, 1);\n  validate(defs.source, node, \"source\", source, 1);\n  validate(defs.attributes, node, \"attributes\", attributes, 1);\n  return node;\n}\nexport function declareExportAllDeclaration(\n  source: t.StringLiteral,\n  attributes: Array<t.ImportAttribute> | null = null,\n): t.DeclareExportAllDeclaration {\n  const node: t.DeclareExportAllDeclaration = {\n    type: \"DeclareExportAllDeclaration\",\n    source,\n    attributes,\n  };\n  const defs = NODE_FIELDS.DeclareExportAllDeclaration;\n  validate(defs.source, node, \"source\", source, 1);\n  validate(defs.attributes, node, \"attributes\", attributes, 1);\n  return node;\n}\nexport function declaredPredicate(value: t.Flow): t.DeclaredPredicate {\n  const node: t.DeclaredPredicate = {\n    type: \"DeclaredPredicate\",\n    value,\n  };\n  const defs = NODE_FIELDS.DeclaredPredicate;\n  validate(defs.value, node, \"value\", value, 1);\n  return node;\n}\nexport function existsTypeAnnotation(): t.ExistsTypeAnnotation {\n  return {\n    type: \"ExistsTypeAnnotation\",\n  };\n}\nexport function functionTypeAnnotation(\n  typeParameters: t.TypeParameterDeclaration | null | undefined = null,\n  params: Array<t.FunctionTypeParam>,\n  rest: t.FunctionTypeParam | null | undefined = null,\n  returnType: t.FlowType,\n): t.FunctionTypeAnnotation {\n  const node: t.FunctionTypeAnnotation = {\n    type: \"FunctionTypeAnnotation\",\n    typeParameters,\n    params,\n    rest,\n    returnType,\n  };\n  const defs = NODE_FIELDS.FunctionTypeAnnotation;\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.rest, node, \"rest\", rest, 1);\n  validate(defs.returnType, node, \"returnType\", returnType, 1);\n  return node;\n}\nexport function functionTypeParam(\n  name: t.Identifier | null | undefined = null,\n  typeAnnotation: t.FlowType,\n): t.FunctionTypeParam {\n  const node: t.FunctionTypeParam = {\n    type: \"FunctionTypeParam\",\n    name,\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.FunctionTypeParam;\n  validate(defs.name, node, \"name\", name, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport function genericTypeAnnotation(\n  id: t.Identifier | t.QualifiedTypeIdentifier,\n  typeParameters: t.TypeParameterInstantiation | null = null,\n): t.GenericTypeAnnotation {\n  const node: t.GenericTypeAnnotation = {\n    type: \"GenericTypeAnnotation\",\n    id,\n    typeParameters,\n  };\n  const defs = NODE_FIELDS.GenericTypeAnnotation;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  return node;\n}\nexport function inferredPredicate(): t.InferredPredicate {\n  return {\n    type: \"InferredPredicate\",\n  };\n}\nexport function interfaceExtends(\n  id: t.Identifier | t.QualifiedTypeIdentifier,\n  typeParameters: t.TypeParameterInstantiation | null = null,\n): t.InterfaceExtends {\n  const node: t.InterfaceExtends = {\n    type: \"InterfaceExtends\",\n    id,\n    typeParameters,\n  };\n  const defs = NODE_FIELDS.InterfaceExtends;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  return node;\n}\nexport function interfaceDeclaration(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null | undefined = null,\n  _extends: Array<t.InterfaceExtends> | null | undefined = null,\n  body: t.ObjectTypeAnnotation,\n): t.InterfaceDeclaration {\n  const node: t.InterfaceDeclaration = {\n    type: \"InterfaceDeclaration\",\n    id,\n    typeParameters,\n    extends: _extends,\n    body,\n  };\n  const defs = NODE_FIELDS.InterfaceDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.extends, node, \"extends\", _extends, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function interfaceTypeAnnotation(\n  _extends: Array<t.InterfaceExtends> | null | undefined = null,\n  body: t.ObjectTypeAnnotation,\n): t.InterfaceTypeAnnotation {\n  const node: t.InterfaceTypeAnnotation = {\n    type: \"InterfaceTypeAnnotation\",\n    extends: _extends,\n    body,\n  };\n  const defs = NODE_FIELDS.InterfaceTypeAnnotation;\n  validate(defs.extends, node, \"extends\", _extends, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function intersectionTypeAnnotation(\n  types: Array<t.FlowType>,\n): t.IntersectionTypeAnnotation {\n  const node: t.IntersectionTypeAnnotation = {\n    type: \"IntersectionTypeAnnotation\",\n    types,\n  };\n  const defs = NODE_FIELDS.IntersectionTypeAnnotation;\n  validate(defs.types, node, \"types\", types, 1);\n  return node;\n}\nexport function mixedTypeAnnotation(): t.MixedTypeAnnotation {\n  return {\n    type: \"MixedTypeAnnotation\",\n  };\n}\nexport function emptyTypeAnnotation(): t.EmptyTypeAnnotation {\n  return {\n    type: \"EmptyTypeAnnotation\",\n  };\n}\nexport function nullableTypeAnnotation(\n  typeAnnotation: t.FlowType,\n): t.NullableTypeAnnotation {\n  const node: t.NullableTypeAnnotation = {\n    type: \"NullableTypeAnnotation\",\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.NullableTypeAnnotation;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport function numberLiteralTypeAnnotation(\n  value: number,\n): t.NumberLiteralTypeAnnotation {\n  const node: t.NumberLiteralTypeAnnotation = {\n    type: \"NumberLiteralTypeAnnotation\",\n    value,\n  };\n  const defs = NODE_FIELDS.NumberLiteralTypeAnnotation;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function numberTypeAnnotation(): t.NumberTypeAnnotation {\n  return {\n    type: \"NumberTypeAnnotation\",\n  };\n}\nexport function objectTypeAnnotation(\n  properties: Array<t.ObjectTypeProperty | t.ObjectTypeSpreadProperty>,\n  indexers: Array<t.ObjectTypeIndexer> = [],\n  callProperties: Array<t.ObjectTypeCallProperty> = [],\n  internalSlots: Array<t.ObjectTypeInternalSlot> = [],\n  exact: boolean = false,\n): t.ObjectTypeAnnotation {\n  const node: t.ObjectTypeAnnotation = {\n    type: \"ObjectTypeAnnotation\",\n    properties,\n    indexers,\n    callProperties,\n    internalSlots,\n    exact,\n  };\n  const defs = NODE_FIELDS.ObjectTypeAnnotation;\n  validate(defs.properties, node, \"properties\", properties, 1);\n  validate(defs.indexers, node, \"indexers\", indexers, 1);\n  validate(defs.callProperties, node, \"callProperties\", callProperties, 1);\n  validate(defs.internalSlots, node, \"internalSlots\", internalSlots, 1);\n  validate(defs.exact, node, \"exact\", exact);\n  return node;\n}\nexport function objectTypeInternalSlot(\n  id: t.Identifier,\n  value: t.FlowType,\n  optional: boolean,\n  _static: boolean,\n  method: boolean,\n): t.ObjectTypeInternalSlot {\n  const node: t.ObjectTypeInternalSlot = {\n    type: \"ObjectTypeInternalSlot\",\n    id,\n    value,\n    optional,\n    static: _static,\n    method,\n  };\n  const defs = NODE_FIELDS.ObjectTypeInternalSlot;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.optional, node, \"optional\", optional);\n  validate(defs.static, node, \"static\", _static);\n  validate(defs.method, node, \"method\", method);\n  return node;\n}\nexport function objectTypeCallProperty(\n  value: t.FlowType,\n): t.ObjectTypeCallProperty {\n  const node: t.ObjectTypeCallProperty = {\n    type: \"ObjectTypeCallProperty\",\n    value,\n    static: null,\n  };\n  const defs = NODE_FIELDS.ObjectTypeCallProperty;\n  validate(defs.value, node, \"value\", value, 1);\n  return node;\n}\nexport function objectTypeIndexer(\n  id: t.Identifier | null | undefined = null,\n  key: t.FlowType,\n  value: t.FlowType,\n  variance: t.Variance | null = null,\n): t.ObjectTypeIndexer {\n  const node: t.ObjectTypeIndexer = {\n    type: \"ObjectTypeIndexer\",\n    id,\n    key,\n    value,\n    variance,\n    static: null,\n  };\n  const defs = NODE_FIELDS.ObjectTypeIndexer;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.variance, node, \"variance\", variance, 1);\n  return node;\n}\nexport function objectTypeProperty(\n  key: t.Identifier | t.StringLiteral,\n  value: t.FlowType,\n  variance: t.Variance | null = null,\n): t.ObjectTypeProperty {\n  const node: t.ObjectTypeProperty = {\n    type: \"ObjectTypeProperty\",\n    key,\n    value,\n    variance,\n    kind: null,\n    method: null,\n    optional: null,\n    proto: null,\n    static: null,\n  };\n  const defs = NODE_FIELDS.ObjectTypeProperty;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.variance, node, \"variance\", variance, 1);\n  return node;\n}\nexport function objectTypeSpreadProperty(\n  argument: t.FlowType,\n): t.ObjectTypeSpreadProperty {\n  const node: t.ObjectTypeSpreadProperty = {\n    type: \"ObjectTypeSpreadProperty\",\n    argument,\n  };\n  const defs = NODE_FIELDS.ObjectTypeSpreadProperty;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nexport function opaqueType(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null | undefined = null,\n  supertype: t.FlowType | null | undefined = null,\n  impltype: t.FlowType,\n): t.OpaqueType {\n  const node: t.OpaqueType = {\n    type: \"OpaqueType\",\n    id,\n    typeParameters,\n    supertype,\n    impltype,\n  };\n  const defs = NODE_FIELDS.OpaqueType;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.supertype, node, \"supertype\", supertype, 1);\n  validate(defs.impltype, node, \"impltype\", impltype, 1);\n  return node;\n}\nexport function qualifiedTypeIdentifier(\n  id: t.Identifier,\n  qualification: t.Identifier | t.QualifiedTypeIdentifier,\n): t.QualifiedTypeIdentifier {\n  const node: t.QualifiedTypeIdentifier = {\n    type: \"QualifiedTypeIdentifier\",\n    id,\n    qualification,\n  };\n  const defs = NODE_FIELDS.QualifiedTypeIdentifier;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.qualification, node, \"qualification\", qualification, 1);\n  return node;\n}\nexport function stringLiteralTypeAnnotation(\n  value: string,\n): t.StringLiteralTypeAnnotation {\n  const node: t.StringLiteralTypeAnnotation = {\n    type: \"StringLiteralTypeAnnotation\",\n    value,\n  };\n  const defs = NODE_FIELDS.StringLiteralTypeAnnotation;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function stringTypeAnnotation(): t.StringTypeAnnotation {\n  return {\n    type: \"StringTypeAnnotation\",\n  };\n}\nexport function symbolTypeAnnotation(): t.SymbolTypeAnnotation {\n  return {\n    type: \"SymbolTypeAnnotation\",\n  };\n}\nexport function thisTypeAnnotation(): t.ThisTypeAnnotation {\n  return {\n    type: \"ThisTypeAnnotation\",\n  };\n}\nexport function tupleTypeAnnotation(\n  types: Array<t.FlowType>,\n): t.TupleTypeAnnotation {\n  const node: t.TupleTypeAnnotation = {\n    type: \"TupleTypeAnnotation\",\n    types,\n  };\n  const defs = NODE_FIELDS.TupleTypeAnnotation;\n  validate(defs.types, node, \"types\", types, 1);\n  return node;\n}\nexport function typeofTypeAnnotation(\n  argument: t.FlowType,\n): t.TypeofTypeAnnotation {\n  const node: t.TypeofTypeAnnotation = {\n    type: \"TypeofTypeAnnotation\",\n    argument,\n  };\n  const defs = NODE_FIELDS.TypeofTypeAnnotation;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nexport function typeAlias(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null | undefined = null,\n  right: t.FlowType,\n): t.TypeAlias {\n  const node: t.TypeAlias = {\n    type: \"TypeAlias\",\n    id,\n    typeParameters,\n    right,\n  };\n  const defs = NODE_FIELDS.TypeAlias;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nexport function typeAnnotation(typeAnnotation: t.FlowType): t.TypeAnnotation {\n  const node: t.TypeAnnotation = {\n    type: \"TypeAnnotation\",\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TypeAnnotation;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport function typeCastExpression(\n  expression: t.Expression,\n  typeAnnotation: t.TypeAnnotation,\n): t.TypeCastExpression {\n  const node: t.TypeCastExpression = {\n    type: \"TypeCastExpression\",\n    expression,\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TypeCastExpression;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport function typeParameter(\n  bound: t.TypeAnnotation | null = null,\n  _default: t.FlowType | null = null,\n  variance: t.Variance | null = null,\n): t.TypeParameter {\n  const node: t.TypeParameter = {\n    type: \"TypeParameter\",\n    bound,\n    default: _default,\n    variance,\n    name: null,\n  };\n  const defs = NODE_FIELDS.TypeParameter;\n  validate(defs.bound, node, \"bound\", bound, 1);\n  validate(defs.default, node, \"default\", _default, 1);\n  validate(defs.variance, node, \"variance\", variance, 1);\n  return node;\n}\nexport function typeParameterDeclaration(\n  params: Array<t.TypeParameter>,\n): t.TypeParameterDeclaration {\n  const node: t.TypeParameterDeclaration = {\n    type: \"TypeParameterDeclaration\",\n    params,\n  };\n  const defs = NODE_FIELDS.TypeParameterDeclaration;\n  validate(defs.params, node, \"params\", params, 1);\n  return node;\n}\nexport function typeParameterInstantiation(\n  params: Array<t.FlowType>,\n): t.TypeParameterInstantiation {\n  const node: t.TypeParameterInstantiation = {\n    type: \"TypeParameterInstantiation\",\n    params,\n  };\n  const defs = NODE_FIELDS.TypeParameterInstantiation;\n  validate(defs.params, node, \"params\", params, 1);\n  return node;\n}\nexport function unionTypeAnnotation(\n  types: Array<t.FlowType>,\n): t.UnionTypeAnnotation {\n  const node: t.UnionTypeAnnotation = {\n    type: \"UnionTypeAnnotation\",\n    types,\n  };\n  const defs = NODE_FIELDS.UnionTypeAnnotation;\n  validate(defs.types, node, \"types\", types, 1);\n  return node;\n}\nexport function variance(kind: \"minus\" | \"plus\"): t.Variance {\n  const node: t.Variance = {\n    type: \"Variance\",\n    kind,\n  };\n  const defs = NODE_FIELDS.Variance;\n  validate(defs.kind, node, \"kind\", kind);\n  return node;\n}\nexport function voidTypeAnnotation(): t.VoidTypeAnnotation {\n  return {\n    type: \"VoidTypeAnnotation\",\n  };\n}\nexport function enumDeclaration(\n  id: t.Identifier,\n  body:\n    | t.EnumBooleanBody\n    | t.EnumNumberBody\n    | t.EnumStringBody\n    | t.EnumSymbolBody,\n): t.EnumDeclaration {\n  const node: t.EnumDeclaration = {\n    type: \"EnumDeclaration\",\n    id,\n    body,\n  };\n  const defs = NODE_FIELDS.EnumDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function enumBooleanBody(\n  members: Array<t.EnumBooleanMember>,\n): t.EnumBooleanBody {\n  const node: t.EnumBooleanBody = {\n    type: \"EnumBooleanBody\",\n    members,\n    explicitType: null,\n    hasUnknownMembers: null,\n  };\n  const defs = NODE_FIELDS.EnumBooleanBody;\n  validate(defs.members, node, \"members\", members, 1);\n  return node;\n}\nexport function enumNumberBody(\n  members: Array<t.EnumNumberMember>,\n): t.EnumNumberBody {\n  const node: t.EnumNumberBody = {\n    type: \"EnumNumberBody\",\n    members,\n    explicitType: null,\n    hasUnknownMembers: null,\n  };\n  const defs = NODE_FIELDS.EnumNumberBody;\n  validate(defs.members, node, \"members\", members, 1);\n  return node;\n}\nexport function enumStringBody(\n  members: Array<t.EnumStringMember | t.EnumDefaultedMember>,\n): t.EnumStringBody {\n  const node: t.EnumStringBody = {\n    type: \"EnumStringBody\",\n    members,\n    explicitType: null,\n    hasUnknownMembers: null,\n  };\n  const defs = NODE_FIELDS.EnumStringBody;\n  validate(defs.members, node, \"members\", members, 1);\n  return node;\n}\nexport function enumSymbolBody(\n  members: Array<t.EnumDefaultedMember>,\n): t.EnumSymbolBody {\n  const node: t.EnumSymbolBody = {\n    type: \"EnumSymbolBody\",\n    members,\n    hasUnknownMembers: null,\n  };\n  const defs = NODE_FIELDS.EnumSymbolBody;\n  validate(defs.members, node, \"members\", members, 1);\n  return node;\n}\nexport function enumBooleanMember(id: t.Identifier): t.EnumBooleanMember {\n  const node: t.EnumBooleanMember = {\n    type: \"EnumBooleanMember\",\n    id,\n    init: null,\n  };\n  const defs = NODE_FIELDS.EnumBooleanMember;\n  validate(defs.id, node, \"id\", id, 1);\n  return node;\n}\nexport function enumNumberMember(\n  id: t.Identifier,\n  init: t.NumericLiteral,\n): t.EnumNumberMember {\n  const node: t.EnumNumberMember = {\n    type: \"EnumNumberMember\",\n    id,\n    init,\n  };\n  const defs = NODE_FIELDS.EnumNumberMember;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.init, node, \"init\", init, 1);\n  return node;\n}\nexport function enumStringMember(\n  id: t.Identifier,\n  init: t.StringLiteral,\n): t.EnumStringMember {\n  const node: t.EnumStringMember = {\n    type: \"EnumStringMember\",\n    id,\n    init,\n  };\n  const defs = NODE_FIELDS.EnumStringMember;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.init, node, \"init\", init, 1);\n  return node;\n}\nexport function enumDefaultedMember(id: t.Identifier): t.EnumDefaultedMember {\n  const node: t.EnumDefaultedMember = {\n    type: \"EnumDefaultedMember\",\n    id,\n  };\n  const defs = NODE_FIELDS.EnumDefaultedMember;\n  validate(defs.id, node, \"id\", id, 1);\n  return node;\n}\nexport function indexedAccessType(\n  objectType: t.FlowType,\n  indexType: t.FlowType,\n): t.IndexedAccessType {\n  const node: t.IndexedAccessType = {\n    type: \"IndexedAccessType\",\n    objectType,\n    indexType,\n  };\n  const defs = NODE_FIELDS.IndexedAccessType;\n  validate(defs.objectType, node, \"objectType\", objectType, 1);\n  validate(defs.indexType, node, \"indexType\", indexType, 1);\n  return node;\n}\nexport function optionalIndexedAccessType(\n  objectType: t.FlowType,\n  indexType: t.FlowType,\n): t.OptionalIndexedAccessType {\n  const node: t.OptionalIndexedAccessType = {\n    type: \"OptionalIndexedAccessType\",\n    objectType,\n    indexType,\n    optional: null,\n  };\n  const defs = NODE_FIELDS.OptionalIndexedAccessType;\n  validate(defs.objectType, node, \"objectType\", objectType, 1);\n  validate(defs.indexType, node, \"indexType\", indexType, 1);\n  return node;\n}\nexport function jsxAttribute(\n  name: t.JSXIdentifier | t.JSXNamespacedName,\n  value:\n    | t.JSXElement\n    | t.JSXFragment\n    | t.StringLiteral\n    | t.JSXExpressionContainer\n    | null = null,\n): t.JSXAttribute {\n  const node: t.JSXAttribute = {\n    type: \"JSXAttribute\",\n    name,\n    value,\n  };\n  const defs = NODE_FIELDS.JSXAttribute;\n  validate(defs.name, node, \"name\", name, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  return node;\n}\nexport { jsxAttribute as jSXAttribute };\nexport function jsxClosingElement(\n  name: t.JSXIdentifier | t.JSXMemberExpression | t.JSXNamespacedName,\n): t.JSXClosingElement {\n  const node: t.JSXClosingElement = {\n    type: \"JSXClosingElement\",\n    name,\n  };\n  const defs = NODE_FIELDS.JSXClosingElement;\n  validate(defs.name, node, \"name\", name, 1);\n  return node;\n}\nexport { jsxClosingElement as jSXClosingElement };\nexport function jsxElement(\n  openingElement: t.JSXOpeningElement,\n  closingElement: t.JSXClosingElement | null | undefined = null,\n  children: Array<\n    | t.JSXText\n    | t.JSXExpressionContainer\n    | t.JSXSpreadChild\n    | t.JSXElement\n    | t.JSXFragment\n  >,\n  selfClosing: boolean | null = null,\n): t.JSXElement {\n  const node: t.JSXElement = {\n    type: \"JSXElement\",\n    openingElement,\n    closingElement,\n    children,\n    selfClosing,\n  };\n  const defs = NODE_FIELDS.JSXElement;\n  validate(defs.openingElement, node, \"openingElement\", openingElement, 1);\n  validate(defs.closingElement, node, \"closingElement\", closingElement, 1);\n  validate(defs.children, node, \"children\", children, 1);\n  validate(defs.selfClosing, node, \"selfClosing\", selfClosing);\n  return node;\n}\nexport { jsxElement as jSXElement };\nexport function jsxEmptyExpression(): t.JSXEmptyExpression {\n  return {\n    type: \"JSXEmptyExpression\",\n  };\n}\nexport { jsxEmptyExpression as jSXEmptyExpression };\nexport function jsxExpressionContainer(\n  expression: t.Expression | t.JSXEmptyExpression,\n): t.JSXExpressionContainer {\n  const node: t.JSXExpressionContainer = {\n    type: \"JSXExpressionContainer\",\n    expression,\n  };\n  const defs = NODE_FIELDS.JSXExpressionContainer;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nexport { jsxExpressionContainer as jSXExpressionContainer };\nexport function jsxSpreadChild(expression: t.Expression): t.JSXSpreadChild {\n  const node: t.JSXSpreadChild = {\n    type: \"JSXSpreadChild\",\n    expression,\n  };\n  const defs = NODE_FIELDS.JSXSpreadChild;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nexport { jsxSpreadChild as jSXSpreadChild };\nexport function jsxIdentifier(name: string): t.JSXIdentifier {\n  const node: t.JSXIdentifier = {\n    type: \"JSXIdentifier\",\n    name,\n  };\n  const defs = NODE_FIELDS.JSXIdentifier;\n  validate(defs.name, node, \"name\", name);\n  return node;\n}\nexport { jsxIdentifier as jSXIdentifier };\nexport function jsxMemberExpression(\n  object: t.JSXMemberExpression | t.JSXIdentifier,\n  property: t.JSXIdentifier,\n): t.JSXMemberExpression {\n  const node: t.JSXMemberExpression = {\n    type: \"JSXMemberExpression\",\n    object,\n    property,\n  };\n  const defs = NODE_FIELDS.JSXMemberExpression;\n  validate(defs.object, node, \"object\", object, 1);\n  validate(defs.property, node, \"property\", property, 1);\n  return node;\n}\nexport { jsxMemberExpression as jSXMemberExpression };\nexport function jsxNamespacedName(\n  namespace: t.JSXIdentifier,\n  name: t.JSXIdentifier,\n): t.JSXNamespacedName {\n  const node: t.JSXNamespacedName = {\n    type: \"JSXNamespacedName\",\n    namespace,\n    name,\n  };\n  const defs = NODE_FIELDS.JSXNamespacedName;\n  validate(defs.namespace, node, \"namespace\", namespace, 1);\n  validate(defs.name, node, \"name\", name, 1);\n  return node;\n}\nexport { jsxNamespacedName as jSXNamespacedName };\nexport function jsxOpeningElement(\n  name: t.JSXIdentifier | t.JSXMemberExpression | t.JSXNamespacedName,\n  attributes: Array<t.JSXAttribute | t.JSXSpreadAttribute>,\n  selfClosing: boolean = false,\n): t.JSXOpeningElement {\n  const node: t.JSXOpeningElement = {\n    type: \"JSXOpeningElement\",\n    name,\n    attributes,\n    selfClosing,\n  };\n  const defs = NODE_FIELDS.JSXOpeningElement;\n  validate(defs.name, node, \"name\", name, 1);\n  validate(defs.attributes, node, \"attributes\", attributes, 1);\n  validate(defs.selfClosing, node, \"selfClosing\", selfClosing);\n  return node;\n}\nexport { jsxOpeningElement as jSXOpeningElement };\nexport function jsxSpreadAttribute(\n  argument: t.Expression,\n): t.JSXSpreadAttribute {\n  const node: t.JSXSpreadAttribute = {\n    type: \"JSXSpreadAttribute\",\n    argument,\n  };\n  const defs = NODE_FIELDS.JSXSpreadAttribute;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nexport { jsxSpreadAttribute as jSXSpreadAttribute };\nexport function jsxText(value: string): t.JSXText {\n  const node: t.JSXText = {\n    type: \"JSXText\",\n    value,\n  };\n  const defs = NODE_FIELDS.JSXText;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport { jsxText as jSXText };\nexport function jsxFragment(\n  openingFragment: t.JSXOpeningFragment,\n  closingFragment: t.JSXClosingFragment,\n  children: Array<\n    | t.JSXText\n    | t.JSXExpressionContainer\n    | t.JSXSpreadChild\n    | t.JSXElement\n    | t.JSXFragment\n  >,\n): t.JSXFragment {\n  const node: t.JSXFragment = {\n    type: \"JSXFragment\",\n    openingFragment,\n    closingFragment,\n    children,\n  };\n  const defs = NODE_FIELDS.JSXFragment;\n  validate(defs.openingFragment, node, \"openingFragment\", openingFragment, 1);\n  validate(defs.closingFragment, node, \"closingFragment\", closingFragment, 1);\n  validate(defs.children, node, \"children\", children, 1);\n  return node;\n}\nexport { jsxFragment as jSXFragment };\nexport function jsxOpeningFragment(): t.JSXOpeningFragment {\n  return {\n    type: \"JSXOpeningFragment\",\n  };\n}\nexport { jsxOpeningFragment as jSXOpeningFragment };\nexport function jsxClosingFragment(): t.JSXClosingFragment {\n  return {\n    type: \"JSXClosingFragment\",\n  };\n}\nexport { jsxClosingFragment as jSXClosingFragment };\nexport function noop(): t.Noop {\n  return {\n    type: \"Noop\",\n  };\n}\nexport function placeholder(\n  expectedNode:\n    | \"Identifier\"\n    | \"StringLiteral\"\n    | \"Expression\"\n    | \"Statement\"\n    | \"Declaration\"\n    | \"BlockStatement\"\n    | \"ClassBody\"\n    | \"Pattern\",\n  name: t.Identifier,\n): t.Placeholder {\n  const node: t.Placeholder = {\n    type: \"Placeholder\",\n    expectedNode,\n    name,\n  };\n  const defs = NODE_FIELDS.Placeholder;\n  validate(defs.expectedNode, node, \"expectedNode\", expectedNode);\n  validate(defs.name, node, \"name\", name, 1);\n  return node;\n}\nexport function v8IntrinsicIdentifier(name: string): t.V8IntrinsicIdentifier {\n  const node: t.V8IntrinsicIdentifier = {\n    type: \"V8IntrinsicIdentifier\",\n    name,\n  };\n  const defs = NODE_FIELDS.V8IntrinsicIdentifier;\n  validate(defs.name, node, \"name\", name);\n  return node;\n}\nexport function argumentPlaceholder(): t.ArgumentPlaceholder {\n  return {\n    type: \"ArgumentPlaceholder\",\n  };\n}\nexport function bindExpression(\n  object: t.Expression,\n  callee: t.Expression,\n): t.BindExpression {\n  const node: t.BindExpression = {\n    type: \"BindExpression\",\n    object,\n    callee,\n  };\n  const defs = NODE_FIELDS.BindExpression;\n  validate(defs.object, node, \"object\", object, 1);\n  validate(defs.callee, node, \"callee\", callee, 1);\n  return node;\n}\nexport function importAttribute(\n  key: t.Identifier | t.StringLiteral,\n  value: t.StringLiteral,\n): t.ImportAttribute {\n  const node: t.ImportAttribute = {\n    type: \"ImportAttribute\",\n    key,\n    value,\n  };\n  const defs = NODE_FIELDS.ImportAttribute;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  return node;\n}\nexport function decorator(expression: t.Expression): t.Decorator {\n  const node: t.Decorator = {\n    type: \"Decorator\",\n    expression,\n  };\n  const defs = NODE_FIELDS.Decorator;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nexport function doExpression(\n  body: t.BlockStatement,\n  async: boolean = false,\n): t.DoExpression {\n  const node: t.DoExpression = {\n    type: \"DoExpression\",\n    body,\n    async,\n  };\n  const defs = NODE_FIELDS.DoExpression;\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.async, node, \"async\", async);\n  return node;\n}\nexport function exportDefaultSpecifier(\n  exported: t.Identifier,\n): t.ExportDefaultSpecifier {\n  const node: t.ExportDefaultSpecifier = {\n    type: \"ExportDefaultSpecifier\",\n    exported,\n  };\n  const defs = NODE_FIELDS.ExportDefaultSpecifier;\n  validate(defs.exported, node, \"exported\", exported, 1);\n  return node;\n}\nexport function recordExpression(\n  properties: Array<t.ObjectProperty | t.SpreadElement>,\n): t.RecordExpression {\n  const node: t.RecordExpression = {\n    type: \"RecordExpression\",\n    properties,\n  };\n  const defs = NODE_FIELDS.RecordExpression;\n  validate(defs.properties, node, \"properties\", properties, 1);\n  return node;\n}\nexport function tupleExpression(\n  elements: Array<t.Expression | t.SpreadElement> = [],\n): t.TupleExpression {\n  const node: t.TupleExpression = {\n    type: \"TupleExpression\",\n    elements,\n  };\n  const defs = NODE_FIELDS.TupleExpression;\n  validate(defs.elements, node, \"elements\", elements, 1);\n  return node;\n}\nexport function decimalLiteral(value: string): t.DecimalLiteral {\n  const node: t.DecimalLiteral = {\n    type: \"DecimalLiteral\",\n    value,\n  };\n  const defs = NODE_FIELDS.DecimalLiteral;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function moduleExpression(body: t.Program): t.ModuleExpression {\n  const node: t.ModuleExpression = {\n    type: \"ModuleExpression\",\n    body,\n  };\n  const defs = NODE_FIELDS.ModuleExpression;\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function topicReference(): t.TopicReference {\n  return {\n    type: \"TopicReference\",\n  };\n}\nexport function pipelineTopicExpression(\n  expression: t.Expression,\n): t.PipelineTopicExpression {\n  const node: t.PipelineTopicExpression = {\n    type: \"PipelineTopicExpression\",\n    expression,\n  };\n  const defs = NODE_FIELDS.PipelineTopicExpression;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nexport function pipelineBareFunction(\n  callee: t.Expression,\n): t.PipelineBareFunction {\n  const node: t.PipelineBareFunction = {\n    type: \"PipelineBareFunction\",\n    callee,\n  };\n  const defs = NODE_FIELDS.PipelineBareFunction;\n  validate(defs.callee, node, \"callee\", callee, 1);\n  return node;\n}\nexport function pipelinePrimaryTopicReference(): t.PipelinePrimaryTopicReference {\n  return {\n    type: \"PipelinePrimaryTopicReference\",\n  };\n}\nexport function tsParameterProperty(\n  parameter: t.Identifier | t.AssignmentPattern,\n): t.TSParameterProperty {\n  const node: t.TSParameterProperty = {\n    type: \"TSParameterProperty\",\n    parameter,\n  };\n  const defs = NODE_FIELDS.TSParameterProperty;\n  validate(defs.parameter, node, \"parameter\", parameter, 1);\n  return node;\n}\nexport { tsParameterProperty as tSParameterProperty };\nexport function tsDeclareFunction(\n  id: t.Identifier | null | undefined = null,\n  typeParameters:\n    | t.TSTypeParameterDeclaration\n    | t.Noop\n    | null\n    | undefined = null,\n  params: Array<t.Identifier | t.Pattern | t.RestElement>,\n  returnType: t.TSTypeAnnotation | t.Noop | null = null,\n): t.TSDeclareFunction {\n  const node: t.TSDeclareFunction = {\n    type: \"TSDeclareFunction\",\n    id,\n    typeParameters,\n    params,\n    returnType,\n  };\n  const defs = NODE_FIELDS.TSDeclareFunction;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.returnType, node, \"returnType\", returnType, 1);\n  return node;\n}\nexport { tsDeclareFunction as tSDeclareFunction };\nexport function tsDeclareMethod(\n  decorators: Array<t.Decorator> | null | undefined = null,\n  key:\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.Expression,\n  typeParameters:\n    | t.TSTypeParameterDeclaration\n    | t.Noop\n    | null\n    | undefined = null,\n  params: Array<\n    t.Identifier | t.Pattern | t.RestElement | t.TSParameterProperty\n  >,\n  returnType: t.TSTypeAnnotation | t.Noop | null = null,\n): t.TSDeclareMethod {\n  const node: t.TSDeclareMethod = {\n    type: \"TSDeclareMethod\",\n    decorators,\n    key,\n    typeParameters,\n    params,\n    returnType,\n  };\n  const defs = NODE_FIELDS.TSDeclareMethod;\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.returnType, node, \"returnType\", returnType, 1);\n  return node;\n}\nexport { tsDeclareMethod as tSDeclareMethod };\nexport function tsQualifiedName(\n  left: t.TSEntityName,\n  right: t.Identifier,\n): t.TSQualifiedName {\n  const node: t.TSQualifiedName = {\n    type: \"TSQualifiedName\",\n    left,\n    right,\n  };\n  const defs = NODE_FIELDS.TSQualifiedName;\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nexport { tsQualifiedName as tSQualifiedName };\nexport function tsCallSignatureDeclaration(\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,\n  parameters: Array<\n    t.ArrayPattern | t.Identifier | t.ObjectPattern | t.RestElement\n  >,\n  typeAnnotation: t.TSTypeAnnotation | null = null,\n): t.TSCallSignatureDeclaration {\n  const node: t.TSCallSignatureDeclaration = {\n    type: \"TSCallSignatureDeclaration\",\n    typeParameters,\n    parameters,\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TSCallSignatureDeclaration;\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.parameters, node, \"parameters\", parameters, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport { tsCallSignatureDeclaration as tSCallSignatureDeclaration };\nexport function tsConstructSignatureDeclaration(\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,\n  parameters: Array<\n    t.ArrayPattern | t.Identifier | t.ObjectPattern | t.RestElement\n  >,\n  typeAnnotation: t.TSTypeAnnotation | null = null,\n): t.TSConstructSignatureDeclaration {\n  const node: t.TSConstructSignatureDeclaration = {\n    type: \"TSConstructSignatureDeclaration\",\n    typeParameters,\n    parameters,\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TSConstructSignatureDeclaration;\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.parameters, node, \"parameters\", parameters, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport { tsConstructSignatureDeclaration as tSConstructSignatureDeclaration };\nexport function tsPropertySignature(\n  key: t.Expression,\n  typeAnnotation: t.TSTypeAnnotation | null = null,\n): t.TSPropertySignature {\n  const node: t.TSPropertySignature = {\n    type: \"TSPropertySignature\",\n    key,\n    typeAnnotation,\n    kind: null,\n  };\n  const defs = NODE_FIELDS.TSPropertySignature;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport { tsPropertySignature as tSPropertySignature };\nexport function tsMethodSignature(\n  key: t.Expression,\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,\n  parameters: Array<\n    t.ArrayPattern | t.Identifier | t.ObjectPattern | t.RestElement\n  >,\n  typeAnnotation: t.TSTypeAnnotation | null = null,\n): t.TSMethodSignature {\n  const node: t.TSMethodSignature = {\n    type: \"TSMethodSignature\",\n    key,\n    typeParameters,\n    parameters,\n    typeAnnotation,\n    kind: null,\n  };\n  const defs = NODE_FIELDS.TSMethodSignature;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.parameters, node, \"parameters\", parameters, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport { tsMethodSignature as tSMethodSignature };\nexport function tsIndexSignature(\n  parameters: Array<t.Identifier>,\n  typeAnnotation: t.TSTypeAnnotation | null = null,\n): t.TSIndexSignature {\n  const node: t.TSIndexSignature = {\n    type: \"TSIndexSignature\",\n    parameters,\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TSIndexSignature;\n  validate(defs.parameters, node, \"parameters\", parameters, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport { tsIndexSignature as tSIndexSignature };\nexport function tsAnyKeyword(): t.TSAnyKeyword {\n  return {\n    type: \"TSAnyKeyword\",\n  };\n}\nexport { tsAnyKeyword as tSAnyKeyword };\nexport function tsBooleanKeyword(): t.TSBooleanKeyword {\n  return {\n    type: \"TSBooleanKeyword\",\n  };\n}\nexport { tsBooleanKeyword as tSBooleanKeyword };\nexport function tsBigIntKeyword(): t.TSBigIntKeyword {\n  return {\n    type: \"TSBigIntKeyword\",\n  };\n}\nexport { tsBigIntKeyword as tSBigIntKeyword };\nexport function tsIntrinsicKeyword(): t.TSIntrinsicKeyword {\n  return {\n    type: \"TSIntrinsicKeyword\",\n  };\n}\nexport { tsIntrinsicKeyword as tSIntrinsicKeyword };\nexport function tsNeverKeyword(): t.TSNeverKeyword {\n  return {\n    type: \"TSNeverKeyword\",\n  };\n}\nexport { tsNeverKeyword as tSNeverKeyword };\nexport function tsNullKeyword(): t.TSNullKeyword {\n  return {\n    type: \"TSNullKeyword\",\n  };\n}\nexport { tsNullKeyword as tSNullKeyword };\nexport function tsNumberKeyword(): t.TSNumberKeyword {\n  return {\n    type: \"TSNumberKeyword\",\n  };\n}\nexport { tsNumberKeyword as tSNumberKeyword };\nexport function tsObjectKeyword(): t.TSObjectKeyword {\n  return {\n    type: \"TSObjectKeyword\",\n  };\n}\nexport { tsObjectKeyword as tSObjectKeyword };\nexport function tsStringKeyword(): t.TSStringKeyword {\n  return {\n    type: \"TSStringKeyword\",\n  };\n}\nexport { tsStringKeyword as tSStringKeyword };\nexport function tsSymbolKeyword(): t.TSSymbolKeyword {\n  return {\n    type: \"TSSymbolKeyword\",\n  };\n}\nexport { tsSymbolKeyword as tSSymbolKeyword };\nexport function tsUndefinedKeyword(): t.TSUndefinedKeyword {\n  return {\n    type: \"TSUndefinedKeyword\",\n  };\n}\nexport { tsUndefinedKeyword as tSUndefinedKeyword };\nexport function tsUnknownKeyword(): t.TSUnknownKeyword {\n  return {\n    type: \"TSUnknownKeyword\",\n  };\n}\nexport { tsUnknownKeyword as tSUnknownKeyword };\nexport function tsVoidKeyword(): t.TSVoidKeyword {\n  return {\n    type: \"TSVoidKeyword\",\n  };\n}\nexport { tsVoidKeyword as tSVoidKeyword };\nexport function tsThisType(): t.TSThisType {\n  return {\n    type: \"TSThisType\",\n  };\n}\nexport { tsThisType as tSThisType };\nexport function tsFunctionType(\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,\n  parameters: Array<\n    t.ArrayPattern | t.Identifier | t.ObjectPattern | t.RestElement\n  >,\n  typeAnnotation: t.TSTypeAnnotation | null = null,\n): t.TSFunctionType {\n  const node: t.TSFunctionType = {\n    type: \"TSFunctionType\",\n    typeParameters,\n    parameters,\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TSFunctionType;\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.parameters, node, \"parameters\", parameters, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport { tsFunctionType as tSFunctionType };\nexport function tsConstructorType(\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,\n  parameters: Array<\n    t.ArrayPattern | t.Identifier | t.ObjectPattern | t.RestElement\n  >,\n  typeAnnotation: t.TSTypeAnnotation | null = null,\n): t.TSConstructorType {\n  const node: t.TSConstructorType = {\n    type: \"TSConstructorType\",\n    typeParameters,\n    parameters,\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TSConstructorType;\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.parameters, node, \"parameters\", parameters, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport { tsConstructorType as tSConstructorType };\nexport function tsTypeReference(\n  typeName: t.TSEntityName,\n  typeParameters: t.TSTypeParameterInstantiation | null = null,\n): t.TSTypeReference {\n  const node: t.TSTypeReference = {\n    type: \"TSTypeReference\",\n    typeName,\n    typeParameters,\n  };\n  const defs = NODE_FIELDS.TSTypeReference;\n  validate(defs.typeName, node, \"typeName\", typeName, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  return node;\n}\nexport { tsTypeReference as tSTypeReference };\nexport function tsTypePredicate(\n  parameterName: t.Identifier | t.TSThisType,\n  typeAnnotation: t.TSTypeAnnotation | null = null,\n  asserts: boolean | null = null,\n): t.TSTypePredicate {\n  const node: t.TSTypePredicate = {\n    type: \"TSTypePredicate\",\n    parameterName,\n    typeAnnotation,\n    asserts,\n  };\n  const defs = NODE_FIELDS.TSTypePredicate;\n  validate(defs.parameterName, node, \"parameterName\", parameterName, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  validate(defs.asserts, node, \"asserts\", asserts);\n  return node;\n}\nexport { tsTypePredicate as tSTypePredicate };\nexport function tsTypeQuery(\n  exprName: t.TSEntityName | t.TSImportType,\n  typeParameters: t.TSTypeParameterInstantiation | null = null,\n): t.TSTypeQuery {\n  const node: t.TSTypeQuery = {\n    type: \"TSTypeQuery\",\n    exprName,\n    typeParameters,\n  };\n  const defs = NODE_FIELDS.TSTypeQuery;\n  validate(defs.exprName, node, \"exprName\", exprName, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  return node;\n}\nexport { tsTypeQuery as tSTypeQuery };\nexport function tsTypeLiteral(\n  members: Array<t.TSTypeElement>,\n): t.TSTypeLiteral {\n  const node: t.TSTypeLiteral = {\n    type: \"TSTypeLiteral\",\n    members,\n  };\n  const defs = NODE_FIELDS.TSTypeLiteral;\n  validate(defs.members, node, \"members\", members, 1);\n  return node;\n}\nexport { tsTypeLiteral as tSTypeLiteral };\nexport function tsArrayType(elementType: t.TSType): t.TSArrayType {\n  const node: t.TSArrayType = {\n    type: \"TSArrayType\",\n    elementType,\n  };\n  const defs = NODE_FIELDS.TSArrayType;\n  validate(defs.elementType, node, \"elementType\", elementType, 1);\n  return node;\n}\nexport { tsArrayType as tSArrayType };\nexport function tsTupleType(\n  elementTypes: Array<t.TSType | t.TSNamedTupleMember>,\n): t.TSTupleType {\n  const node: t.TSTupleType = {\n    type: \"TSTupleType\",\n    elementTypes,\n  };\n  const defs = NODE_FIELDS.TSTupleType;\n  validate(defs.elementTypes, node, \"elementTypes\", elementTypes, 1);\n  return node;\n}\nexport { tsTupleType as tSTupleType };\nexport function tsOptionalType(typeAnnotation: t.TSType): t.TSOptionalType {\n  const node: t.TSOptionalType = {\n    type: \"TSOptionalType\",\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TSOptionalType;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport { tsOptionalType as tSOptionalType };\nexport function tsRestType(typeAnnotation: t.TSType): t.TSRestType {\n  const node: t.TSRestType = {\n    type: \"TSRestType\",\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TSRestType;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport { tsRestType as tSRestType };\nexport function tsNamedTupleMember(\n  label: t.Identifier,\n  elementType: t.TSType,\n  optional: boolean = false,\n): t.TSNamedTupleMember {\n  const node: t.TSNamedTupleMember = {\n    type: \"TSNamedTupleMember\",\n    label,\n    elementType,\n    optional,\n  };\n  const defs = NODE_FIELDS.TSNamedTupleMember;\n  validate(defs.label, node, \"label\", label, 1);\n  validate(defs.elementType, node, \"elementType\", elementType, 1);\n  validate(defs.optional, node, \"optional\", optional);\n  return node;\n}\nexport { tsNamedTupleMember as tSNamedTupleMember };\nexport function tsUnionType(types: Array<t.TSType>): t.TSUnionType {\n  const node: t.TSUnionType = {\n    type: \"TSUnionType\",\n    types,\n  };\n  const defs = NODE_FIELDS.TSUnionType;\n  validate(defs.types, node, \"types\", types, 1);\n  return node;\n}\nexport { tsUnionType as tSUnionType };\nexport function tsIntersectionType(\n  types: Array<t.TSType>,\n): t.TSIntersectionType {\n  const node: t.TSIntersectionType = {\n    type: \"TSIntersectionType\",\n    types,\n  };\n  const defs = NODE_FIELDS.TSIntersectionType;\n  validate(defs.types, node, \"types\", types, 1);\n  return node;\n}\nexport { tsIntersectionType as tSIntersectionType };\nexport function tsConditionalType(\n  checkType: t.TSType,\n  extendsType: t.TSType,\n  trueType: t.TSType,\n  falseType: t.TSType,\n): t.TSConditionalType {\n  const node: t.TSConditionalType = {\n    type: \"TSConditionalType\",\n    checkType,\n    extendsType,\n    trueType,\n    falseType,\n  };\n  const defs = NODE_FIELDS.TSConditionalType;\n  validate(defs.checkType, node, \"checkType\", checkType, 1);\n  validate(defs.extendsType, node, \"extendsType\", extendsType, 1);\n  validate(defs.trueType, node, \"trueType\", trueType, 1);\n  validate(defs.falseType, node, \"falseType\", falseType, 1);\n  return node;\n}\nexport { tsConditionalType as tSConditionalType };\nexport function tsInferType(typeParameter: t.TSTypeParameter): t.TSInferType {\n  const node: t.TSInferType = {\n    type: \"TSInferType\",\n    typeParameter,\n  };\n  const defs = NODE_FIELDS.TSInferType;\n  validate(defs.typeParameter, node, \"typeParameter\", typeParameter, 1);\n  return node;\n}\nexport { tsInferType as tSInferType };\nexport function tsParenthesizedType(\n  typeAnnotation: t.TSType,\n): t.TSParenthesizedType {\n  const node: t.TSParenthesizedType = {\n    type: \"TSParenthesizedType\",\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TSParenthesizedType;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport { tsParenthesizedType as tSParenthesizedType };\nexport function tsTypeOperator(typeAnnotation: t.TSType): t.TSTypeOperator {\n  const node: t.TSTypeOperator = {\n    type: \"TSTypeOperator\",\n    typeAnnotation,\n    operator: null,\n  };\n  const defs = NODE_FIELDS.TSTypeOperator;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport { tsTypeOperator as tSTypeOperator };\nexport function tsIndexedAccessType(\n  objectType: t.TSType,\n  indexType: t.TSType,\n): t.TSIndexedAccessType {\n  const node: t.TSIndexedAccessType = {\n    type: \"TSIndexedAccessType\",\n    objectType,\n    indexType,\n  };\n  const defs = NODE_FIELDS.TSIndexedAccessType;\n  validate(defs.objectType, node, \"objectType\", objectType, 1);\n  validate(defs.indexType, node, \"indexType\", indexType, 1);\n  return node;\n}\nexport { tsIndexedAccessType as tSIndexedAccessType };\nexport function tsMappedType(\n  typeParameter: t.TSTypeParameter,\n  typeAnnotation: t.TSType | null = null,\n  nameType: t.TSType | null = null,\n): t.TSMappedType {\n  const node: t.TSMappedType = {\n    type: \"TSMappedType\",\n    typeParameter,\n    typeAnnotation,\n    nameType,\n  };\n  const defs = NODE_FIELDS.TSMappedType;\n  validate(defs.typeParameter, node, \"typeParameter\", typeParameter, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  validate(defs.nameType, node, \"nameType\", nameType, 1);\n  return node;\n}\nexport { tsMappedType as tSMappedType };\nexport function tsLiteralType(\n  literal:\n    | t.NumericLiteral\n    | t.StringLiteral\n    | t.BooleanLiteral\n    | t.BigIntLiteral\n    | t.TemplateLiteral\n    | t.UnaryExpression,\n): t.TSLiteralType {\n  const node: t.TSLiteralType = {\n    type: \"TSLiteralType\",\n    literal,\n  };\n  const defs = NODE_FIELDS.TSLiteralType;\n  validate(defs.literal, node, \"literal\", literal, 1);\n  return node;\n}\nexport { tsLiteralType as tSLiteralType };\nexport function tsExpressionWithTypeArguments(\n  expression: t.TSEntityName,\n  typeParameters: t.TSTypeParameterInstantiation | null = null,\n): t.TSExpressionWithTypeArguments {\n  const node: t.TSExpressionWithTypeArguments = {\n    type: \"TSExpressionWithTypeArguments\",\n    expression,\n    typeParameters,\n  };\n  const defs = NODE_FIELDS.TSExpressionWithTypeArguments;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  return node;\n}\nexport { tsExpressionWithTypeArguments as tSExpressionWithTypeArguments };\nexport function tsInterfaceDeclaration(\n  id: t.Identifier,\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,\n  _extends: Array<t.TSExpressionWithTypeArguments> | null | undefined = null,\n  body: t.TSInterfaceBody,\n): t.TSInterfaceDeclaration {\n  const node: t.TSInterfaceDeclaration = {\n    type: \"TSInterfaceDeclaration\",\n    id,\n    typeParameters,\n    extends: _extends,\n    body,\n  };\n  const defs = NODE_FIELDS.TSInterfaceDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.extends, node, \"extends\", _extends, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport { tsInterfaceDeclaration as tSInterfaceDeclaration };\nexport function tsInterfaceBody(\n  body: Array<t.TSTypeElement>,\n): t.TSInterfaceBody {\n  const node: t.TSInterfaceBody = {\n    type: \"TSInterfaceBody\",\n    body,\n  };\n  const defs = NODE_FIELDS.TSInterfaceBody;\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport { tsInterfaceBody as tSInterfaceBody };\nexport function tsTypeAliasDeclaration(\n  id: t.Identifier,\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,\n  typeAnnotation: t.TSType,\n): t.TSTypeAliasDeclaration {\n  const node: t.TSTypeAliasDeclaration = {\n    type: \"TSTypeAliasDeclaration\",\n    id,\n    typeParameters,\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TSTypeAliasDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport { tsTypeAliasDeclaration as tSTypeAliasDeclaration };\nexport function tsInstantiationExpression(\n  expression: t.Expression,\n  typeParameters: t.TSTypeParameterInstantiation | null = null,\n): t.TSInstantiationExpression {\n  const node: t.TSInstantiationExpression = {\n    type: \"TSInstantiationExpression\",\n    expression,\n    typeParameters,\n  };\n  const defs = NODE_FIELDS.TSInstantiationExpression;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  return node;\n}\nexport { tsInstantiationExpression as tSInstantiationExpression };\nexport function tsAsExpression(\n  expression: t.Expression,\n  typeAnnotation: t.TSType,\n): t.TSAsExpression {\n  const node: t.TSAsExpression = {\n    type: \"TSAsExpression\",\n    expression,\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TSAsExpression;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport { tsAsExpression as tSAsExpression };\nexport function tsSatisfiesExpression(\n  expression: t.Expression,\n  typeAnnotation: t.TSType,\n): t.TSSatisfiesExpression {\n  const node: t.TSSatisfiesExpression = {\n    type: \"TSSatisfiesExpression\",\n    expression,\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TSSatisfiesExpression;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport { tsSatisfiesExpression as tSSatisfiesExpression };\nexport function tsTypeAssertion(\n  typeAnnotation: t.TSType,\n  expression: t.Expression,\n): t.TSTypeAssertion {\n  const node: t.TSTypeAssertion = {\n    type: \"TSTypeAssertion\",\n    typeAnnotation,\n    expression,\n  };\n  const defs = NODE_FIELDS.TSTypeAssertion;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nexport { tsTypeAssertion as tSTypeAssertion };\nexport function tsEnumDeclaration(\n  id: t.Identifier,\n  members: Array<t.TSEnumMember>,\n): t.TSEnumDeclaration {\n  const node: t.TSEnumDeclaration = {\n    type: \"TSEnumDeclaration\",\n    id,\n    members,\n  };\n  const defs = NODE_FIELDS.TSEnumDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.members, node, \"members\", members, 1);\n  return node;\n}\nexport { tsEnumDeclaration as tSEnumDeclaration };\nexport function tsEnumMember(\n  id: t.Identifier | t.StringLiteral,\n  initializer: t.Expression | null = null,\n): t.TSEnumMember {\n  const node: t.TSEnumMember = {\n    type: \"TSEnumMember\",\n    id,\n    initializer,\n  };\n  const defs = NODE_FIELDS.TSEnumMember;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.initializer, node, \"initializer\", initializer, 1);\n  return node;\n}\nexport { tsEnumMember as tSEnumMember };\nexport function tsModuleDeclaration(\n  id: t.Identifier | t.StringLiteral,\n  body: t.TSModuleBlock | t.TSModuleDeclaration,\n): t.TSModuleDeclaration {\n  const node: t.TSModuleDeclaration = {\n    type: \"TSModuleDeclaration\",\n    id,\n    body,\n    kind: null,\n  };\n  const defs = NODE_FIELDS.TSModuleDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport { tsModuleDeclaration as tSModuleDeclaration };\nexport function tsModuleBlock(body: Array<t.Statement>): t.TSModuleBlock {\n  const node: t.TSModuleBlock = {\n    type: \"TSModuleBlock\",\n    body,\n  };\n  const defs = NODE_FIELDS.TSModuleBlock;\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport { tsModuleBlock as tSModuleBlock };\nexport function tsImportType(\n  argument: t.StringLiteral,\n  qualifier: t.TSEntityName | null = null,\n  typeParameters: t.TSTypeParameterInstantiation | null = null,\n): t.TSImportType {\n  const node: t.TSImportType = {\n    type: \"TSImportType\",\n    argument,\n    qualifier,\n    typeParameters,\n  };\n  const defs = NODE_FIELDS.TSImportType;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  validate(defs.qualifier, node, \"qualifier\", qualifier, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  return node;\n}\nexport { tsImportType as tSImportType };\nexport function tsImportEqualsDeclaration(\n  id: t.Identifier,\n  moduleReference: t.TSEntityName | t.TSExternalModuleReference,\n): t.TSImportEqualsDeclaration {\n  const node: t.TSImportEqualsDeclaration = {\n    type: \"TSImportEqualsDeclaration\",\n    id,\n    moduleReference,\n    isExport: null,\n  };\n  const defs = NODE_FIELDS.TSImportEqualsDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.moduleReference, node, \"moduleReference\", moduleReference, 1);\n  return node;\n}\nexport { tsImportEqualsDeclaration as tSImportEqualsDeclaration };\nexport function tsExternalModuleReference(\n  expression: t.StringLiteral,\n): t.TSExternalModuleReference {\n  const node: t.TSExternalModuleReference = {\n    type: \"TSExternalModuleReference\",\n    expression,\n  };\n  const defs = NODE_FIELDS.TSExternalModuleReference;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nexport { tsExternalModuleReference as tSExternalModuleReference };\nexport function tsNonNullExpression(\n  expression: t.Expression,\n): t.TSNonNullExpression {\n  const node: t.TSNonNullExpression = {\n    type: \"TSNonNullExpression\",\n    expression,\n  };\n  const defs = NODE_FIELDS.TSNonNullExpression;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nexport { tsNonNullExpression as tSNonNullExpression };\nexport function tsExportAssignment(\n  expression: t.Expression,\n): t.TSExportAssignment {\n  const node: t.TSExportAssignment = {\n    type: \"TSExportAssignment\",\n    expression,\n  };\n  const defs = NODE_FIELDS.TSExportAssignment;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nexport { tsExportAssignment as tSExportAssignment };\nexport function tsNamespaceExportDeclaration(\n  id: t.Identifier,\n): t.TSNamespaceExportDeclaration {\n  const node: t.TSNamespaceExportDeclaration = {\n    type: \"TSNamespaceExportDeclaration\",\n    id,\n  };\n  const defs = NODE_FIELDS.TSNamespaceExportDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  return node;\n}\nexport { tsNamespaceExportDeclaration as tSNamespaceExportDeclaration };\nexport function tsTypeAnnotation(typeAnnotation: t.TSType): t.TSTypeAnnotation {\n  const node: t.TSTypeAnnotation = {\n    type: \"TSTypeAnnotation\",\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TSTypeAnnotation;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport { tsTypeAnnotation as tSTypeAnnotation };\nexport function tsTypeParameterInstantiation(\n  params: Array<t.TSType>,\n): t.TSTypeParameterInstantiation {\n  const node: t.TSTypeParameterInstantiation = {\n    type: \"TSTypeParameterInstantiation\",\n    params,\n  };\n  const defs = NODE_FIELDS.TSTypeParameterInstantiation;\n  validate(defs.params, node, \"params\", params, 1);\n  return node;\n}\nexport { tsTypeParameterInstantiation as tSTypeParameterInstantiation };\nexport function tsTypeParameterDeclaration(\n  params: Array<t.TSTypeParameter>,\n): t.TSTypeParameterDeclaration {\n  const node: t.TSTypeParameterDeclaration = {\n    type: \"TSTypeParameterDeclaration\",\n    params,\n  };\n  const defs = NODE_FIELDS.TSTypeParameterDeclaration;\n  validate(defs.params, node, \"params\", params, 1);\n  return node;\n}\nexport { tsTypeParameterDeclaration as tSTypeParameterDeclaration };\nexport function tsTypeParameter(\n  constraint: t.TSType | null | undefined = null,\n  _default: t.TSType | null | undefined = null,\n  name: string,\n): t.TSTypeParameter {\n  const node: t.TSTypeParameter = {\n    type: \"TSTypeParameter\",\n    constraint,\n    default: _default,\n    name,\n  };\n  const defs = NODE_FIELDS.TSTypeParameter;\n  validate(defs.constraint, node, \"constraint\", constraint, 1);\n  validate(defs.default, node, \"default\", _default, 1);\n  validate(defs.name, node, \"name\", name);\n  return node;\n}\nexport { tsTypeParameter as tSTypeParameter };\n/** @deprecated */\nfunction NumberLiteral(value: number) {\n  deprecationWarning(\"NumberLiteral\", \"NumericLiteral\", \"The node type \");\n  return numericLiteral(value);\n}\nexport { NumberLiteral as numberLiteral };\n/** @deprecated */\nfunction RegexLiteral(pattern: string, flags: string = \"\") {\n  deprecationWarning(\"RegexLiteral\", \"RegExpLiteral\", \"The node type \");\n  return regExpLiteral(pattern, flags);\n}\nexport { RegexLiteral as regexLiteral };\n/** @deprecated */\nfunction RestProperty(argument: t.LVal) {\n  deprecationWarning(\"RestProperty\", \"RestElement\", \"The node type \");\n  return restElement(argument);\n}\nexport { RestProperty as restProperty };\n/** @deprecated */\nfunction SpreadProperty(argument: t.Expression) {\n  deprecationWarning(\"SpreadProperty\", \"SpreadElement\", \"The node type \");\n  return spreadElement(argument);\n}\nexport { SpreadProperty as spreadProperty };\n", "import { stringLiteral } from \"../../builders/generated/index.ts\";\nimport type * as t from \"../../index.ts\";\nimport { inherits } from \"../../index.ts\";\n\nexport default function cleanJSXElementLiteralChild(\n  child: t.JSXText,\n  args: Array<t.Node>,\n) {\n  const lines = child.value.split(/\\r\\n|\\n|\\r/);\n\n  let lastNonEmptyLine = 0;\n\n  for (let i = 0; i < lines.length; i++) {\n    if (/[^ \\t]/.exec(lines[i])) {\n      lastNonEmptyLine = i;\n    }\n  }\n\n  let str = \"\";\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n\n    const isFirstLine = i === 0;\n    const isLastLine = i === lines.length - 1;\n    const isLastNonEmptyLine = i === lastNonEmptyLine;\n\n    // replace rendered whitespace tabs with spaces\n    let trimmedLine = line.replace(/\\t/g, \" \");\n\n    // trim whitespace touching a newline\n    if (!isFirstLine) {\n      trimmedLine = trimmedLine.replace(/^ +/, \"\");\n    }\n\n    // trim whitespace touching an endline\n    if (!isLastLine) {\n      trimmedLine = trimmedLine.replace(/ +$/, \"\");\n    }\n\n    if (trimmedLine) {\n      if (!isLastNonEmptyLine) {\n        trimmedLine += \" \";\n      }\n\n      str += trimmedLine;\n    }\n  }\n\n  if (str) args.push(inherits(stringLiteral(str), child));\n}\n", "import {\n  isJSXText,\n  isJSXExpressionContainer,\n  isJSXEmptyExpression,\n} from \"../../validators/generated/index.ts\";\nimport cleanJSXElementLiteralChild from \"../../utils/react/cleanJSXElementLiteralChild.ts\";\nimport type * as t from \"../../index.ts\";\n\ntype ReturnedChild =\n  | t.JSXSpreadChild\n  | t.JSXElement\n  | t.JSXFragment\n  | t.Expression;\n\nexport default function buildChildren(\n  node: t.JSXElement | t.JSXFragment,\n): ReturnedChild[] {\n  const elements = [];\n\n  for (let i = 0; i < node.children.length; i++) {\n    let child: any = node.children[i];\n\n    if (isJSXText(child)) {\n      cleanJSXElementLiteralChild(child, elements);\n      continue;\n    }\n\n    if (isJSXExpressionContainer(child)) child = child.expression;\n    if (isJSXEmptyExpression(child)) continue;\n\n    elements.push(child);\n  }\n\n  return elements;\n}\n", "import { VISITOR_KEYS } from \"../definitions/index.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default function isNode(node: any): node is t.Node {\n  return !!(node && VISITOR_KEYS[node.type]);\n}\n", "import isNode from \"../validators/isNode.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default function assertNode(node?: any): asserts node is t.Node {\n  if (!isNode(node)) {\n    const type = node?.type ?? JSON.stringify(node);\n    throw new TypeError(`Not a valid node of type \"${type}\"`);\n  }\n}\n", "/*\n * This file is auto-generated! Do not modify it directly.\n * To re-generate run 'make build'\n */\nimport is from \"../../validators/is.ts\";\nimport type * as t from \"../../index.ts\";\nimport deprecationWarning from \"../../utils/deprecationWarning.ts\";\n\nfunction assert(type: string, node: any, opts?: any): void {\n  if (!is(type, node, opts)) {\n    throw new Error(\n      `Expected type \"${type}\" with option ${JSON.stringify(opts)}, ` +\n        `but instead got \"${node.type}\".`,\n    );\n  }\n}\n\nexport function assertArrayExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ArrayExpression {\n  assert(\"ArrayExpression\", node, opts);\n}\nexport function assertAssignmentExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.AssignmentExpression {\n  assert(\"AssignmentExpression\", node, opts);\n}\nexport function assertBinaryExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.BinaryExpression {\n  assert(\"BinaryExpression\", node, opts);\n}\nexport function assertInterpreterDirective(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.InterpreterDirective {\n  assert(\"InterpreterDirective\", node, opts);\n}\nexport function assertDirective(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Directive {\n  assert(\"Directive\", node, opts);\n}\nexport function assertDirectiveLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DirectiveLiteral {\n  assert(\"DirectiveLiteral\", node, opts);\n}\nexport function assertBlockStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.BlockStatement {\n  assert(\"BlockStatement\", node, opts);\n}\nexport function assertBreakStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.BreakStatement {\n  assert(\"BreakStatement\", node, opts);\n}\nexport function assertCallExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.CallExpression {\n  assert(\"CallExpression\", node, opts);\n}\nexport function assertCatchClause(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.CatchClause {\n  assert(\"CatchClause\", node, opts);\n}\nexport function assertConditionalExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ConditionalExpression {\n  assert(\"ConditionalExpression\", node, opts);\n}\nexport function assertContinueStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ContinueStatement {\n  assert(\"ContinueStatement\", node, opts);\n}\nexport function assertDebuggerStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DebuggerStatement {\n  assert(\"DebuggerStatement\", node, opts);\n}\nexport function assertDoWhileStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DoWhileStatement {\n  assert(\"DoWhileStatement\", node, opts);\n}\nexport function assertEmptyStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EmptyStatement {\n  assert(\"EmptyStatement\", node, opts);\n}\nexport function assertExpressionStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ExpressionStatement {\n  assert(\"ExpressionStatement\", node, opts);\n}\nexport function assertFile(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.File {\n  assert(\"File\", node, opts);\n}\nexport function assertForInStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ForInStatement {\n  assert(\"ForInStatement\", node, opts);\n}\nexport function assertForStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ForStatement {\n  assert(\"ForStatement\", node, opts);\n}\nexport function assertFunctionDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.FunctionDeclaration {\n  assert(\"FunctionDeclaration\", node, opts);\n}\nexport function assertFunctionExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.FunctionExpression {\n  assert(\"FunctionExpression\", node, opts);\n}\nexport function assertIdentifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Identifier {\n  assert(\"Identifier\", node, opts);\n}\nexport function assertIfStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.IfStatement {\n  assert(\"IfStatement\", node, opts);\n}\nexport function assertLabeledStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.LabeledStatement {\n  assert(\"LabeledStatement\", node, opts);\n}\nexport function assertStringLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.StringLiteral {\n  assert(\"StringLiteral\", node, opts);\n}\nexport function assertNumericLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.NumericLiteral {\n  assert(\"NumericLiteral\", node, opts);\n}\nexport function assertNullLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.NullLiteral {\n  assert(\"NullLiteral\", node, opts);\n}\nexport function assertBooleanLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.BooleanLiteral {\n  assert(\"BooleanLiteral\", node, opts);\n}\nexport function assertRegExpLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.RegExpLiteral {\n  assert(\"RegExpLiteral\", node, opts);\n}\nexport function assertLogicalExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.LogicalExpression {\n  assert(\"LogicalExpression\", node, opts);\n}\nexport function assertMemberExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.MemberExpression {\n  assert(\"MemberExpression\", node, opts);\n}\nexport function assertNewExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.NewExpression {\n  assert(\"NewExpression\", node, opts);\n}\nexport function assertProgram(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Program {\n  assert(\"Program\", node, opts);\n}\nexport function assertObjectExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ObjectExpression {\n  assert(\"ObjectExpression\", node, opts);\n}\nexport function assertObjectMethod(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ObjectMethod {\n  assert(\"ObjectMethod\", node, opts);\n}\nexport function assertObjectProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ObjectProperty {\n  assert(\"ObjectProperty\", node, opts);\n}\nexport function assertRestElement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.RestElement {\n  assert(\"RestElement\", node, opts);\n}\nexport function assertReturnStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ReturnStatement {\n  assert(\"ReturnStatement\", node, opts);\n}\nexport function assertSequenceExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.SequenceExpression {\n  assert(\"SequenceExpression\", node, opts);\n}\nexport function assertParenthesizedExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ParenthesizedExpression {\n  assert(\"ParenthesizedExpression\", node, opts);\n}\nexport function assertSwitchCase(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.SwitchCase {\n  assert(\"SwitchCase\", node, opts);\n}\nexport function assertSwitchStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.SwitchStatement {\n  assert(\"SwitchStatement\", node, opts);\n}\nexport function assertThisExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ThisExpression {\n  assert(\"ThisExpression\", node, opts);\n}\nexport function assertThrowStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ThrowStatement {\n  assert(\"ThrowStatement\", node, opts);\n}\nexport function assertTryStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TryStatement {\n  assert(\"TryStatement\", node, opts);\n}\nexport function assertUnaryExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.UnaryExpression {\n  assert(\"UnaryExpression\", node, opts);\n}\nexport function assertUpdateExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.UpdateExpression {\n  assert(\"UpdateExpression\", node, opts);\n}\nexport function assertVariableDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.VariableDeclaration {\n  assert(\"VariableDeclaration\", node, opts);\n}\nexport function assertVariableDeclarator(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.VariableDeclarator {\n  assert(\"VariableDeclarator\", node, opts);\n}\nexport function assertWhileStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.WhileStatement {\n  assert(\"WhileStatement\", node, opts);\n}\nexport function assertWithStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.WithStatement {\n  assert(\"WithStatement\", node, opts);\n}\nexport function assertAssignmentPattern(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.AssignmentPattern {\n  assert(\"AssignmentPattern\", node, opts);\n}\nexport function assertArrayPattern(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ArrayPattern {\n  assert(\"ArrayPattern\", node, opts);\n}\nexport function assertArrowFunctionExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ArrowFunctionExpression {\n  assert(\"ArrowFunctionExpression\", node, opts);\n}\nexport function assertClassBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ClassBody {\n  assert(\"ClassBody\", node, opts);\n}\nexport function assertClassExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ClassExpression {\n  assert(\"ClassExpression\", node, opts);\n}\nexport function assertClassDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ClassDeclaration {\n  assert(\"ClassDeclaration\", node, opts);\n}\nexport function assertExportAllDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ExportAllDeclaration {\n  assert(\"ExportAllDeclaration\", node, opts);\n}\nexport function assertExportDefaultDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ExportDefaultDeclaration {\n  assert(\"ExportDefaultDeclaration\", node, opts);\n}\nexport function assertExportNamedDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ExportNamedDeclaration {\n  assert(\"ExportNamedDeclaration\", node, opts);\n}\nexport function assertExportSpecifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ExportSpecifier {\n  assert(\"ExportSpecifier\", node, opts);\n}\nexport function assertForOfStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ForOfStatement {\n  assert(\"ForOfStatement\", node, opts);\n}\nexport function assertImportDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ImportDeclaration {\n  assert(\"ImportDeclaration\", node, opts);\n}\nexport function assertImportDefaultSpecifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ImportDefaultSpecifier {\n  assert(\"ImportDefaultSpecifier\", node, opts);\n}\nexport function assertImportNamespaceSpecifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ImportNamespaceSpecifier {\n  assert(\"ImportNamespaceSpecifier\", node, opts);\n}\nexport function assertImportSpecifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ImportSpecifier {\n  assert(\"ImportSpecifier\", node, opts);\n}\nexport function assertImportExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ImportExpression {\n  assert(\"ImportExpression\", node, opts);\n}\nexport function assertMetaProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.MetaProperty {\n  assert(\"MetaProperty\", node, opts);\n}\nexport function assertClassMethod(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ClassMethod {\n  assert(\"ClassMethod\", node, opts);\n}\nexport function assertObjectPattern(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ObjectPattern {\n  assert(\"ObjectPattern\", node, opts);\n}\nexport function assertSpreadElement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.SpreadElement {\n  assert(\"SpreadElement\", node, opts);\n}\nexport function assertSuper(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Super {\n  assert(\"Super\", node, opts);\n}\nexport function assertTaggedTemplateExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TaggedTemplateExpression {\n  assert(\"TaggedTemplateExpression\", node, opts);\n}\nexport function assertTemplateElement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TemplateElement {\n  assert(\"TemplateElement\", node, opts);\n}\nexport function assertTemplateLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TemplateLiteral {\n  assert(\"TemplateLiteral\", node, opts);\n}\nexport function assertYieldExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.YieldExpression {\n  assert(\"YieldExpression\", node, opts);\n}\nexport function assertAwaitExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.AwaitExpression {\n  assert(\"AwaitExpression\", node, opts);\n}\nexport function assertImport(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Import {\n  assert(\"Import\", node, opts);\n}\nexport function assertBigIntLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.BigIntLiteral {\n  assert(\"BigIntLiteral\", node, opts);\n}\nexport function assertExportNamespaceSpecifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ExportNamespaceSpecifier {\n  assert(\"ExportNamespaceSpecifier\", node, opts);\n}\nexport function assertOptionalMemberExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.OptionalMemberExpression {\n  assert(\"OptionalMemberExpression\", node, opts);\n}\nexport function assertOptionalCallExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.OptionalCallExpression {\n  assert(\"OptionalCallExpression\", node, opts);\n}\nexport function assertClassProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ClassProperty {\n  assert(\"ClassProperty\", node, opts);\n}\nexport function assertClassAccessorProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ClassAccessorProperty {\n  assert(\"ClassAccessorProperty\", node, opts);\n}\nexport function assertClassPrivateProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ClassPrivateProperty {\n  assert(\"ClassPrivateProperty\", node, opts);\n}\nexport function assertClassPrivateMethod(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ClassPrivateMethod {\n  assert(\"ClassPrivateMethod\", node, opts);\n}\nexport function assertPrivateName(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.PrivateName {\n  assert(\"PrivateName\", node, opts);\n}\nexport function assertStaticBlock(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.StaticBlock {\n  assert(\"StaticBlock\", node, opts);\n}\nexport function assertAnyTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.AnyTypeAnnotation {\n  assert(\"AnyTypeAnnotation\", node, opts);\n}\nexport function assertArrayTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ArrayTypeAnnotation {\n  assert(\"ArrayTypeAnnotation\", node, opts);\n}\nexport function assertBooleanTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.BooleanTypeAnnotation {\n  assert(\"BooleanTypeAnnotation\", node, opts);\n}\nexport function assertBooleanLiteralTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.BooleanLiteralTypeAnnotation {\n  assert(\"BooleanLiteralTypeAnnotation\", node, opts);\n}\nexport function assertNullLiteralTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.NullLiteralTypeAnnotation {\n  assert(\"NullLiteralTypeAnnotation\", node, opts);\n}\nexport function assertClassImplements(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ClassImplements {\n  assert(\"ClassImplements\", node, opts);\n}\nexport function assertDeclareClass(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DeclareClass {\n  assert(\"DeclareClass\", node, opts);\n}\nexport function assertDeclareFunction(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DeclareFunction {\n  assert(\"DeclareFunction\", node, opts);\n}\nexport function assertDeclareInterface(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DeclareInterface {\n  assert(\"DeclareInterface\", node, opts);\n}\nexport function assertDeclareModule(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DeclareModule {\n  assert(\"DeclareModule\", node, opts);\n}\nexport function assertDeclareModuleExports(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DeclareModuleExports {\n  assert(\"DeclareModuleExports\", node, opts);\n}\nexport function assertDeclareTypeAlias(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DeclareTypeAlias {\n  assert(\"DeclareTypeAlias\", node, opts);\n}\nexport function assertDeclareOpaqueType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DeclareOpaqueType {\n  assert(\"DeclareOpaqueType\", node, opts);\n}\nexport function assertDeclareVariable(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DeclareVariable {\n  assert(\"DeclareVariable\", node, opts);\n}\nexport function assertDeclareExportDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DeclareExportDeclaration {\n  assert(\"DeclareExportDeclaration\", node, opts);\n}\nexport function assertDeclareExportAllDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DeclareExportAllDeclaration {\n  assert(\"DeclareExportAllDeclaration\", node, opts);\n}\nexport function assertDeclaredPredicate(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DeclaredPredicate {\n  assert(\"DeclaredPredicate\", node, opts);\n}\nexport function assertExistsTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ExistsTypeAnnotation {\n  assert(\"ExistsTypeAnnotation\", node, opts);\n}\nexport function assertFunctionTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.FunctionTypeAnnotation {\n  assert(\"FunctionTypeAnnotation\", node, opts);\n}\nexport function assertFunctionTypeParam(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.FunctionTypeParam {\n  assert(\"FunctionTypeParam\", node, opts);\n}\nexport function assertGenericTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.GenericTypeAnnotation {\n  assert(\"GenericTypeAnnotation\", node, opts);\n}\nexport function assertInferredPredicate(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.InferredPredicate {\n  assert(\"InferredPredicate\", node, opts);\n}\nexport function assertInterfaceExtends(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.InterfaceExtends {\n  assert(\"InterfaceExtends\", node, opts);\n}\nexport function assertInterfaceDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.InterfaceDeclaration {\n  assert(\"InterfaceDeclaration\", node, opts);\n}\nexport function assertInterfaceTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.InterfaceTypeAnnotation {\n  assert(\"InterfaceTypeAnnotation\", node, opts);\n}\nexport function assertIntersectionTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.IntersectionTypeAnnotation {\n  assert(\"IntersectionTypeAnnotation\", node, opts);\n}\nexport function assertMixedTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.MixedTypeAnnotation {\n  assert(\"MixedTypeAnnotation\", node, opts);\n}\nexport function assertEmptyTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EmptyTypeAnnotation {\n  assert(\"EmptyTypeAnnotation\", node, opts);\n}\nexport function assertNullableTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.NullableTypeAnnotation {\n  assert(\"NullableTypeAnnotation\", node, opts);\n}\nexport function assertNumberLiteralTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.NumberLiteralTypeAnnotation {\n  assert(\"NumberLiteralTypeAnnotation\", node, opts);\n}\nexport function assertNumberTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.NumberTypeAnnotation {\n  assert(\"NumberTypeAnnotation\", node, opts);\n}\nexport function assertObjectTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ObjectTypeAnnotation {\n  assert(\"ObjectTypeAnnotation\", node, opts);\n}\nexport function assertObjectTypeInternalSlot(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ObjectTypeInternalSlot {\n  assert(\"ObjectTypeInternalSlot\", node, opts);\n}\nexport function assertObjectTypeCallProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ObjectTypeCallProperty {\n  assert(\"ObjectTypeCallProperty\", node, opts);\n}\nexport function assertObjectTypeIndexer(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ObjectTypeIndexer {\n  assert(\"ObjectTypeIndexer\", node, opts);\n}\nexport function assertObjectTypeProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ObjectTypeProperty {\n  assert(\"ObjectTypeProperty\", node, opts);\n}\nexport function assertObjectTypeSpreadProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ObjectTypeSpreadProperty {\n  assert(\"ObjectTypeSpreadProperty\", node, opts);\n}\nexport function assertOpaqueType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.OpaqueType {\n  assert(\"OpaqueType\", node, opts);\n}\nexport function assertQualifiedTypeIdentifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.QualifiedTypeIdentifier {\n  assert(\"QualifiedTypeIdentifier\", node, opts);\n}\nexport function assertStringLiteralTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.StringLiteralTypeAnnotation {\n  assert(\"StringLiteralTypeAnnotation\", node, opts);\n}\nexport function assertStringTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.StringTypeAnnotation {\n  assert(\"StringTypeAnnotation\", node, opts);\n}\nexport function assertSymbolTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.SymbolTypeAnnotation {\n  assert(\"SymbolTypeAnnotation\", node, opts);\n}\nexport function assertThisTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ThisTypeAnnotation {\n  assert(\"ThisTypeAnnotation\", node, opts);\n}\nexport function assertTupleTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TupleTypeAnnotation {\n  assert(\"TupleTypeAnnotation\", node, opts);\n}\nexport function assertTypeofTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TypeofTypeAnnotation {\n  assert(\"TypeofTypeAnnotation\", node, opts);\n}\nexport function assertTypeAlias(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TypeAlias {\n  assert(\"TypeAlias\", node, opts);\n}\nexport function assertTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TypeAnnotation {\n  assert(\"TypeAnnotation\", node, opts);\n}\nexport function assertTypeCastExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TypeCastExpression {\n  assert(\"TypeCastExpression\", node, opts);\n}\nexport function assertTypeParameter(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TypeParameter {\n  assert(\"TypeParameter\", node, opts);\n}\nexport function assertTypeParameterDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TypeParameterDeclaration {\n  assert(\"TypeParameterDeclaration\", node, opts);\n}\nexport function assertTypeParameterInstantiation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TypeParameterInstantiation {\n  assert(\"TypeParameterInstantiation\", node, opts);\n}\nexport function assertUnionTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.UnionTypeAnnotation {\n  assert(\"UnionTypeAnnotation\", node, opts);\n}\nexport function assertVariance(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Variance {\n  assert(\"Variance\", node, opts);\n}\nexport function assertVoidTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.VoidTypeAnnotation {\n  assert(\"VoidTypeAnnotation\", node, opts);\n}\nexport function assertEnumDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EnumDeclaration {\n  assert(\"EnumDeclaration\", node, opts);\n}\nexport function assertEnumBooleanBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EnumBooleanBody {\n  assert(\"EnumBooleanBody\", node, opts);\n}\nexport function assertEnumNumberBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EnumNumberBody {\n  assert(\"EnumNumberBody\", node, opts);\n}\nexport function assertEnumStringBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EnumStringBody {\n  assert(\"EnumStringBody\", node, opts);\n}\nexport function assertEnumSymbolBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EnumSymbolBody {\n  assert(\"EnumSymbolBody\", node, opts);\n}\nexport function assertEnumBooleanMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EnumBooleanMember {\n  assert(\"EnumBooleanMember\", node, opts);\n}\nexport function assertEnumNumberMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EnumNumberMember {\n  assert(\"EnumNumberMember\", node, opts);\n}\nexport function assertEnumStringMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EnumStringMember {\n  assert(\"EnumStringMember\", node, opts);\n}\nexport function assertEnumDefaultedMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EnumDefaultedMember {\n  assert(\"EnumDefaultedMember\", node, opts);\n}\nexport function assertIndexedAccessType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.IndexedAccessType {\n  assert(\"IndexedAccessType\", node, opts);\n}\nexport function assertOptionalIndexedAccessType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.OptionalIndexedAccessType {\n  assert(\"OptionalIndexedAccessType\", node, opts);\n}\nexport function assertJSXAttribute(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXAttribute {\n  assert(\"JSXAttribute\", node, opts);\n}\nexport function assertJSXClosingElement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXClosingElement {\n  assert(\"JSXClosingElement\", node, opts);\n}\nexport function assertJSXElement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXElement {\n  assert(\"JSXElement\", node, opts);\n}\nexport function assertJSXEmptyExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXEmptyExpression {\n  assert(\"JSXEmptyExpression\", node, opts);\n}\nexport function assertJSXExpressionContainer(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXExpressionContainer {\n  assert(\"JSXExpressionContainer\", node, opts);\n}\nexport function assertJSXSpreadChild(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXSpreadChild {\n  assert(\"JSXSpreadChild\", node, opts);\n}\nexport function assertJSXIdentifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXIdentifier {\n  assert(\"JSXIdentifier\", node, opts);\n}\nexport function assertJSXMemberExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXMemberExpression {\n  assert(\"JSXMemberExpression\", node, opts);\n}\nexport function assertJSXNamespacedName(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXNamespacedName {\n  assert(\"JSXNamespacedName\", node, opts);\n}\nexport function assertJSXOpeningElement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXOpeningElement {\n  assert(\"JSXOpeningElement\", node, opts);\n}\nexport function assertJSXSpreadAttribute(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXSpreadAttribute {\n  assert(\"JSXSpreadAttribute\", node, opts);\n}\nexport function assertJSXText(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXText {\n  assert(\"JSXText\", node, opts);\n}\nexport function assertJSXFragment(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXFragment {\n  assert(\"JSXFragment\", node, opts);\n}\nexport function assertJSXOpeningFragment(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXOpeningFragment {\n  assert(\"JSXOpeningFragment\", node, opts);\n}\nexport function assertJSXClosingFragment(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXClosingFragment {\n  assert(\"JSXClosingFragment\", node, opts);\n}\nexport function assertNoop(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Noop {\n  assert(\"Noop\", node, opts);\n}\nexport function assertPlaceholder(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Placeholder {\n  assert(\"Placeholder\", node, opts);\n}\nexport function assertV8IntrinsicIdentifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.V8IntrinsicIdentifier {\n  assert(\"V8IntrinsicIdentifier\", node, opts);\n}\nexport function assertArgumentPlaceholder(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ArgumentPlaceholder {\n  assert(\"ArgumentPlaceholder\", node, opts);\n}\nexport function assertBindExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.BindExpression {\n  assert(\"BindExpression\", node, opts);\n}\nexport function assertImportAttribute(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ImportAttribute {\n  assert(\"ImportAttribute\", node, opts);\n}\nexport function assertDecorator(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Decorator {\n  assert(\"Decorator\", node, opts);\n}\nexport function assertDoExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DoExpression {\n  assert(\"DoExpression\", node, opts);\n}\nexport function assertExportDefaultSpecifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ExportDefaultSpecifier {\n  assert(\"ExportDefaultSpecifier\", node, opts);\n}\nexport function assertRecordExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.RecordExpression {\n  assert(\"RecordExpression\", node, opts);\n}\nexport function assertTupleExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TupleExpression {\n  assert(\"TupleExpression\", node, opts);\n}\nexport function assertDecimalLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DecimalLiteral {\n  assert(\"DecimalLiteral\", node, opts);\n}\nexport function assertModuleExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ModuleExpression {\n  assert(\"ModuleExpression\", node, opts);\n}\nexport function assertTopicReference(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TopicReference {\n  assert(\"TopicReference\", node, opts);\n}\nexport function assertPipelineTopicExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.PipelineTopicExpression {\n  assert(\"PipelineTopicExpression\", node, opts);\n}\nexport function assertPipelineBareFunction(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.PipelineBareFunction {\n  assert(\"PipelineBareFunction\", node, opts);\n}\nexport function assertPipelinePrimaryTopicReference(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.PipelinePrimaryTopicReference {\n  assert(\"PipelinePrimaryTopicReference\", node, opts);\n}\nexport function assertTSParameterProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSParameterProperty {\n  assert(\"TSParameterProperty\", node, opts);\n}\nexport function assertTSDeclareFunction(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSDeclareFunction {\n  assert(\"TSDeclareFunction\", node, opts);\n}\nexport function assertTSDeclareMethod(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSDeclareMethod {\n  assert(\"TSDeclareMethod\", node, opts);\n}\nexport function assertTSQualifiedName(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSQualifiedName {\n  assert(\"TSQualifiedName\", node, opts);\n}\nexport function assertTSCallSignatureDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSCallSignatureDeclaration {\n  assert(\"TSCallSignatureDeclaration\", node, opts);\n}\nexport function assertTSConstructSignatureDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSConstructSignatureDeclaration {\n  assert(\"TSConstructSignatureDeclaration\", node, opts);\n}\nexport function assertTSPropertySignature(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSPropertySignature {\n  assert(\"TSPropertySignature\", node, opts);\n}\nexport function assertTSMethodSignature(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSMethodSignature {\n  assert(\"TSMethodSignature\", node, opts);\n}\nexport function assertTSIndexSignature(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSIndexSignature {\n  assert(\"TSIndexSignature\", node, opts);\n}\nexport function assertTSAnyKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSAnyKeyword {\n  assert(\"TSAnyKeyword\", node, opts);\n}\nexport function assertTSBooleanKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSBooleanKeyword {\n  assert(\"TSBooleanKeyword\", node, opts);\n}\nexport function assertTSBigIntKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSBigIntKeyword {\n  assert(\"TSBigIntKeyword\", node, opts);\n}\nexport function assertTSIntrinsicKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSIntrinsicKeyword {\n  assert(\"TSIntrinsicKeyword\", node, opts);\n}\nexport function assertTSNeverKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSNeverKeyword {\n  assert(\"TSNeverKeyword\", node, opts);\n}\nexport function assertTSNullKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSNullKeyword {\n  assert(\"TSNullKeyword\", node, opts);\n}\nexport function assertTSNumberKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSNumberKeyword {\n  assert(\"TSNumberKeyword\", node, opts);\n}\nexport function assertTSObjectKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSObjectKeyword {\n  assert(\"TSObjectKeyword\", node, opts);\n}\nexport function assertTSStringKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSStringKeyword {\n  assert(\"TSStringKeyword\", node, opts);\n}\nexport function assertTSSymbolKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSSymbolKeyword {\n  assert(\"TSSymbolKeyword\", node, opts);\n}\nexport function assertTSUndefinedKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSUndefinedKeyword {\n  assert(\"TSUndefinedKeyword\", node, opts);\n}\nexport function assertTSUnknownKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSUnknownKeyword {\n  assert(\"TSUnknownKeyword\", node, opts);\n}\nexport function assertTSVoidKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSVoidKeyword {\n  assert(\"TSVoidKeyword\", node, opts);\n}\nexport function assertTSThisType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSThisType {\n  assert(\"TSThisType\", node, opts);\n}\nexport function assertTSFunctionType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSFunctionType {\n  assert(\"TSFunctionType\", node, opts);\n}\nexport function assertTSConstructorType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSConstructorType {\n  assert(\"TSConstructorType\", node, opts);\n}\nexport function assertTSTypeReference(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTypeReference {\n  assert(\"TSTypeReference\", node, opts);\n}\nexport function assertTSTypePredicate(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTypePredicate {\n  assert(\"TSTypePredicate\", node, opts);\n}\nexport function assertTSTypeQuery(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTypeQuery {\n  assert(\"TSTypeQuery\", node, opts);\n}\nexport function assertTSTypeLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTypeLiteral {\n  assert(\"TSTypeLiteral\", node, opts);\n}\nexport function assertTSArrayType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSArrayType {\n  assert(\"TSArrayType\", node, opts);\n}\nexport function assertTSTupleType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTupleType {\n  assert(\"TSTupleType\", node, opts);\n}\nexport function assertTSOptionalType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSOptionalType {\n  assert(\"TSOptionalType\", node, opts);\n}\nexport function assertTSRestType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSRestType {\n  assert(\"TSRestType\", node, opts);\n}\nexport function assertTSNamedTupleMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSNamedTupleMember {\n  assert(\"TSNamedTupleMember\", node, opts);\n}\nexport function assertTSUnionType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSUnionType {\n  assert(\"TSUnionType\", node, opts);\n}\nexport function assertTSIntersectionType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSIntersectionType {\n  assert(\"TSIntersectionType\", node, opts);\n}\nexport function assertTSConditionalType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSConditionalType {\n  assert(\"TSConditionalType\", node, opts);\n}\nexport function assertTSInferType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSInferType {\n  assert(\"TSInferType\", node, opts);\n}\nexport function assertTSParenthesizedType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSParenthesizedType {\n  assert(\"TSParenthesizedType\", node, opts);\n}\nexport function assertTSTypeOperator(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTypeOperator {\n  assert(\"TSTypeOperator\", node, opts);\n}\nexport function assertTSIndexedAccessType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSIndexedAccessType {\n  assert(\"TSIndexedAccessType\", node, opts);\n}\nexport function assertTSMappedType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSMappedType {\n  assert(\"TSMappedType\", node, opts);\n}\nexport function assertTSLiteralType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSLiteralType {\n  assert(\"TSLiteralType\", node, opts);\n}\nexport function assertTSExpressionWithTypeArguments(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSExpressionWithTypeArguments {\n  assert(\"TSExpressionWithTypeArguments\", node, opts);\n}\nexport function assertTSInterfaceDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSInterfaceDeclaration {\n  assert(\"TSInterfaceDeclaration\", node, opts);\n}\nexport function assertTSInterfaceBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSInterfaceBody {\n  assert(\"TSInterfaceBody\", node, opts);\n}\nexport function assertTSTypeAliasDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTypeAliasDeclaration {\n  assert(\"TSTypeAliasDeclaration\", node, opts);\n}\nexport function assertTSInstantiationExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSInstantiationExpression {\n  assert(\"TSInstantiationExpression\", node, opts);\n}\nexport function assertTSAsExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSAsExpression {\n  assert(\"TSAsExpression\", node, opts);\n}\nexport function assertTSSatisfiesExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSSatisfiesExpression {\n  assert(\"TSSatisfiesExpression\", node, opts);\n}\nexport function assertTSTypeAssertion(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTypeAssertion {\n  assert(\"TSTypeAssertion\", node, opts);\n}\nexport function assertTSEnumDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSEnumDeclaration {\n  assert(\"TSEnumDeclaration\", node, opts);\n}\nexport function assertTSEnumMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSEnumMember {\n  assert(\"TSEnumMember\", node, opts);\n}\nexport function assertTSModuleDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSModuleDeclaration {\n  assert(\"TSModuleDeclaration\", node, opts);\n}\nexport function assertTSModuleBlock(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSModuleBlock {\n  assert(\"TSModuleBlock\", node, opts);\n}\nexport function assertTSImportType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSImportType {\n  assert(\"TSImportType\", node, opts);\n}\nexport function assertTSImportEqualsDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSImportEqualsDeclaration {\n  assert(\"TSImportEqualsDeclaration\", node, opts);\n}\nexport function assertTSExternalModuleReference(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSExternalModuleReference {\n  assert(\"TSExternalModuleReference\", node, opts);\n}\nexport function assertTSNonNullExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSNonNullExpression {\n  assert(\"TSNonNullExpression\", node, opts);\n}\nexport function assertTSExportAssignment(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSExportAssignment {\n  assert(\"TSExportAssignment\", node, opts);\n}\nexport function assertTSNamespaceExportDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSNamespaceExportDeclaration {\n  assert(\"TSNamespaceExportDeclaration\", node, opts);\n}\nexport function assertTSTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTypeAnnotation {\n  assert(\"TSTypeAnnotation\", node, opts);\n}\nexport function assertTSTypeParameterInstantiation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTypeParameterInstantiation {\n  assert(\"TSTypeParameterInstantiation\", node, opts);\n}\nexport function assertTSTypeParameterDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTypeParameterDeclaration {\n  assert(\"TSTypeParameterDeclaration\", node, opts);\n}\nexport function assertTSTypeParameter(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTypeParameter {\n  assert(\"TSTypeParameter\", node, opts);\n}\nexport function assertStandardized(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Standardized {\n  assert(\"Standardized\", node, opts);\n}\nexport function assertExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Expression {\n  assert(\"Expression\", node, opts);\n}\nexport function assertBinary(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Binary {\n  assert(\"Binary\", node, opts);\n}\nexport function assertScopable(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Scopable {\n  assert(\"Scopable\", node, opts);\n}\nexport function assertBlockParent(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.BlockParent {\n  assert(\"BlockParent\", node, opts);\n}\nexport function assertBlock(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Block {\n  assert(\"Block\", node, opts);\n}\nexport function assertStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Statement {\n  assert(\"Statement\", node, opts);\n}\nexport function assertTerminatorless(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Terminatorless {\n  assert(\"Terminatorless\", node, opts);\n}\nexport function assertCompletionStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.CompletionStatement {\n  assert(\"CompletionStatement\", node, opts);\n}\nexport function assertConditional(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Conditional {\n  assert(\"Conditional\", node, opts);\n}\nexport function assertLoop(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Loop {\n  assert(\"Loop\", node, opts);\n}\nexport function assertWhile(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.While {\n  assert(\"While\", node, opts);\n}\nexport function assertExpressionWrapper(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ExpressionWrapper {\n  assert(\"ExpressionWrapper\", node, opts);\n}\nexport function assertFor(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.For {\n  assert(\"For\", node, opts);\n}\nexport function assertForXStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ForXStatement {\n  assert(\"ForXStatement\", node, opts);\n}\nexport function assertFunction(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Function {\n  assert(\"Function\", node, opts);\n}\nexport function assertFunctionParent(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.FunctionParent {\n  assert(\"FunctionParent\", node, opts);\n}\nexport function assertPureish(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Pureish {\n  assert(\"Pureish\", node, opts);\n}\nexport function assertDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Declaration {\n  assert(\"Declaration\", node, opts);\n}\nexport function assertPatternLike(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.PatternLike {\n  assert(\"PatternLike\", node, opts);\n}\nexport function assertLVal(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.LVal {\n  assert(\"LVal\", node, opts);\n}\nexport function assertTSEntityName(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSEntityName {\n  assert(\"TSEntityName\", node, opts);\n}\nexport function assertLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Literal {\n  assert(\"Literal\", node, opts);\n}\nexport function assertImmutable(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Immutable {\n  assert(\"Immutable\", node, opts);\n}\nexport function assertUserWhitespacable(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.UserWhitespacable {\n  assert(\"UserWhitespacable\", node, opts);\n}\nexport function assertMethod(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Method {\n  assert(\"Method\", node, opts);\n}\nexport function assertObjectMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ObjectMember {\n  assert(\"ObjectMember\", node, opts);\n}\nexport function assertProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Property {\n  assert(\"Property\", node, opts);\n}\nexport function assertUnaryLike(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.UnaryLike {\n  assert(\"UnaryLike\", node, opts);\n}\nexport function assertPattern(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Pattern {\n  assert(\"Pattern\", node, opts);\n}\nexport function assertClass(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Class {\n  assert(\"Class\", node, opts);\n}\nexport function assertImportOrExportDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ImportOrExportDeclaration {\n  assert(\"ImportOrExportDeclaration\", node, opts);\n}\nexport function assertExportDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ExportDeclaration {\n  assert(\"ExportDeclaration\", node, opts);\n}\nexport function assertModuleSpecifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ModuleSpecifier {\n  assert(\"ModuleSpecifier\", node, opts);\n}\nexport function assertAccessor(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Accessor {\n  assert(\"Accessor\", node, opts);\n}\nexport function assertPrivate(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Private {\n  assert(\"Private\", node, opts);\n}\nexport function assertFlow(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Flow {\n  assert(\"Flow\", node, opts);\n}\nexport function assertFlowType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.FlowType {\n  assert(\"FlowType\", node, opts);\n}\nexport function assertFlowBaseAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.FlowBaseAnnotation {\n  assert(\"FlowBaseAnnotation\", node, opts);\n}\nexport function assertFlowDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.FlowDeclaration {\n  assert(\"FlowDeclaration\", node, opts);\n}\nexport function assertFlowPredicate(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.FlowPredicate {\n  assert(\"FlowPredicate\", node, opts);\n}\nexport function assertEnumBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EnumBody {\n  assert(\"EnumBody\", node, opts);\n}\nexport function assertEnumMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EnumMember {\n  assert(\"EnumMember\", node, opts);\n}\nexport function assertJSX(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSX {\n  assert(\"JSX\", node, opts);\n}\nexport function assertMiscellaneous(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Miscellaneous {\n  assert(\"Miscellaneous\", node, opts);\n}\nexport function assertTypeScript(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TypeScript {\n  assert(\"TypeScript\", node, opts);\n}\nexport function assertTSTypeElement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTypeElement {\n  assert(\"TSTypeElement\", node, opts);\n}\nexport function assertTSType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSType {\n  assert(\"TSType\", node, opts);\n}\nexport function assertTSBaseType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSBaseType {\n  assert(\"TSBaseType\", node, opts);\n}\nexport function assertNumberLiteral(node: any, opts: any): void {\n  deprecationWarning(\"assertNumberLiteral\", \"assertNumericLiteral\");\n  assert(\"NumberLiteral\", node, opts);\n}\nexport function assertRegexLiteral(node: any, opts: any): void {\n  deprecationWarning(\"assertRegexLiteral\", \"assertRegExpLiteral\");\n  assert(\"RegexLiteral\", node, opts);\n}\nexport function assertRestProperty(node: any, opts: any): void {\n  deprecationWarning(\"assertRestProperty\", \"assertRestElement\");\n  assert(\"RestProperty\", node, opts);\n}\nexport function assertSpreadProperty(node: any, opts: any): void {\n  deprecationWarning(\"assertSpreadProperty\", \"assertSpreadElement\");\n  assert(\"SpreadProperty\", node, opts);\n}\nexport function assertModuleDeclaration(node: any, opts: any): void {\n  deprecationWarning(\n    \"assertModuleDeclaration\",\n    \"assertImportOrExportDeclaration\",\n  );\n  assert(\"ModuleDeclaration\", node, opts);\n}\n", "import {\n  anyTypeAnnotation,\n  stringTypeAnnotation,\n  numberTypeAnnotation,\n  voidTypeAnnotation,\n  booleanTypeAnnotation,\n  genericTypeAnnotation,\n  identifier,\n} from \"../generated/index.ts\";\nimport type * as t from \"../../index.ts\";\n\nexport default createTypeAnnotationBasedOnTypeof as {\n  (type: \"string\"): t.StringTypeAnnotation;\n  (type: \"number\"): t.NumberTypeAnnotation;\n  (type: \"undefined\"): t.VoidTypeAnnotation;\n  (type: \"boolean\"): t.BooleanTypeAnnotation;\n  (type: \"function\"): t.GenericTypeAnnotation;\n  (type: \"object\"): t.GenericTypeAnnotation;\n  (type: \"symbol\"): t.GenericTypeAnnotation;\n  (type: \"bigint\"): t.AnyTypeAnnotation;\n};\n\n/**\n * Create a type annotation based on typeof expression.\n */\nfunction createTypeAnnotationBasedOnTypeof(type: string): t.FlowType {\n  switch (type) {\n    case \"string\":\n      return stringTypeAnnotation();\n    case \"number\":\n      return numberTypeAnnotation();\n    case \"undefined\":\n      return voidTypeAnnotation();\n    case \"boolean\":\n      return booleanTypeAnnotation();\n    case \"function\":\n      return genericTypeAnnotation(identifier(\"Function\"));\n    case \"object\":\n      return genericTypeAnnotation(identifier(\"Object\"));\n    case \"symbol\":\n      return genericTypeAnnotation(identifier(\"Symbol\"));\n    case \"bigint\":\n      // todo: use BigInt annotation when Flow supports BigInt\n      // https://github.com/facebook/flow/issues/6639\n      return anyTypeAnnotation();\n  }\n  throw new Error(\"Invalid typeof value: \" + type);\n}\n", "import {\n  isAnyTypeAnnotation,\n  isGenericTypeAnnotation,\n  isUnionTypeAnnotation,\n  isFlowBaseAnnotation,\n  isIdentifier,\n} from \"../../validators/generated/index.ts\";\nimport type * as t from \"../../index.ts\";\n\nfunction getQualifiedName(node: t.GenericTypeAnnotation[\"id\"]): string {\n  return isIdentifier(node)\n    ? node.name\n    : `${node.id.name}.${getQualifiedName(node.qualification)}`;\n}\n\n/**\n * Dedupe type annotations.\n */\nexport default function removeTypeDuplicates(\n  nodesIn: ReadonlyArray<t.FlowType | false | null | undefined>,\n): t.FlowType[] {\n  const nodes = Array.from(nodesIn);\n\n  const generics = new Map<string, t.GenericTypeAnnotation>();\n  const bases = new Map<t.FlowBaseAnnotation[\"type\"], t.FlowBaseAnnotation>();\n\n  // store union type groups to circular references\n  const typeGroups = new Set<t.FlowType[]>();\n\n  const types: t.FlowType[] = [];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!node) continue;\n\n    // detect duplicates\n    if (types.includes(node)) {\n      continue;\n    }\n\n    // this type matches anything\n    if (isAnyTypeAnnotation(node)) {\n      return [node];\n    }\n\n    if (isFlowBaseAnnotation(node)) {\n      bases.set(node.type, node);\n      continue;\n    }\n\n    if (isUnionTypeAnnotation(node)) {\n      if (!typeGroups.has(node.types)) {\n        nodes.push(...node.types);\n        typeGroups.add(node.types);\n      }\n      continue;\n    }\n\n    // find a matching generic type and merge and deduplicate the type parameters\n    if (isGenericTypeAnnotation(node)) {\n      const name = getQualifiedName(node.id);\n\n      if (generics.has(name)) {\n        let existing: t.Flow = generics.get(name);\n        if (existing.typeParameters) {\n          if (node.typeParameters) {\n            existing.typeParameters.params.push(...node.typeParameters.params);\n            existing.typeParameters.params = removeTypeDuplicates(\n              existing.typeParameters.params,\n            );\n          }\n        } else {\n          existing = node.typeParameters;\n        }\n      } else {\n        generics.set(name, node);\n      }\n\n      continue;\n    }\n\n    types.push(node);\n  }\n\n  // add back in bases\n  for (const [, baseType] of bases) {\n    types.push(baseType);\n  }\n\n  // add back in generics\n  for (const [, genericName] of generics) {\n    types.push(genericName);\n  }\n\n  return types;\n}\n", "import { unionTypeAnnotation } from \"../generated/index.ts\";\nimport removeTypeDuplicates from \"../../modifications/flow/removeTypeDuplicates.ts\";\nimport type * as t from \"../../index.ts\";\n\n/**\n * Takes an array of `types` and flattens them, removing duplicates and\n * returns a `UnionTypeAnnotation` node containing them.\n */\nexport default function createFlowUnionType<T extends t.FlowType>(\n  types: [T] | Array<T>,\n): T | t.UnionTypeAnnotation {\n  const flattened = removeTypeDuplicates(types);\n\n  if (flattened.length === 1) {\n    return flattened[0] as T;\n  } else {\n    return unionTypeAnnotation(flattened);\n  }\n}\n", "import {\n  isIdentifier,\n  isTSAnyKeyword,\n  isTSTypeReference,\n  isTSUnionType,\n  isTSBaseType,\n} from \"../../validators/generated/index.ts\";\nimport type * as t from \"../../index.ts\";\n\nfunction getQualifiedName(node: t.TSTypeReference[\"typeName\"]): string {\n  return isIdentifier(node)\n    ? node.name\n    : `${node.right.name}.${getQualifiedName(node.left)}`;\n}\n\n/**\n * Dedupe type annotations.\n */\nexport default function removeTypeDuplicates(\n  nodesIn: ReadonlyArray<t.TSType>,\n): Array<t.TSType> {\n  const nodes = Array.from(nodesIn);\n\n  const generics = new Map<string, t.TSTypeReference>();\n  const bases = new Map<t.TSBaseType[\"type\"], t.TSBaseType>();\n\n  // store union type groups to circular references\n  const typeGroups = new Set<t.TSType[]>();\n\n  const types: t.TSType[] = [];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!node) continue;\n\n    // detect duplicates\n    if (types.includes(node)) {\n      continue;\n    }\n\n    // this type matches anything\n    if (isTSAnyKeyword(node)) {\n      return [node];\n    }\n\n    // Analogue of FlowBaseAnnotation\n    if (isTSBaseType(node)) {\n      bases.set(node.type, node);\n      continue;\n    }\n\n    if (isTSUnionType(node)) {\n      if (!typeGroups.has(node.types)) {\n        nodes.push(...node.types);\n        typeGroups.add(node.types);\n      }\n      continue;\n    }\n\n    // todo: support merging tuples: number[]\n    if (isTSTypeReference(node) && node.typeParameters) {\n      const name = getQualifiedName(node.typeName);\n\n      if (generics.has(name)) {\n        let existing: t.TypeScript = generics.get(name);\n        if (existing.typeParameters) {\n          if (node.typeParameters) {\n            existing.typeParameters.params.push(...node.typeParameters.params);\n            existing.typeParameters.params = removeTypeDuplicates(\n              existing.typeParameters.params,\n            );\n          }\n        } else {\n          existing = node.typeParameters;\n        }\n      } else {\n        generics.set(name, node);\n      }\n\n      continue;\n    }\n\n    types.push(node);\n  }\n\n  // add back in bases\n  for (const [, baseType] of bases) {\n    types.push(baseType);\n  }\n\n  // add back in generics\n  for (const [, genericName] of generics) {\n    types.push(genericName);\n  }\n\n  return types;\n}\n", "import { tsUnionType } from \"../generated/index.ts\";\nimport removeTypeDuplicates from \"../../modifications/typescript/removeTypeDuplicates.ts\";\nimport { isTSTypeAnnotation } from \"../../validators/generated/index.ts\";\nimport type * as t from \"../../index.ts\";\n\n/**\n * Takes an array of `types` and flattens them, removing duplicates and\n * returns a `UnionTypeAnnotation` node containing them.\n */\nexport default function createTSUnionType(\n  typeAnnotations: Array<t.TSTypeAnnotation | t.TSType>,\n): t.TSType {\n  const types = typeAnnotations.map(type => {\n    return isTSTypeAnnotation(type) ? type.typeAnnotation : type;\n  });\n  const flattened = removeTypeDuplicates(types);\n\n  if (flattened.length === 1) {\n    return flattened[0];\n  } else {\n    return tsUnionType(flattened);\n  }\n}\n", "/*\n * This file is auto-generated! Do not modify it directly.\n * To re-generate run 'make build'\n */\n\n/**\n * This file is written in JavaScript and not TypeScript because uppercase builders\n * conflict with AST types. TypeScript reads the uppercase.d.ts file instead.\n */\n\nexport {\n  arrayExpression as ArrayExpression,\n  assignmentExpression as AssignmentExpression,\n  binaryExpression as BinaryExpression,\n  interpreterDirective as InterpreterDirective,\n  directive as Directive,\n  directiveLiteral as DirectiveLiteral,\n  blockStatement as BlockStatement,\n  breakStatement as BreakStatement,\n  callExpression as CallExpression,\n  catchClause as CatchClause,\n  conditionalExpression as ConditionalExpression,\n  continueStatement as ContinueStatement,\n  debuggerStatement as DebuggerStatement,\n  doWhileStatement as DoWhileStatement,\n  emptyStatement as EmptyStatement,\n  expressionStatement as ExpressionStatement,\n  file as File,\n  forInStatement as ForInStatement,\n  forStatement as ForStatement,\n  functionDeclaration as FunctionDeclaration,\n  functionExpression as FunctionExpression,\n  identifier as Identifier,\n  ifStatement as IfStatement,\n  labeledStatement as LabeledStatement,\n  stringLiteral as StringLiteral,\n  numericLiteral as NumericLiteral,\n  nullLiteral as NullLiteral,\n  booleanLiteral as BooleanLiteral,\n  regExpLiteral as RegExpLiteral,\n  logicalExpression as LogicalExpression,\n  memberExpression as MemberExpression,\n  newExpression as NewExpression,\n  program as Program,\n  objectExpression as ObjectExpression,\n  objectMethod as ObjectMethod,\n  objectProperty as ObjectProperty,\n  restElement as RestElement,\n  returnStatement as ReturnStatement,\n  sequenceExpression as SequenceExpression,\n  parenthesizedExpression as ParenthesizedExpression,\n  switchCase as SwitchCase,\n  switchStatement as SwitchStatement,\n  thisExpression as ThisExpression,\n  throwStatement as ThrowStatement,\n  tryStatement as TryStatement,\n  unaryExpression as UnaryExpression,\n  updateExpression as UpdateExpression,\n  variableDeclaration as VariableDeclaration,\n  variableDeclarator as VariableDeclarator,\n  whileStatement as WhileStatement,\n  withStatement as WithStatement,\n  assignmentPattern as AssignmentPattern,\n  arrayPattern as ArrayPattern,\n  arrowFunctionExpression as ArrowFunctionExpression,\n  classBody as ClassBody,\n  classExpression as ClassExpression,\n  classDeclaration as ClassDeclaration,\n  exportAllDeclaration as ExportAllDeclaration,\n  exportDefaultDeclaration as ExportDefaultDeclaration,\n  exportNamedDeclaration as ExportNamedDeclaration,\n  exportSpecifier as ExportSpecifier,\n  forOfStatement as ForOfStatement,\n  importDeclaration as ImportDeclaration,\n  importDefaultSpecifier as ImportDefaultSpecifier,\n  importNamespaceSpecifier as ImportNamespaceSpecifier,\n  importSpecifier as ImportSpecifier,\n  importExpression as ImportExpression,\n  metaProperty as MetaProperty,\n  classMethod as ClassMethod,\n  objectPattern as ObjectPattern,\n  spreadElement as SpreadElement,\n  super as Super,\n  taggedTemplateExpression as TaggedTemplateExpression,\n  templateElement as TemplateElement,\n  templateLiteral as TemplateLiteral,\n  yieldExpression as YieldExpression,\n  awaitExpression as AwaitExpression,\n  import as Import,\n  bigIntLiteral as BigIntLiteral,\n  exportNamespaceSpecifier as ExportNamespaceSpecifier,\n  optionalMemberExpression as OptionalMemberExpression,\n  optionalCallExpression as OptionalCallExpression,\n  classProperty as ClassProperty,\n  classAccessorProperty as ClassAccessorProperty,\n  classPrivateProperty as ClassPrivateProperty,\n  classPrivateMethod as ClassPrivateMethod,\n  privateName as PrivateName,\n  staticBlock as StaticBlock,\n  anyTypeAnnotation as AnyTypeAnnotation,\n  arrayTypeAnnotation as ArrayTypeAnnotation,\n  booleanTypeAnnotation as BooleanTypeAnnotation,\n  booleanLiteralTypeAnnotation as BooleanLiteralTypeAnnotation,\n  nullLiteralTypeAnnotation as NullLiteralTypeAnnotation,\n  classImplements as ClassImplements,\n  declareClass as DeclareClass,\n  declareFunction as DeclareFunction,\n  declareInterface as DeclareInterface,\n  declareModule as DeclareModule,\n  declareModuleExports as DeclareModuleExports,\n  declareTypeAlias as DeclareTypeAlias,\n  declareOpaqueType as DeclareOpaqueType,\n  declareVariable as DeclareVariable,\n  declareExportDeclaration as DeclareExportDeclaration,\n  declareExportAllDeclaration as DeclareExportAllDeclaration,\n  declaredPredicate as DeclaredPredicate,\n  existsTypeAnnotation as ExistsTypeAnnotation,\n  functionTypeAnnotation as FunctionTypeAnnotation,\n  functionTypeParam as FunctionTypeParam,\n  genericTypeAnnotation as GenericTypeAnnotation,\n  inferredPredicate as InferredPredicate,\n  interfaceExtends as InterfaceExtends,\n  interfaceDeclaration as InterfaceDeclaration,\n  interfaceTypeAnnotation as InterfaceTypeAnnotation,\n  intersectionTypeAnnotation as IntersectionTypeAnnotation,\n  mixedTypeAnnotation as MixedTypeAnnotation,\n  emptyTypeAnnotation as EmptyTypeAnnotation,\n  nullableTypeAnnotation as NullableTypeAnnotation,\n  numberLiteralTypeAnnotation as NumberLiteralTypeAnnotation,\n  numberTypeAnnotation as NumberTypeAnnotation,\n  objectTypeAnnotation as ObjectTypeAnnotation,\n  objectTypeInternalSlot as ObjectTypeInternalSlot,\n  objectTypeCallProperty as ObjectTypeCallProperty,\n  objectTypeIndexer as ObjectTypeIndexer,\n  objectTypeProperty as ObjectTypeProperty,\n  objectTypeSpreadProperty as ObjectTypeSpreadProperty,\n  opaqueType as OpaqueType,\n  qualifiedTypeIdentifier as QualifiedTypeIdentifier,\n  stringLiteralTypeAnnotation as StringLiteralTypeAnnotation,\n  stringTypeAnnotation as StringTypeAnnotation,\n  symbolTypeAnnotation as SymbolTypeAnnotation,\n  thisTypeAnnotation as ThisTypeAnnotation,\n  tupleTypeAnnotation as TupleTypeAnnotation,\n  typeofTypeAnnotation as TypeofTypeAnnotation,\n  typeAlias as TypeAlias,\n  typeAnnotation as TypeAnnotation,\n  typeCastExpression as TypeCastExpression,\n  typeParameter as TypeParameter,\n  typeParameterDeclaration as TypeParameterDeclaration,\n  typeParameterInstantiation as TypeParameterInstantiation,\n  unionTypeAnnotation as UnionTypeAnnotation,\n  variance as Variance,\n  voidTypeAnnotation as VoidTypeAnnotation,\n  enumDeclaration as EnumDeclaration,\n  enumBooleanBody as EnumBooleanBody,\n  enumNumberBody as EnumNumberBody,\n  enumStringBody as EnumStringBody,\n  enumSymbolBody as EnumSymbolBody,\n  enumBooleanMember as EnumBooleanMember,\n  enumNumberMember as EnumNumberMember,\n  enumStringMember as EnumStringMember,\n  enumDefaultedMember as EnumDefaultedMember,\n  indexedAccessType as IndexedAccessType,\n  optionalIndexedAccessType as OptionalIndexedAccessType,\n  jsxAttribute as JSXAttribute,\n  jsxClosingElement as JSXClosingElement,\n  jsxElement as JSXElement,\n  jsxEmptyExpression as JSXEmptyExpression,\n  jsxExpressionContainer as JSXExpressionContainer,\n  jsxSpreadChild as JSXSpreadChild,\n  jsxIdentifier as JSXIdentifier,\n  jsxMemberExpression as JSXMemberExpression,\n  jsxNamespacedName as JSXNamespacedName,\n  jsxOpeningElement as JSXOpeningElement,\n  jsxSpreadAttribute as JSXSpreadAttribute,\n  jsxText as JSXText,\n  jsxFragment as JSXFragment,\n  jsxOpeningFragment as JSXOpeningFragment,\n  jsxClosingFragment as JSXClosingFragment,\n  noop as Noop,\n  placeholder as Placeholder,\n  v8IntrinsicIdentifier as V8IntrinsicIdentifier,\n  argumentPlaceholder as ArgumentPlaceholder,\n  bindExpression as BindExpression,\n  importAttribute as ImportAttribute,\n  decorator as Decorator,\n  doExpression as DoExpression,\n  exportDefaultSpecifier as ExportDefaultSpecifier,\n  recordExpression as RecordExpression,\n  tupleExpression as TupleExpression,\n  decimalLiteral as DecimalLiteral,\n  moduleExpression as ModuleExpression,\n  topicReference as TopicReference,\n  pipelineTopicExpression as PipelineTopicExpression,\n  pipelineBareFunction as PipelineBareFunction,\n  pipelinePrimaryTopicReference as PipelinePrimaryTopicReference,\n  tsParameterProperty as TSParameterProperty,\n  tsDeclareFunction as TSDeclareFunction,\n  tsDeclareMethod as TSDeclareMethod,\n  tsQualifiedName as TSQualifiedName,\n  tsCallSignatureDeclaration as TSCallSignatureDeclaration,\n  tsConstructSignatureDeclaration as TSConstructSignatureDeclaration,\n  tsPropertySignature as TSPropertySignature,\n  tsMethodSignature as TSMethodSignature,\n  tsIndexSignature as TSIndexSignature,\n  tsAnyKeyword as TSAnyKeyword,\n  tsBooleanKeyword as TSBooleanKeyword,\n  tsBigIntKeyword as TSBigIntKeyword,\n  tsIntrinsicKeyword as TSIntrinsicKeyword,\n  tsNeverKeyword as TSNeverKeyword,\n  tsNullKeyword as TSNullKeyword,\n  tsNumberKeyword as TSNumberKeyword,\n  tsObjectKeyword as TSObjectKeyword,\n  tsStringKeyword as TSStringKeyword,\n  tsSymbolKeyword as TSSymbolKeyword,\n  tsUndefinedKeyword as TSUndefinedKeyword,\n  tsUnknownKeyword as TSUnknownKeyword,\n  tsVoidKeyword as TSVoidKeyword,\n  tsThisType as TSThisType,\n  tsFunctionType as TSFunctionType,\n  tsConstructorType as TSConstructorType,\n  tsTypeReference as TSTypeReference,\n  tsTypePredicate as TSTypePredicate,\n  tsTypeQuery as TSTypeQuery,\n  tsTypeLiteral as TSTypeLiteral,\n  tsArrayType as TSArrayType,\n  tsTupleType as TSTupleType,\n  tsOptionalType as TSOptionalType,\n  tsRestType as TSRestType,\n  tsNamedTupleMember as TSNamedTupleMember,\n  tsUnionType as TSUnionType,\n  tsIntersectionType as TSIntersectionType,\n  tsConditionalType as TSConditionalType,\n  tsInferType as TSInferType,\n  tsParenthesizedType as TSParenthesizedType,\n  tsTypeOperator as TSTypeOperator,\n  tsIndexedAccessType as TSIndexedAccessType,\n  tsMappedType as TSMappedType,\n  tsLiteralType as TSLiteralType,\n  tsExpressionWithTypeArguments as TSExpressionWithTypeArguments,\n  tsInterfaceDeclaration as TSInterfaceDeclaration,\n  tsInterfaceBody as TSInterfaceBody,\n  tsTypeAliasDeclaration as TSTypeAliasDeclaration,\n  tsInstantiationExpression as TSInstantiationExpression,\n  tsAsExpression as TSAsExpression,\n  tsSatisfiesExpression as TSSatisfiesExpression,\n  tsTypeAssertion as TSTypeAssertion,\n  tsEnumDeclaration as TSEnumDeclaration,\n  tsEnumMember as TSEnumMember,\n  tsModuleDeclaration as TSModuleDeclaration,\n  tsModuleBlock as TSModuleBlock,\n  tsImportType as TSImportType,\n  tsImportEqualsDeclaration as TSImportEqualsDeclaration,\n  tsExternalModuleReference as TSExternalModuleReference,\n  tsNonNullExpression as TSNonNullExpression,\n  tsExportAssignment as TSExportAssignment,\n  tsNamespaceExportDeclaration as TSNamespaceExportDeclaration,\n  tsTypeAnnotation as TSTypeAnnotation,\n  tsTypeParameterInstantiation as TSTypeParameterInstantiation,\n  tsTypeParameterDeclaration as TSTypeParameterDeclaration,\n  tsTypeParameter as TSTypeParameter,\n  numberLiteral as NumberLiteral,\n  regexLiteral as RegexLiteral,\n  restProperty as RestProperty,\n  spreadProperty as SpreadProperty,\n} from \"./index.ts\";\n", "import { numericLiteral, unaryExpression } from \"./generated/index.ts\";\n\nexport function buildUndefinedNode() {\n  return unaryExpression(\"void\", numericLiteral(0), true);\n}\n", "import { NODE_FIELDS } from \"../definitions/index.ts\";\nimport type * as t from \"../index.ts\";\nimport { isFile, isIdentifier } from \"../validators/generated/index.ts\";\n\nconst { hasOwn } = process.env.BABEL_8_BREAKING\n  ? Object\n  : { hasOwn: Function.call.bind(Object.prototype.hasOwnProperty) };\n\ntype CommentCache = Map<t.Comment, t.Comment>;\n\n// This function will never be called for comments, only for real nodes.\nfunction cloneIfNode(\n  obj: t.Node | undefined | null,\n  deep: boolean,\n  withoutLoc: boolean,\n  commentsCache: CommentCache,\n) {\n  if (obj && typeof obj.type === \"string\") {\n    return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);\n  }\n\n  return obj;\n}\n\nfunction cloneIfNodeOrArray(\n  obj: t.Node | undefined | null | (t.Node | undefined | null)[],\n  deep: boolean,\n  withoutLoc: boolean,\n  commentsCache: CommentCache,\n) {\n  if (Array.isArray(obj)) {\n    return obj.map(node => cloneIfNode(node, deep, withoutLoc, commentsCache));\n  }\n  return cloneIfNode(obj, deep, withoutLoc, commentsCache);\n}\n\n/**\n * Create a clone of a `node` including only properties belonging to the node.\n * If the second parameter is `false`, cloneNode performs a shallow clone.\n * If the third parameter is true, the cloned nodes exclude location properties.\n */\nexport default function cloneNode<T extends t.Node>(\n  node: T,\n  deep: boolean = true,\n  withoutLoc: boolean = false,\n): T {\n  return cloneNodeInternal(node, deep, withoutLoc, new Map());\n}\n\nfunction cloneNodeInternal<T extends t.Node>(\n  node: T,\n  deep: boolean = true,\n  withoutLoc: boolean = false,\n  commentsCache: CommentCache,\n): T {\n  if (!node) return node;\n\n  const { type } = node;\n  const newNode: any = { type: node.type };\n\n  // Special-case identifiers since they are the most cloned nodes.\n  if (isIdentifier(node)) {\n    newNode.name = node.name;\n\n    if (hasOwn(node, \"optional\") && typeof node.optional === \"boolean\") {\n      newNode.optional = node.optional;\n    }\n\n    if (hasOwn(node, \"typeAnnotation\")) {\n      newNode.typeAnnotation = deep\n        ? cloneIfNodeOrArray(\n            node.typeAnnotation,\n            true,\n            withoutLoc,\n            commentsCache,\n          )\n        : node.typeAnnotation;\n    }\n\n    if (hasOwn(node, \"decorators\")) {\n      newNode.decorators = deep\n        ? cloneIfNodeOrArray(node.decorators, true, withoutLoc, commentsCache)\n        : node.decorators;\n    }\n  } else if (!hasOwn(NODE_FIELDS, type)) {\n    throw new Error(`Unknown node type: \"${type}\"`);\n  } else {\n    for (const field of Object.keys(NODE_FIELDS[type])) {\n      if (hasOwn(node, field)) {\n        if (deep) {\n          newNode[field] =\n            isFile(node) && field === \"comments\"\n              ? maybeCloneComments(\n                  node.comments,\n                  deep,\n                  withoutLoc,\n                  commentsCache,\n                )\n              : cloneIfNodeOrArray(\n                  // @ts-expect-error node[field] has been guarded by has check\n                  node[field],\n                  true,\n                  withoutLoc,\n                  commentsCache,\n                );\n        } else {\n          newNode[field] =\n            // @ts-expect-error node[field] has been guarded by has check\n            node[field];\n        }\n      }\n    }\n  }\n\n  if (hasOwn(node, \"loc\")) {\n    if (withoutLoc) {\n      newNode.loc = null;\n    } else {\n      newNode.loc = node.loc;\n    }\n  }\n  if (hasOwn(node, \"leadingComments\")) {\n    newNode.leadingComments = maybeCloneComments(\n      node.leadingComments,\n      deep,\n      withoutLoc,\n      commentsCache,\n    );\n  }\n  if (hasOwn(node, \"innerComments\")) {\n    newNode.innerComments = maybeCloneComments(\n      node.innerComments,\n      deep,\n      withoutLoc,\n      commentsCache,\n    );\n  }\n  if (hasOwn(node, \"trailingComments\")) {\n    newNode.trailingComments = maybeCloneComments(\n      node.trailingComments,\n      deep,\n      withoutLoc,\n      commentsCache,\n    );\n  }\n  if (hasOwn(node, \"extra\")) {\n    newNode.extra = {\n      ...node.extra,\n    };\n  }\n\n  return newNode;\n}\n\nfunction maybeCloneComments<T extends t.Comment>(\n  comments: ReadonlyArray<T> | null,\n  deep: boolean,\n  withoutLoc: boolean,\n  commentsCache: Map<T, T>,\n): ReadonlyArray<T> | null {\n  if (!comments || !deep) {\n    return comments;\n  }\n  return comments.map(comment => {\n    const cache = commentsCache.get(comment);\n    if (cache) return cache;\n\n    const { type, value, loc } = comment;\n\n    const ret = { type, value, loc } as T;\n    if (withoutLoc) {\n      ret.loc = null;\n    }\n\n    commentsCache.set(comment, ret);\n\n    return ret;\n  });\n}\n", "import cloneNode from \"./cloneNode.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Create a shallow clone of a `node`, including only\n * properties belonging to the node.\n * @deprecated Use t.cloneNode instead.\n */\nexport default function clone<T extends t.Node>(node: T): T {\n  return cloneNode(node, /* deep */ false);\n}\n", "import cloneNode from \"./cloneNode.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Create a deep clone of a `node` and all of it's child nodes\n * including only properties belonging to the node.\n * @deprecated Use t.cloneNode instead.\n */\nexport default function cloneDeep<T extends t.Node>(node: T): T {\n  return cloneNode(node);\n}\n", "import cloneNode from \"./cloneNode.ts\";\nimport type * as t from \"../index.ts\";\n/**\n * Create a deep clone of a `node` and all of it's child nodes\n * including only properties belonging to the node.\n * excluding `_private` and location properties.\n */\nexport default function cloneDeepWithoutLoc<T extends t.Node>(node: T): T {\n  return cloneNode(node, /* deep */ true, /* withoutLoc */ true);\n}\n", "import cloneNode from \"./cloneNode.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Create a shallow clone of a `node` excluding `_private` and location properties.\n */\nexport default function cloneWithoutLoc<T extends t.Node>(node: T): T {\n  return cloneNode(node, /* deep */ false, /* withoutLoc */ true);\n}\n", "import type * as t from \"../index.ts\";\n\n/**\n * Add comments of certain type to a node.\n */\nexport default function addComments<T extends t.Node>(\n  node: T,\n  type: t.CommentTypeShorthand,\n  comments: Array<t.Comment>,\n): T {\n  if (!comments || !node) return node;\n\n  const key = `${type}Comments` as const;\n\n  if (node[key]) {\n    if (type === \"leading\") {\n      node[key] = comments.concat(node[key]);\n    } else {\n      node[key].push(...comments);\n    }\n  } else {\n    node[key] = comments;\n  }\n\n  return node;\n}\n", "import addComments from \"./addComments.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Add comment of certain type to a node.\n */\nexport default function addComment<T extends t.Node>(\n  node: T,\n  type: t.CommentTypeShorthand,\n  content: string,\n  line?: boolean,\n): T {\n  return addComments(node, type, [\n    {\n      type: line ? \"CommentLine\" : \"CommentBlock\",\n      value: content,\n    } as t.Comment,\n  ]);\n}\n", "import type * as t from \"../index.ts\";\n\nexport default function inherit<\n  C extends t.Node | undefined,\n  P extends t.Node | undefined,\n>(key: keyof C & keyof P, child: C, parent: P): void {\n  if (child && parent) {\n    // @ts-expect-error Could further refine key definitions\n    child[key] = Array.from(\n      new Set([].concat(child[key], parent[key]).filter(Boolean)),\n    );\n  }\n}\n", "import inherit from \"../utils/inherit.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default function inheritInnerComments(\n  child: t.Node,\n  parent: t.Node,\n): void {\n  inherit(\"innerComments\", child, parent);\n}\n", "import inherit from \"../utils/inherit.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default function inheritLeadingComments(\n  child: t.Node,\n  parent: t.Node,\n): void {\n  inherit(\"leadingComments\", child, parent);\n}\n", "import inherit from \"../utils/inherit.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default function inheritTrailingComments(\n  child: t.Node,\n  parent: t.Node,\n): void {\n  inherit(\"trailingComments\", child, parent);\n}\n", "import inheritTrailingComments from \"./inheritTrailingComments.ts\";\nimport inheritLeadingComments from \"./inheritLeadingComments.ts\";\nimport inheritInnerComments from \"./inheritInnerComments.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Inherit all unique comments from `parent` node to `child` node.\n */\nexport default function inheritsComments<T extends t.Node>(\n  child: T,\n  parent: t.Node,\n): T {\n  inheritTrailingComments(child, parent);\n  inheritLeadingComments(child, parent);\n  inheritInnerComments(child, parent);\n\n  return child;\n}\n", "import { COMMENT_KEYS } from \"../constants/index.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Remove comment properties from a node.\n */\nexport default function removeComments<T extends t.Node>(node: T): T {\n  COMMENT_KEYS.forEach(key => {\n    node[key] = null;\n  });\n\n  return node;\n}\n", "/*\n * This file is auto-generated! Do not modify it directly.\n * To re-generate run 'make build'\n */\nimport { FLIPPED_ALIAS_KEYS } from \"../../definitions/index.ts\";\n\nexport const STANDARDIZED_TYPES = FLIPPED_ALIAS_KEYS[\"Standardized\"];\nexport const EXPRESSION_TYPES = FLIPPED_ALIAS_KEYS[\"Expression\"];\nexport const BINARY_TYPES = FLIPPED_ALIAS_KEYS[\"Binary\"];\nexport const SCOPABLE_TYPES = FLIPPED_ALIAS_KEYS[\"Scopable\"];\nexport const BLOCKPARENT_TYPES = FLIPPED_ALIAS_KEYS[\"BlockParent\"];\nexport const BLOCK_TYPES = FLIPPED_ALIAS_KEYS[\"Block\"];\nexport const STATEMENT_TYPES = FLIPPED_ALIAS_KEYS[\"Statement\"];\nexport const TERMINATORLESS_TYPES = FLIPPED_ALIAS_KEYS[\"Terminatorless\"];\nexport const COMPLETIONSTATEMENT_TYPES =\n  FLIPPED_ALIAS_KEYS[\"CompletionStatement\"];\nexport const CONDITIONAL_TYPES = FLIPPED_ALIAS_KEYS[\"Conditional\"];\nexport const LOOP_TYPES = FLIPPED_ALIAS_KEYS[\"Loop\"];\nexport const WHILE_TYPES = FLIPPED_ALIAS_KEYS[\"While\"];\nexport const EXPRESSIONWRAPPER_TYPES = FLIPPED_ALIAS_KEYS[\"ExpressionWrapper\"];\nexport const FOR_TYPES = FLIPPED_ALIAS_KEYS[\"For\"];\nexport const FORXSTATEMENT_TYPES = FLIPPED_ALIAS_KEYS[\"ForXStatement\"];\nexport const FUNCTION_TYPES = FLIPPED_ALIAS_KEYS[\"Function\"];\nexport const FUNCTIONPARENT_TYPES = FLIPPED_ALIAS_KEYS[\"FunctionParent\"];\nexport const PUREISH_TYPES = FLIPPED_ALIAS_KEYS[\"Pureish\"];\nexport const DECLARATION_TYPES = FLIPPED_ALIAS_KEYS[\"Declaration\"];\nexport const PATTERNLIKE_TYPES = FLIPPED_ALIAS_KEYS[\"PatternLike\"];\nexport const LVAL_TYPES = FLIPPED_ALIAS_KEYS[\"LVal\"];\nexport const TSENTITYNAME_TYPES = FLIPPED_ALIAS_KEYS[\"TSEntityName\"];\nexport const LITERAL_TYPES = FLIPPED_ALIAS_KEYS[\"Literal\"];\nexport const IMMUTABLE_TYPES = FLIPPED_ALIAS_KEYS[\"Immutable\"];\nexport const USERWHITESPACABLE_TYPES = FLIPPED_ALIAS_KEYS[\"UserWhitespacable\"];\nexport const METHOD_TYPES = FLIPPED_ALIAS_KEYS[\"Method\"];\nexport const OBJECTMEMBER_TYPES = FLIPPED_ALIAS_KEYS[\"ObjectMember\"];\nexport const PROPERTY_TYPES = FLIPPED_ALIAS_KEYS[\"Property\"];\nexport const UNARYLIKE_TYPES = FLIPPED_ALIAS_KEYS[\"UnaryLike\"];\nexport const PATTERN_TYPES = FLIPPED_ALIAS_KEYS[\"Pattern\"];\nexport const CLASS_TYPES = FLIPPED_ALIAS_KEYS[\"Class\"];\nexport const IMPORTOREXPORTDECLARATION_TYPES =\n  FLIPPED_ALIAS_KEYS[\"ImportOrExportDeclaration\"];\nexport const EXPORTDECLARATION_TYPES = FLIPPED_ALIAS_KEYS[\"ExportDeclaration\"];\nexport const MODULESPECIFIER_TYPES = FLIPPED_ALIAS_KEYS[\"ModuleSpecifier\"];\nexport const ACCESSOR_TYPES = FLIPPED_ALIAS_KEYS[\"Accessor\"];\nexport const PRIVATE_TYPES = FLIPPED_ALIAS_KEYS[\"Private\"];\nexport const FLOW_TYPES = FLIPPED_ALIAS_KEYS[\"Flow\"];\nexport const FLOWTYPE_TYPES = FLIPPED_ALIAS_KEYS[\"FlowType\"];\nexport const FLOWBASEANNOTATION_TYPES =\n  FLIPPED_ALIAS_KEYS[\"FlowBaseAnnotation\"];\nexport const FLOWDECLARATION_TYPES = FLIPPED_ALIAS_KEYS[\"FlowDeclaration\"];\nexport const FLOWPREDICATE_TYPES = FLIPPED_ALIAS_KEYS[\"FlowPredicate\"];\nexport const ENUMBODY_TYPES = FLIPPED_ALIAS_KEYS[\"EnumBody\"];\nexport const ENUMMEMBER_TYPES = FLIPPED_ALIAS_KEYS[\"EnumMember\"];\nexport const JSX_TYPES = FLIPPED_ALIAS_KEYS[\"JSX\"];\nexport const MISCELLANEOUS_TYPES = FLIPPED_ALIAS_KEYS[\"Miscellaneous\"];\nexport const TYPESCRIPT_TYPES = FLIPPED_ALIAS_KEYS[\"TypeScript\"];\nexport const TSTYPEELEMENT_TYPES = FLIPPED_ALIAS_KEYS[\"TSTypeElement\"];\nexport const TSTYPE_TYPES = FLIPPED_ALIAS_KEYS[\"TSType\"];\nexport const TSBASETYPE_TYPES = FLIPPED_ALIAS_KEYS[\"TSBaseType\"];\n/**\n * @deprecated migrate to IMPORTOREXPORTDECLARATION_TYPES.\n */\nexport const MODULEDECLARATION_TYPES = IMPORTOREXPORTDECLARATION_TYPES;\n", "import {\n  isBlockStatement,\n  isFunction,\n  isEmptyStatement,\n  isStatement,\n} from \"../validators/generated/index.ts\";\nimport {\n  returnStatement,\n  expressionStatement,\n  blockStatement,\n} from \"../builders/generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default function toBlock(\n  node: t.Statement | t.Expression,\n  parent?: t.Node,\n): t.BlockStatement {\n  if (isBlockStatement(node)) {\n    return node;\n  }\n\n  let blockNodes: t.Statement[] = [];\n\n  if (isEmptyStatement(node)) {\n    blockNodes = [];\n  } else {\n    if (!isStatement(node)) {\n      if (isFunction(parent)) {\n        node = returnStatement(node);\n      } else {\n        node = expressionStatement(node);\n      }\n    }\n\n    blockNodes = [node];\n  }\n\n  return blockStatement(blockNodes);\n}\n", "import toBlock from \"./toBlock.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Ensure the `key` (defaults to \"body\") of a `node` is a block.\n * Casting it to a block if it is not.\n *\n * Returns the BlockStatement\n */\nexport default function ensureBlock(\n  node: t.Node,\n  key: string = \"body\",\n): t.BlockStatement {\n  // @ts-expect-error Fixme: key may not exist in node, consider remove key = \"body\"\n  const result = toBlock(node[key], node);\n  // @ts-expect-error Fixme: key may not exist in node, consider remove key = \"body\"\n  node[key] = result;\n  return result;\n}\n", "import isValidIdentifier from \"../validators/isValidIdentifier.ts\";\nimport { isIdentifierChar } from \"@babel/helper-validator-identifier\";\n\nexport default function toIdentifier(input: string): string {\n  input = input + \"\";\n\n  // replace all non-valid identifiers with dashes\n  let name = \"\";\n  for (const c of input) {\n    name += isIdentifierChar(c.codePointAt(0)) ? c : \"-\";\n  }\n\n  // remove all dashes and numbers from start of name\n  name = name.replace(/^[-0-9]+/, \"\");\n\n  // camel case\n  name = name.replace(/[-\\s]+(.)?/g, function (match, c) {\n    return c ? c.toUpperCase() : \"\";\n  });\n\n  if (!isValidIdentifier(name)) {\n    name = `_${name}`;\n  }\n\n  return name || \"_\";\n}\n", "import toIdentifier from \"./toIdentifier.ts\";\n\nexport default function toBindingIdentifierName(name: string): string {\n  name = toIdentifier(name);\n  if (name === \"eval\" || name === \"arguments\") name = \"_\" + name;\n\n  return name;\n}\n", "import { isIdentifier } from \"../validators/generated/index.ts\";\nimport { stringLiteral } from \"../builders/generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default function toComputedKey(\n  node:\n    | t.ObjectMember\n    | t.ObjectProperty\n    | t.ClassMethod\n    | t.ClassProperty\n    | t.ClassAccessorProperty\n    | t.MemberExpression\n    | t.OptionalMemberExpression,\n  // @ts-expect-error todo(flow->ts): maybe check the type of node before accessing .key and .property\n  key: t.Expression | t.PrivateName = node.key || node.property,\n) {\n  if (!node.computed && isIdentifier(key)) key = stringLiteral(key.name);\n\n  return key;\n}\n", "import {\n  isExpression,\n  isFunction,\n  isClass,\n  isExpressionStatement,\n} from \"../validators/generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default toExpression as {\n  (node: t.Function): t.FunctionExpression;\n  (node: t.Class): t.ClassExpression;\n  (\n    node: t.ExpressionStatement | t.Expression | t.Class | t.Function,\n  ): t.Expression;\n};\n\nfunction toExpression(\n  node: t.ExpressionStatement | t.Expression | t.Class | t.Function,\n): t.Expression {\n  if (isExpressionStatement(node)) {\n    node = node.expression;\n  }\n\n  // return unmodified node\n  // important for things like ArrowFunctions where\n  // type change from ArrowFunction to FunctionExpression\n  // produces bugs like -> `()=>a` to `function () a`\n  // without generating a BlockStatement for it\n  // ref: https://github.com/babel/babili/issues/130\n  if (isExpression(node)) {\n    return node;\n  }\n\n  // convert all classes and functions\n  // ClassDeclaration -> ClassExpression\n  // FunctionDeclaration, ObjectMethod, ClassMethod -> FunctionExpression\n  if (isClass(node)) {\n    // @ts-expect-error todo(flow->ts): avoid type unsafe mutations\n    node.type = \"ClassExpression\";\n  } else if (isFunction(node)) {\n    // @ts-expect-error todo(flow->ts): avoid type unsafe mutations\n    node.type = \"FunctionExpression\";\n  }\n\n  // if it's still not an expression\n  if (!isExpression(node)) {\n    throw new Error(`cannot turn ${node.type} to an expression`);\n  }\n\n  return node;\n}\n", "import { VISITOR_KEYS } from \"../definitions/index.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * A prefix AST traversal implementation meant for simple searching\n * and processing.\n */\nexport default function traverseFast<Options = object>(\n  node: t.Node | null | undefined,\n  enter: (node: t.Node, opts?: Options) => void,\n  opts?: Options,\n): void {\n  if (!node) return;\n\n  const keys = VISITOR_KEYS[node.type];\n  if (!keys) return;\n\n  opts = opts || ({} as Options);\n  enter(node, opts);\n\n  for (const key of keys) {\n    const subNode: t.Node | undefined | null =\n      // @ts-expect-error key must present in node\n      node[key];\n\n    if (Array.isArray(subNode)) {\n      for (const node of subNode) {\n        traverseFast(node, enter, opts);\n      }\n    } else {\n      traverseFast(subNode, enter, opts);\n    }\n  }\n}\n", "import { COMMENT_KEYS } from \"../constants/index.ts\";\nimport type * as t from \"../index.ts\";\n\nconst CLEAR_KEYS = [\n  \"tokens\", // only exist in t.File\n  \"start\",\n  \"end\",\n  \"loc\",\n  // Fixme: should be extra.raw / extra.rawValue?\n  \"raw\",\n  \"rawValue\",\n] as const;\n\nconst CLEAR_KEYS_PLUS_COMMENTS = [\n  ...COMMENT_KEYS,\n  \"comments\",\n  ...CLEAR_KEYS,\n] as const;\n\nexport type Options = { preserveComments?: boolean };\n/**\n * Remove all of the _* properties from a node along with the additional metadata\n * properties like location data and raw token data.\n */\nexport default function removeProperties(\n  node: t.Node,\n  opts: Options = {},\n): void {\n  const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;\n  for (const key of map) {\n    // @ts-expect-error tokens only exist in t.File\n    if (node[key] != null) node[key] = undefined;\n  }\n\n  for (const key of Object.keys(node)) {\n    // @ts-expect-error string can not index node\n    if (key[0] === \"_\" && node[key] != null) node[key] = undefined;\n  }\n\n  const symbols: Array<symbol> = Object.getOwnPropertySymbols(node);\n  for (const sym of symbols) {\n    // @ts-expect-error Fixme: document symbol properties\n    node[sym] = null;\n  }\n}\n", "import traverseFast from \"../traverse/traverseFast.ts\";\nimport removeProperties from \"./removeProperties.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default function removePropertiesDeep<T extends t.Node>(\n  tree: T,\n  opts?: { preserveComments: boolean } | null,\n): T {\n  traverseFast(tree, removeProperties, opts);\n\n  return tree;\n}\n", "import {\n  isIdentifier,\n  isStringLiteral,\n} from \"../validators/generated/index.ts\";\nimport cloneNode from \"../clone/cloneNode.ts\";\nimport removePropertiesDeep from \"../modifications/removePropertiesDeep.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default function toKeyAlias(\n  node: t.Method | t.Property,\n  key: t.Node = node.key,\n): string {\n  let alias;\n\n  // @ts-expect-error todo(flow->ts): maybe add node type check before checking `.kind`\n  if (node.kind === \"method\") {\n    return toKeyAlias.increment() + \"\";\n  } else if (isIdentifier(key)) {\n    alias = key.name;\n  } else if (isStringLiteral(key)) {\n    alias = JSON.stringify(key.value);\n  } else {\n    alias = JSON.stringify(removePropertiesDeep(cloneNode(key)));\n  }\n\n  // @ts-expect-error todo(flow->ts): maybe add node type check before checking `.computed`\n  if (node.computed) {\n    alias = `[${alias}]`;\n  }\n\n  // @ts-expect-error todo(flow->ts): maybe add node type check before checking `.static`\n  if (node.static) {\n    alias = `static:${alias}`;\n  }\n\n  return alias;\n}\n\ntoKeyAlias.uid = 0;\n\ntoKeyAlias.increment = function () {\n  if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {\n    return (toKeyAlias.uid = 0);\n  } else {\n    return toKeyAlias.uid++;\n  }\n};\n", "import {\n  isStatement,\n  isFunction,\n  isClass,\n  isAssignmentExpression,\n} from \"../validators/generated/index.ts\";\nimport { expressionStatement } from \"../builders/generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default toStatement as {\n  (node: t.AssignmentExpression, ignore?: boolean): t.ExpressionStatement;\n\n  <T extends t.Statement>(node: T, ignore: false): T;\n  <T extends t.Statement>(node: T, ignore?: boolean): T | false;\n\n  (node: t.Class, ignore: false): t.ClassDeclaration;\n  (node: t.Class, ignore?: boolean): t.ClassDeclaration | false;\n\n  (node: t.Function, ignore: false): t.FunctionDeclaration;\n  (node: t.Function, ignore?: boolean): t.FunctionDeclaration | false;\n\n  (node: t.Node, ignore: false): t.Statement;\n  (node: t.Node, ignore?: boolean): t.Statement | false;\n};\n\nfunction toStatement(node: t.Node, ignore?: boolean): t.Statement | false {\n  if (isStatement(node)) {\n    return node;\n  }\n\n  let mustHaveId = false;\n  let newType;\n\n  if (isClass(node)) {\n    mustHaveId = true;\n    newType = \"ClassDeclaration\" as const;\n  } else if (isFunction(node)) {\n    mustHaveId = true;\n    newType = \"FunctionDeclaration\" as const;\n  } else if (isAssignmentExpression(node)) {\n    return expressionStatement(node);\n  }\n\n  // @ts-expect-error todo(flow->ts): node.id might be missing\n  if (mustHaveId && !node.id) {\n    newType = false;\n  }\n\n  if (!newType) {\n    if (ignore) {\n      return false;\n    } else {\n      throw new Error(`cannot turn ${node.type} to a statement`);\n    }\n  }\n\n  // @ts-expect-error manipulating node.type\n  node.type = newType;\n\n  // @ts-expect-error todo(flow->ts) refactor to avoid type unsafe mutations like reassigning node type above\n  return node;\n}\n", "import isValidIdentifier from \"../validators/isValidIdentifier.ts\";\nimport {\n  identifier,\n  booleanLiteral,\n  nullLiteral,\n  stringLiteral,\n  numericLiteral,\n  regExpLiteral,\n  arrayExpression,\n  objectProperty,\n  objectExpression,\n  unaryExpression,\n  binaryExpression,\n} from \"../builders/generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default valueToNode as {\n  (value: undefined): t.Identifier; // TODO: This should return \"void 0\"\n  (value: boolean): t.BooleanLiteral;\n  (value: null): t.NullLiteral;\n  (value: string): t.StringLiteral;\n  // Infinities and NaN need to use a BinaryExpression; negative values must be wrapped in UnaryExpression\n  (value: number): t.NumericLiteral | t.BinaryExpression | t.UnaryExpression;\n  (value: RegExp): t.RegExpLiteral;\n  (value: ReadonlyArray<unknown>): t.ArrayExpression;\n\n  // this throws with objects that are not plain objects,\n  // or if there are non-valueToNode-able values\n  (value: object): t.ObjectExpression;\n\n  (value: unknown): t.Expression;\n};\n\n// @ts-expect-error: Object.prototype.toString must return a string\nconst objectToString: (value: unknown) => string = Function.call.bind(\n  Object.prototype.toString,\n);\n\nfunction isRegExp(value: unknown): value is RegExp {\n  return objectToString(value) === \"[object RegExp]\";\n}\n\nfunction isPlainObject(value: unknown): value is object {\n  if (\n    typeof value !== \"object\" ||\n    value === null ||\n    Object.prototype.toString.call(value) !== \"[object Object]\"\n  ) {\n    return false;\n  }\n  const proto = Object.getPrototypeOf(value);\n  // Object.prototype's __proto__ is null. Every other class's __proto__.__proto__ is\n  // not null by default. We cannot check if proto === Object.prototype because it\n  // could come from another realm.\n  return proto === null || Object.getPrototypeOf(proto) === null;\n}\n\nfunction valueToNode(value: unknown): t.Expression {\n  // undefined\n  if (value === undefined) {\n    return identifier(\"undefined\");\n  }\n\n  // boolean\n  if (value === true || value === false) {\n    return booleanLiteral(value);\n  }\n\n  // null\n  if (value === null) {\n    return nullLiteral();\n  }\n\n  // strings\n  if (typeof value === \"string\") {\n    return stringLiteral(value);\n  }\n\n  // numbers\n  if (typeof value === \"number\") {\n    let result;\n    if (Number.isFinite(value)) {\n      result = numericLiteral(Math.abs(value));\n    } else {\n      let numerator;\n      if (Number.isNaN(value)) {\n        // NaN\n        numerator = numericLiteral(0);\n      } else {\n        // Infinity / -Infinity\n        numerator = numericLiteral(1);\n      }\n\n      result = binaryExpression(\"/\", numerator, numericLiteral(0));\n    }\n\n    if (value < 0 || Object.is(value, -0)) {\n      result = unaryExpression(\"-\", result);\n    }\n\n    return result;\n  }\n\n  // regexes\n  if (isRegExp(value)) {\n    const pattern = value.source;\n    const flags = /\\/([a-z]*)$/.exec(value.toString())[1];\n    return regExpLiteral(pattern, flags);\n  }\n\n  // array\n  if (Array.isArray(value)) {\n    return arrayExpression(value.map(valueToNode));\n  }\n\n  // object\n  if (isPlainObject(value)) {\n    const props = [];\n    for (const key of Object.keys(value)) {\n      let nodeKey;\n      if (isValidIdentifier(key)) {\n        nodeKey = identifier(key);\n      } else {\n        nodeKey = stringLiteral(key);\n      }\n      props.push(\n        objectProperty(\n          nodeKey,\n          valueToNode(\n            // @ts-expect-error key must present in value\n            value[key],\n          ),\n        ),\n      );\n    }\n    return objectExpression(props);\n  }\n\n  throw new Error(\"don't know how to turn this value into a node\");\n}\n", "import { memberExpression } from \"../builders/generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Append a node to a member expression.\n */\nexport default function appendToMemberExpression(\n  member: t.MemberExpression,\n  append: t.MemberExpression[\"property\"],\n  computed: boolean = false,\n): t.MemberExpression {\n  member.object = memberExpression(\n    member.object,\n    member.property,\n    member.computed,\n  );\n  member.property = append;\n  member.computed = !!computed;\n\n  return member;\n}\n", "import { INHERIT_KEYS } from \"../constants/index.ts\";\nimport inheritsComments from \"../comments/inheritsComments.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Inherit all contextual properties from `parent` node to `child` node.\n */\nexport default function inherits<T extends t.Node | null | undefined>(\n  child: T,\n  parent: t.Node | null | undefined,\n): T {\n  if (!child || !parent) return child;\n\n  // optionally inherit specific properties if not null\n  for (const key of INHERIT_KEYS.optional) {\n    // @ts-expect-error Fixme: refine parent types\n    if (child[key] == null) {\n      // @ts-expect-error Fixme: refine parent types\n      child[key] = parent[key];\n    }\n  }\n\n  // force inherit \"private\" properties\n  for (const key of Object.keys(parent)) {\n    if (key[0] === \"_\" && key !== \"__clone\") {\n      // @ts-expect-error Fixme: refine parent types\n      child[key] = parent[key];\n    }\n  }\n\n  // force inherit select properties\n  for (const key of INHERIT_KEYS.force) {\n    // @ts-expect-error Fixme: refine parent types\n    child[key] = parent[key];\n  }\n\n  inheritsComments(child, parent);\n\n  return child;\n}\n", "import { memberExpression } from \"../builders/generated/index.ts\";\nimport { isSuper } from \"../index.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Prepend a node to a member expression.\n */\nexport default function prependToMemberExpression<\n  T extends Pick<t.MemberExpression, \"object\" | \"property\">,\n>(member: T, prepend: t.MemberExpression[\"object\"]): T {\n  if (isSuper(member.object)) {\n    throw new Error(\n      \"Cannot prepend node to super property access (`super.foo`).\",\n    );\n  }\n  member.object = memberExpression(prepend, member.object);\n\n  return member;\n}\n", "import type * as t from \"../index.ts\";\n\n/**\n * For the given node, generate a map from assignment id names to the identifier node.\n * Unlike getBindingIdentifiers, this function does not handle declarations and imports.\n * @param node the assignment expression or forXstatement\n * @returns an object map\n * @see getBindingIdentifiers\n */\nexport default function getAssignmentIdentifiers(\n  node: t.Node | t.Node[],\n): Record<string, t.Identifier> {\n  // null represents holes in an array pattern\n  const search: (t.Node | null)[] = [].concat(node);\n  const ids = Object.create(null);\n\n  while (search.length) {\n    const id = search.pop();\n    if (!id) continue;\n\n    switch (id.type) {\n      case \"ArrayPattern\":\n        search.push(...id.elements);\n        break;\n\n      case \"AssignmentExpression\":\n      case \"AssignmentPattern\":\n      case \"ForInStatement\":\n      case \"ForOfStatement\":\n        search.push(id.left);\n        break;\n\n      case \"ObjectPattern\":\n        search.push(...id.properties);\n        break;\n\n      case \"ObjectProperty\":\n        search.push(id.value);\n        break;\n\n      case \"RestElement\":\n      case \"UpdateExpression\":\n        search.push(id.argument);\n        break;\n\n      case \"UnaryExpression\":\n        if (id.operator === \"delete\") {\n          search.push(id.argument);\n        }\n        break;\n\n      case \"Identifier\":\n        ids[id.name] = id;\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  return ids;\n}\n", "import {\n  isExportDeclaration,\n  isIdentifier,\n  isClassExpression,\n  isDeclaration,\n  isFunctionDeclaration,\n  isFunctionExpression,\n  isExportAllDeclaration,\n  isAssignmentExpression,\n  isUnaryExpression,\n  isUpdateExpression,\n} from \"../validators/generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\nexport { getBindingIdentifiers as default };\n\nfunction getBindingIdentifiers(\n  node: t.Node,\n  duplicates: true,\n  outerOnly?: boolean,\n  newBindingsOnly?: boolean,\n): Record<string, Array<t.Identifier>>;\n\nfunction getBindingIdentifiers(\n  node: t.Node,\n  duplicates?: false,\n  outerOnly?: boolean,\n  newBindingsOnly?: boolean,\n): Record<string, t.Identifier>;\n\nfunction getBindingIdentifiers(\n  node: t.Node,\n  duplicates?: boolean,\n  outerOnly?: boolean,\n  newBindingsOnly?: boolean,\n): Record<string, t.Identifier> | Record<string, Array<t.Identifier>>;\n\n/**\n * Return a list of binding identifiers associated with the input `node`.\n */\nfunction getBindingIdentifiers(\n  node: t.Node,\n  duplicates?: boolean,\n  outerOnly?: boolean,\n  newBindingsOnly?: boolean,\n): Record<string, t.Identifier> | Record<string, Array<t.Identifier>> {\n  const search: t.Node[] = [].concat(node);\n  const ids = Object.create(null);\n\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n\n    if (\n      newBindingsOnly &&\n      // These nodes do not introduce _new_ bindings, but they are included\n      // in getBindingIdentifiers.keys for backwards compatibility.\n      // TODO(@nicolo-ribaudo): Check if we can remove them from .keys in a\n      // backward-compatible way, and if not what we need to do to remove them\n      // in Babel 8.\n      (isAssignmentExpression(id) ||\n        isUnaryExpression(id) ||\n        isUpdateExpression(id))\n    ) {\n      continue;\n    }\n\n    if (isIdentifier(id)) {\n      if (duplicates) {\n        const _ids = (ids[id.name] = ids[id.name] || []);\n        _ids.push(id);\n      } else {\n        ids[id.name] = id;\n      }\n      continue;\n    }\n\n    if (isExportDeclaration(id) && !isExportAllDeclaration(id)) {\n      if (isDeclaration(id.declaration)) {\n        search.push(id.declaration);\n      }\n      continue;\n    }\n\n    if (outerOnly) {\n      if (isFunctionDeclaration(id)) {\n        search.push(id.id);\n        continue;\n      }\n\n      if (\n        isFunctionExpression(id) ||\n        (process.env.BABEL_8_BREAKING && isClassExpression(id))\n      ) {\n        continue;\n      }\n    }\n\n    const keys = getBindingIdentifiers.keys[id.type];\n\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const nodes =\n          // @ts-expect-error key must present in id\n          id[key] as t.Node[] | t.Node | undefined | null;\n        if (nodes) {\n          if (Array.isArray(nodes)) {\n            search.push(...nodes);\n          } else {\n            search.push(nodes);\n          }\n        }\n      }\n    }\n  }\n  return ids;\n}\n\n/**\n * Mapping of types to their identifier keys.\n */\ntype KeysMap = {\n  [N in t.Node as N[\"type\"]]?: (keyof N)[];\n};\n\nconst keys: KeysMap = {\n  DeclareClass: [\"id\"],\n  DeclareFunction: [\"id\"],\n  DeclareModule: [\"id\"],\n  DeclareVariable: [\"id\"],\n  DeclareInterface: [\"id\"],\n  DeclareTypeAlias: [\"id\"],\n  DeclareOpaqueType: [\"id\"],\n  InterfaceDeclaration: [\"id\"],\n  TypeAlias: [\"id\"],\n  OpaqueType: [\"id\"],\n\n  CatchClause: [\"param\"],\n  LabeledStatement: [\"label\"],\n  UnaryExpression: [\"argument\"],\n  AssignmentExpression: [\"left\"],\n\n  ImportSpecifier: [\"local\"],\n  ImportNamespaceSpecifier: [\"local\"],\n  ImportDefaultSpecifier: [\"local\"],\n  ImportDeclaration: [\"specifiers\"],\n\n  ExportSpecifier: [\"exported\"],\n  ExportNamespaceSpecifier: [\"exported\"],\n  ExportDefaultSpecifier: [\"exported\"],\n\n  FunctionDeclaration: [\"id\", \"params\"],\n  FunctionExpression: [\"id\", \"params\"],\n  ArrowFunctionExpression: [\"params\"],\n  ObjectMethod: [\"params\"],\n  ClassMethod: [\"params\"],\n  ClassPrivateMethod: [\"params\"],\n\n  ForInStatement: [\"left\"],\n  ForOfStatement: [\"left\"],\n\n  ClassDeclaration: [\"id\"],\n  ClassExpression: [\"id\"],\n\n  RestElement: [\"argument\"],\n  UpdateExpression: [\"argument\"],\n\n  ObjectProperty: [\"value\"],\n\n  AssignmentPattern: [\"left\"],\n  ArrayPattern: [\"elements\"],\n  ObjectPattern: [\"properties\"],\n\n  VariableDeclaration: [\"declarations\"],\n  VariableDeclarator: [\"id\"],\n};\n\ngetBindingIdentifiers.keys = keys;\n", "import getBindingIdentifiers from \"./getBindingIdentifiers.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default getOuterBindingIdentifiers as {\n  (node: t.Node, duplicates: true): Record<string, Array<t.Identifier>>;\n  (node: t.Node, duplicates?: false): Record<string, t.Identifier>;\n  (\n    node: t.Node,\n    duplicates?: boolean,\n  ): Record<string, t.Identifier> | Record<string, Array<t.Identifier>>;\n};\n\nfunction getOuterBindingIdentifiers(\n  node: t.Node,\n  duplicates: boolean,\n): Record<string, t.Identifier> | Record<string, Array<t.Identifier>> {\n  return getBindingIdentifiers(node, duplicates, true);\n}\n", "import type * as t from \"../index.ts\";\n\nimport {\n  isAssignmentExpression,\n  isClassMethod,\n  isIdentifier,\n  isLiteral,\n  isNullLiteral,\n  isObjectMethod,\n  isObjectProperty,\n  isPrivateName,\n  isRegExpLiteral,\n  isTemplateLiteral,\n  isVariableDeclarator,\n} from \"../validators/generated/index.ts\";\n\nfunction getNameFromLiteralId(id: t.Literal): string {\n  if (isNullLiteral(id)) {\n    return \"null\";\n  }\n\n  if (isRegExpLiteral(id)) {\n    return `/${id.pattern}/${id.flags}`;\n  }\n\n  if (isTemplateLiteral(id)) {\n    return id.quasis.map(quasi => quasi.value.raw).join(\"\");\n  }\n\n  if (id.value !== undefined) {\n    return String(id.value);\n  }\n\n  return null;\n}\n\nfunction getObjectMemberKey(\n  node: t.ObjectProperty | t.ObjectMethod | t.ClassProperty | t.ClassMethod,\n): t.Expression | t.PrivateName {\n  if (!node.computed || isLiteral(node.key)) {\n    return node.key;\n  }\n}\n\ntype GetFunctionNameResult = {\n  name: string;\n  originalNode: t.Node;\n} | null;\n\nexport default function getFunctionName(\n  node: t.ObjectMethod | t.ClassMethod,\n): GetFunctionNameResult;\nexport default function getFunctionName(\n  node: t.Function | t.Class,\n  parent: t.Node,\n): GetFunctionNameResult;\nexport default function getFunctionName(\n  node: t.Function | t.Class,\n  parent?: t.Node,\n): GetFunctionNameResult {\n  if (\"id\" in node && node.id) {\n    return {\n      name: node.id.name,\n      originalNode: node.id,\n    };\n  }\n\n  let prefix = \"\";\n\n  let id;\n  if (isObjectProperty(parent, { value: node })) {\n    // { foo: () => {} };\n    id = getObjectMemberKey(parent);\n  } else if (isObjectMethod(node) || isClassMethod(node)) {\n    // { foo() {} };\n    id = getObjectMemberKey(node);\n    if (node.kind === \"get\") prefix = \"get \";\n    else if (node.kind === \"set\") prefix = \"set \";\n  } else if (isVariableDeclarator(parent, { init: node })) {\n    // let foo = function () {};\n    id = parent.id;\n  } else if (isAssignmentExpression(parent, { operator: \"=\", right: node })) {\n    // foo = function () {};\n    id = parent.left;\n  }\n\n  if (!id) return null;\n\n  const name = isLiteral(id)\n    ? getNameFromLiteralId(id)\n    : isIdentifier(id)\n      ? id.name\n      : isPrivateName(id)\n        ? id.id.name\n        : null;\n  if (name == null) return null;\n\n  return { name: prefix + name, originalNode: id };\n}\n", "import { VISITOR_KEYS } from \"../definitions/index.ts\";\nimport type * as t from \"../index.ts\";\n\nexport type TraversalAncestors = Array<{\n  node: t.Node;\n  key: string;\n  index?: number;\n}>;\n\nexport type TraversalHandler<T> = (\n  this: undefined,\n  node: t.Node,\n  parent: TraversalAncestors,\n  state: T,\n) => void;\n\nexport type TraversalHandlers<T> = {\n  enter?: TraversalHandler<T>;\n  exit?: TraversalHandler<T>;\n};\n\n/**\n * A general AST traversal with both prefix and postfix handlers, and a\n * state object. Exposes ancestry data to each handler so that more complex\n * AST data can be taken into account.\n */\nexport default function traverse<T>(\n  node: t.Node,\n  handlers: TraversalHandler<T> | TraversalHandlers<T>,\n  state?: T,\n): void {\n  if (typeof handlers === \"function\") {\n    handlers = { enter: handlers };\n  }\n\n  const { enter, exit } = handlers;\n\n  traverseSimpleImpl(node, enter, exit, state, []);\n}\n\nfunction traverseSimpleImpl<T>(\n  node: any,\n  enter: Function | undefined,\n  exit: Function | undefined,\n  state: T | undefined,\n  ancestors: TraversalAncestors,\n) {\n  const keys = VISITOR_KEYS[node.type];\n  if (!keys) return;\n\n  if (enter) enter(node, ancestors, state);\n\n  for (const key of keys) {\n    const subNode = node[key];\n\n    if (Array.isArray(subNode)) {\n      for (let i = 0; i < subNode.length; i++) {\n        const child = subNode[i];\n        if (!child) continue;\n\n        ancestors.push({\n          node,\n          key,\n          index: i,\n        });\n\n        traverseSimpleImpl(child, enter, exit, state, ancestors);\n\n        ancestors.pop();\n      }\n    } else if (subNode) {\n      ancestors.push({\n        node,\n        key,\n      });\n\n      traverseSimpleImpl(subNode, enter, exit, state, ancestors);\n\n      ancestors.pop();\n    }\n  }\n\n  if (exit) exit(node, ancestors, state);\n}\n", "import getBindingIdentifiers from \"../retrievers/getBindingIdentifiers.ts\";\nimport type * as t from \"../index.ts\";\n/**\n * Check if the input `node` is a binding identifier.\n */\nexport default function isBinding(\n  node: t.Node,\n  parent: t.Node,\n  grandparent?: t.Node,\n): boolean {\n  if (\n    grandparent &&\n    node.type === \"Identifier\" &&\n    parent.type === \"ObjectProperty\" &&\n    grandparent.type === \"ObjectExpression\"\n  ) {\n    // We need to special-case this, because getBindingIdentifiers\n    // has an ObjectProperty->value entry for destructuring patterns.\n    return false;\n  }\n\n  const keys = getBindingIdentifiers.keys[parent.type];\n  if (keys) {\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const val =\n        // @ts-expect-error key must present in parent\n        parent[key];\n      if (Array.isArray(val)) {\n        if (val.includes(node)) return true;\n      } else {\n        if (val === node) return true;\n      }\n    }\n  }\n\n  return false;\n}\n", "import { isVariableDeclaration } from \"./generated/index.ts\";\nimport { BLOCK_SCOPED_SYMBOL } from \"../constants/index.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Check if the input `node` is a `let` variable declaration.\n */\nexport default function isLet(node: t.Node): boolean {\n  return (\n    isVariableDeclaration(node) &&\n    (node.kind !== \"var\" ||\n      // @ts-expect-error Fixme: document private properties\n      node[BLOCK_SCOPED_SYMBOL])\n  );\n}\n", "import {\n  isClassDeclaration,\n  isFunctionDeclaration,\n} from \"./generated/index.ts\";\nimport isLet from \"./isLet.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Check if the input `node` is block scoped.\n */\nexport default function isBlockScoped(node: t.Node): boolean {\n  return isFunctionDeclaration(node) || isClassDeclaration(node) || isLet(node);\n}\n", "import isType from \"./isType.ts\";\nimport { isIdentifier } from \"./generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Check if the input `node` is definitely immutable.\n */\nexport default function isImmutable(node: t.Node): boolean {\n  if (isType(node.type, \"Immutable\")) return true;\n\n  if (isIdentifier(node)) {\n    if (node.name === \"undefined\") {\n      // immutable!\n      return true;\n    } else {\n      // no idea...\n      return false;\n    }\n  }\n\n  return false;\n}\n", "import { NODE_FIELDS, VISITOR_KEYS } from \"../definitions/index.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Check if two nodes are equivalent\n */\nexport default function isNodesEquivalent<T extends Partial<t.Node>>(\n  a: T,\n  b: any,\n): b is T {\n  if (\n    typeof a !== \"object\" ||\n    typeof b !== \"object\" ||\n    a == null ||\n    b == null\n  ) {\n    return a === b;\n  }\n\n  if (a.type !== b.type) {\n    return false;\n  }\n\n  const fields = Object.keys(NODE_FIELDS[a.type] || a.type);\n  const visitorKeys = VISITOR_KEYS[a.type];\n\n  for (const field of fields) {\n    const val_a =\n      // @ts-expect-error field must present in a\n      a[field];\n    const val_b = b[field];\n    if (typeof val_a !== typeof val_b) {\n      return false;\n    }\n    if (val_a == null && val_b == null) {\n      continue;\n    } else if (val_a == null || val_b == null) {\n      return false;\n    }\n\n    if (Array.isArray(val_a)) {\n      if (!Array.isArray(val_b)) {\n        return false;\n      }\n      if (val_a.length !== val_b.length) {\n        return false;\n      }\n\n      for (let i = 0; i < val_a.length; i++) {\n        if (!isNodesEquivalent(val_a[i], val_b[i])) {\n          return false;\n        }\n      }\n      continue;\n    }\n\n    if (typeof val_a === \"object\" && !visitorKeys?.includes(field)) {\n      for (const key of Object.keys(val_a)) {\n        if (val_a[key] !== val_b[key]) {\n          return false;\n        }\n      }\n      continue;\n    }\n\n    if (!isNodesEquivalent(val_a, val_b)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n", "import type * as t from \"../index.ts\";\n\n/**\n * Check if the input `node` is a reference to a bound variable.\n */\nexport default function isReferenced(\n  node: t.Node,\n  parent: t.Node,\n  grandparent?: t.Node,\n): boolean {\n  switch (parent.type) {\n    // yes: PARENT[NODE]\n    // yes: NODE.child\n    // no: parent.NODE\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n      if (parent.property === node) {\n        return !!parent.computed;\n      }\n      return parent.object === node;\n\n    case \"JSXMemberExpression\":\n      return parent.object === node;\n    // no: let NODE = init;\n    // yes: let id = NODE;\n    case \"VariableDeclarator\":\n      return parent.init === node;\n\n    // yes: () => NODE\n    // no: (NODE) => {}\n    case \"ArrowFunctionExpression\":\n      return parent.body === node;\n\n    // no: class { #NODE; }\n    // no: class { get #NODE() {} }\n    // no: class { #NODE() {} }\n    // no: class { fn() { return this.#NODE; } }\n    case \"PrivateName\":\n      return false;\n\n    // no: class { NODE() {} }\n    // yes: class { [NODE]() {} }\n    // no: class { foo(NODE) {} }\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n    case \"ObjectMethod\":\n      if (parent.key === node) {\n        return !!parent.computed;\n      }\n      return false;\n\n    // yes: { [NODE]: \"\" }\n    // no: { NODE: \"\" }\n    // depends: { NODE }\n    // depends: { key: NODE }\n    case \"ObjectProperty\":\n      if (parent.key === node) {\n        return !!parent.computed;\n      }\n      // parent.value === node\n      return !grandparent || grandparent.type !== \"ObjectPattern\";\n    // no: class { NODE = value; }\n    // yes: class { [NODE] = value; }\n    // yes: class { key = NODE; }\n    case \"ClassProperty\":\n    case \"ClassAccessorProperty\":\n      if (parent.key === node) {\n        return !!parent.computed;\n      }\n      return true;\n    case \"ClassPrivateProperty\":\n      return parent.key !== node;\n\n    // no: class NODE {}\n    // yes: class Foo extends NODE {}\n    case \"ClassDeclaration\":\n    case \"ClassExpression\":\n      return parent.superClass === node;\n\n    // yes: left = NODE;\n    // no: NODE = right;\n    case \"AssignmentExpression\":\n      return parent.right === node;\n\n    // no: [NODE = foo] = [];\n    // yes: [foo = NODE] = [];\n    case \"AssignmentPattern\":\n      return parent.right === node;\n\n    // no: NODE: for (;;) {}\n    case \"LabeledStatement\":\n      return false;\n\n    // no: try {} catch (NODE) {}\n    case \"CatchClause\":\n      return false;\n\n    // no: function foo(...NODE) {}\n    case \"RestElement\":\n      return false;\n\n    case \"BreakStatement\":\n    case \"ContinueStatement\":\n      return false;\n\n    // no: function NODE() {}\n    // no: function foo(NODE) {}\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n      return false;\n\n    // no: export NODE from \"foo\";\n    // no: export * as NODE from \"foo\";\n    case \"ExportNamespaceSpecifier\":\n    case \"ExportDefaultSpecifier\":\n      return false;\n\n    // no: export { foo as NODE };\n    // yes: export { NODE as foo };\n    // no: export { NODE as foo } from \"foo\";\n    case \"ExportSpecifier\":\n      // @ts-expect-error todo(flow->ts): Property 'source' does not exist on type 'AnyTypeAnnotation'.\n      if (grandparent?.source) {\n        return false;\n      }\n      return parent.local === node;\n\n    // no: import NODE from \"foo\";\n    // no: import * as NODE from \"foo\";\n    // no: import { NODE as foo } from \"foo\";\n    // no: import { foo as NODE } from \"foo\";\n    // no: import NODE from \"bar\";\n    case \"ImportDefaultSpecifier\":\n    case \"ImportNamespaceSpecifier\":\n    case \"ImportSpecifier\":\n      return false;\n\n    // no: import \"foo\" assert { NODE: \"json\" }\n    case \"ImportAttribute\":\n      return false;\n\n    // no: <div NODE=\"foo\" />\n    case \"JSXAttribute\":\n      return false;\n\n    // no: [NODE] = [];\n    // no: ({ NODE }) = [];\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n      return false;\n\n    // no: new.NODE\n    // no: NODE.target\n    case \"MetaProperty\":\n      return false;\n\n    // yes: type X = { someProperty: NODE }\n    // no: type X = { NODE: OtherType }\n    case \"ObjectTypeProperty\":\n      return parent.key !== node;\n\n    // yes: enum X { Foo = NODE }\n    // no: enum X { NODE }\n    case \"TSEnumMember\":\n      return parent.id !== node;\n\n    // yes: { [NODE]: value }\n    // no: { NODE: value }\n    case \"TSPropertySignature\":\n      if (parent.key === node) {\n        return !!parent.computed;\n      }\n\n      return true;\n  }\n\n  return true;\n}\n", "import {\n  isFunction,\n  isCatchClause,\n  isBlockStatement,\n  isScopable,\n  isPattern,\n} from \"./generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Check if the input `node` is a scope.\n */\nexport default function isScope(node: t.Node, parent: t.Node): boolean {\n  // If a BlockStatement is an immediate descendent of a Function/CatchClause, it must be in the body.\n  // Hence we skipped the parentKey === \"params\" check\n  if (isBlockStatement(node) && (isFunction(parent) || isCatchClause(parent))) {\n    return false;\n  }\n\n  // If a Pattern is an immediate descendent of a Function/CatchClause, it must be in the params.\n  // Hence we skipped the parentKey === \"params\" check\n  if (isPattern(node) && (isFunction(parent) || isCatchClause(parent))) {\n    return true;\n  }\n\n  return isScopable(node);\n}\n", "import { isIdentifier, isImportDefaultSpecifier } from \"./generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Check if the input `specifier` is a `default` import or export.\n */\nexport default function isSpecifierDefault(\n  specifier: t.ModuleSpecifier,\n): boolean {\n  return (\n    isImportDefaultSpecifier(specifier) ||\n    // @ts-expect-error todo(flow->ts): stricter type for specifier\n    isIdentifier(specifier.imported || specifier.exported, {\n      name: \"default\",\n    })\n  );\n}\n", "import isValidIdentifier from \"./isValidIdentifier.ts\";\n\nconst RESERVED_WORDS_ES3_ONLY: Set<string> = new Set([\n  \"abstract\",\n  \"boolean\",\n  \"byte\",\n  \"char\",\n  \"double\",\n  \"enum\",\n  \"final\",\n  \"float\",\n  \"goto\",\n  \"implements\",\n  \"int\",\n  \"interface\",\n  \"long\",\n  \"native\",\n  \"package\",\n  \"private\",\n  \"protected\",\n  \"public\",\n  \"short\",\n  \"static\",\n  \"synchronized\",\n  \"throws\",\n  \"transient\",\n  \"volatile\",\n]);\n\n/**\n * Check if the input `name` is a valid identifier name according to the ES3 specification.\n *\n * Additional ES3 reserved words are\n */\nexport default function isValidES3Identifier(name: string): boolean {\n  return isValidIdentifier(name) && !RESERVED_WORDS_ES3_ONLY.has(name);\n}\n", "import { isVariableDeclaration } from \"./generated/index.ts\";\nimport { BLOCK_SCOPED_SYMBOL } from \"../constants/index.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Check if the input `node` is a variable declaration.\n */\nexport default function isVar(node: t.Node): boolean {\n  return (\n    isVariableDeclaration(node, { kind: \"var\" }) &&\n    !(\n      // @ts-expect-error document private properties\n      node[BLOCK_SCOPED_SYMBOL]\n    )\n  );\n}\n", "// TODO(Babel 8) Remove this file\nif (process.env.BABEL_8_BREAKING) {\n  throw new Error(\n    \"Internal Babel error: This file should only be loaded in Babel 7\",\n  );\n}\n\nimport getBindingIdentifiers from \"../retrievers/getBindingIdentifiers.ts\";\nimport {\n  isExpression,\n  isExpressionStatement,\n  isVariableDeclaration,\n  isIfStatement,\n  isBlockStatement,\n  isEmptyStatement,\n} from \"../validators/generated/index.ts\";\nimport {\n  sequenceExpression,\n  assignmentExpression,\n  conditionalExpression,\n} from \"../builders/generated/index.ts\";\nimport { buildUndefinedNode } from \"../builders/productions.ts\";\nimport cloneNode from \"../clone/cloneNode.ts\";\nimport type * as t from \"../index.ts\";\n\nexport type DeclarationInfo = {\n  kind: t.VariableDeclaration[\"kind\"];\n  id: t.Identifier;\n};\n\nexport default function gatherSequenceExpressions(\n  nodes: ReadonlyArray<t.Node>,\n  declars: Array<DeclarationInfo>,\n) {\n  const exprs: t.Expression[] = [];\n  let ensureLastUndefined = true;\n\n  for (const node of nodes) {\n    // if we encounter emptyStatement before a non-emptyStatement\n    // we want to disregard that\n    if (!isEmptyStatement(node)) {\n      ensureLastUndefined = false;\n    }\n\n    if (isExpression(node)) {\n      exprs.push(node);\n    } else if (isExpressionStatement(node)) {\n      exprs.push(node.expression);\n    } else if (isVariableDeclaration(node)) {\n      if (node.kind !== \"var\") return; // bailed\n\n      for (const declar of node.declarations) {\n        const bindings = getBindingIdentifiers(declar);\n        for (const key of Object.keys(bindings)) {\n          declars.push({\n            kind: node.kind,\n            id: cloneNode(bindings[key]),\n          });\n        }\n\n        if (declar.init) {\n          exprs.push(assignmentExpression(\"=\", declar.id, declar.init));\n        }\n      }\n\n      ensureLastUndefined = true;\n    } else if (isIfStatement(node)) {\n      const consequent = node.consequent\n        ? gatherSequenceExpressions([node.consequent], declars)\n        : buildUndefinedNode();\n      const alternate = node.alternate\n        ? gatherSequenceExpressions([node.alternate], declars)\n        : buildUndefinedNode();\n      if (!consequent || !alternate) return; // bailed\n\n      exprs.push(conditionalExpression(node.test, consequent, alternate));\n    } else if (isBlockStatement(node)) {\n      const body = gatherSequenceExpressions(node.body, declars);\n      if (!body) return; // bailed\n\n      exprs.push(body);\n    } else if (isEmptyStatement(node)) {\n      // empty statement so ensure the last item is undefined if we're last\n      // checks if emptyStatement is first\n      if (nodes.indexOf(node) === 0) {\n        ensureLastUndefined = true;\n      }\n    } else {\n      // bailed, we can't turn this statement into an expression\n      return;\n    }\n  }\n\n  if (ensureLastUndefined) {\n    exprs.push(buildUndefinedNode());\n  }\n\n  if (exprs.length === 1) {\n    return exprs[0];\n  } else {\n    return sequenceExpression(exprs);\n  }\n}\n", "// TODO(Babel 8) Remove this file\nif (process.env.BABEL_8_BREAKING) {\n  throw new Error(\n    \"Internal Babel error: This file should only be loaded in Babel 7\",\n  );\n}\n\nimport gatherSequenceExpressions from \"./gatherSequenceExpressions.ts\";\nimport type * as t from \"../index.ts\";\nimport type { DeclarationInfo } from \"./gatherSequenceExpressions.ts\";\n\n/**\n * Turn an array of statement `nodes` into a `SequenceExpression`.\n *\n * Variable declarations are turned into simple assignments and their\n * declarations hoisted to the top of the current scope.\n *\n * Expression statements are just resolved to their expression.\n */\nexport default function toSequenceExpression(\n  nodes: ReadonlyArray<t.Node>,\n  scope: any,\n): t.SequenceExpression | undefined {\n  if (!nodes?.length) return;\n\n  const declars: DeclarationInfo[] = [];\n  const result = gatherSequenceExpressions(nodes, declars);\n  if (!result) return;\n\n  for (const declar of declars) {\n    scope.push(declar);\n  }\n\n  // @ts-expect-error fixme: gatherSequenceExpressions will return an Expression when there are only one element\n  return result;\n}\n", "import isReactComponent from \"./validators/react/isReactComponent.ts\";\nimport isCompatTag from \"./validators/react/isCompatTag.ts\";\nimport buildChildren from \"./builders/react/buildChildren.ts\";\n\n// asserts\nexport { default as assertNode } from \"./asserts/assertNode.ts\";\nexport * from \"./asserts/generated/index.ts\";\n\n// builders\nexport { default as createTypeAnnotationBasedOnTypeof } from \"./builders/flow/createTypeAnnotationBasedOnTypeof.ts\";\n/** @deprecated use createFlowUnionType instead */\nexport { default as createUnionTypeAnnotation } from \"./builders/flow/createFlowUnionType.ts\";\nexport { default as createFlowUnionType } from \"./builders/flow/createFlowUnionType.ts\";\nexport { default as createTSUnionType } from \"./builders/typescript/createTSUnionType.ts\";\nexport * from \"./builders/generated/index.ts\";\n\nexport * from \"./builders/generated/uppercase.js\";\nexport * from \"./builders/productions.ts\";\n\n// clone\nexport { default as cloneNode } from \"./clone/cloneNode.ts\";\nexport { default as clone } from \"./clone/clone.ts\";\nexport { default as cloneDeep } from \"./clone/cloneDeep.ts\";\nexport { default as cloneDeepWithoutLoc } from \"./clone/cloneDeepWithoutLoc.ts\";\nexport { default as cloneWithoutLoc } from \"./clone/cloneWithoutLoc.ts\";\n\n// comments\nexport { default as addComment } from \"./comments/addComment.ts\";\nexport { default as addComments } from \"./comments/addComments.ts\";\nexport { default as inheritInnerComments } from \"./comments/inheritInnerComments.ts\";\nexport { default as inheritLeadingComments } from \"./comments/inheritLeadingComments.ts\";\nexport { default as inheritsComments } from \"./comments/inheritsComments.ts\";\nexport { default as inheritTrailingComments } from \"./comments/inheritTrailingComments.ts\";\nexport { default as removeComments } from \"./comments/removeComments.ts\";\n\n// constants\nexport * from \"./constants/generated/index.ts\";\nexport * from \"./constants/index.ts\";\n\n// converters\nexport { default as ensureBlock } from \"./converters/ensureBlock.ts\";\nexport { default as toBindingIdentifierName } from \"./converters/toBindingIdentifierName.ts\";\nexport { default as toBlock } from \"./converters/toBlock.ts\";\nexport { default as toComputedKey } from \"./converters/toComputedKey.ts\";\nexport { default as toExpression } from \"./converters/toExpression.ts\";\nexport { default as toIdentifier } from \"./converters/toIdentifier.ts\";\nexport { default as toKeyAlias } from \"./converters/toKeyAlias.ts\";\nexport { default as toStatement } from \"./converters/toStatement.ts\";\nexport { default as valueToNode } from \"./converters/valueToNode.ts\";\n\n// definitions\nexport * from \"./definitions/index.ts\";\n\n// modifications\nexport { default as appendToMemberExpression } from \"./modifications/appendToMemberExpression.ts\";\nexport { default as inherits } from \"./modifications/inherits.ts\";\nexport { default as prependToMemberExpression } from \"./modifications/prependToMemberExpression.ts\";\nexport {\n  default as removeProperties,\n  type Options as RemovePropertiesOptions,\n} from \"./modifications/removeProperties.ts\";\nexport { default as removePropertiesDeep } from \"./modifications/removePropertiesDeep.ts\";\nexport { default as removeTypeDuplicates } from \"./modifications/flow/removeTypeDuplicates.ts\";\n\n// retrievers\nexport { default as getAssignmentIdentifiers } from \"./retrievers/getAssignmentIdentifiers.ts\";\nexport { default as getBindingIdentifiers } from \"./retrievers/getBindingIdentifiers.ts\";\nexport { default as getOuterBindingIdentifiers } from \"./retrievers/getOuterBindingIdentifiers.ts\";\nexport { default as getFunctionName } from \"./retrievers/getFunctionName.ts\";\n\n// traverse\nexport { default as traverse } from \"./traverse/traverse.ts\";\nexport * from \"./traverse/traverse.ts\";\nexport { default as traverseFast } from \"./traverse/traverseFast.ts\";\n\n// utils\nexport { default as shallowEqual } from \"./utils/shallowEqual.ts\";\n\n// validators\nexport { default as is } from \"./validators/is.ts\";\nexport { default as isBinding } from \"./validators/isBinding.ts\";\nexport { default as isBlockScoped } from \"./validators/isBlockScoped.ts\";\nexport { default as isImmutable } from \"./validators/isImmutable.ts\";\nexport { default as isLet } from \"./validators/isLet.ts\";\nexport { default as isNode } from \"./validators/isNode.ts\";\nexport { default as isNodesEquivalent } from \"./validators/isNodesEquivalent.ts\";\nexport { default as isPlaceholderType } from \"./validators/isPlaceholderType.ts\";\nexport { default as isReferenced } from \"./validators/isReferenced.ts\";\nexport { default as isScope } from \"./validators/isScope.ts\";\nexport { default as isSpecifierDefault } from \"./validators/isSpecifierDefault.ts\";\nexport { default as isType } from \"./validators/isType.ts\";\nexport { default as isValidES3Identifier } from \"./validators/isValidES3Identifier.ts\";\nexport { default as isValidIdentifier } from \"./validators/isValidIdentifier.ts\";\nexport { default as isVar } from \"./validators/isVar.ts\";\nexport { default as matchesPattern } from \"./validators/matchesPattern.ts\";\nexport { default as validate } from \"./validators/validate.ts\";\nexport { default as buildMatchMemberExpression } from \"./validators/buildMatchMemberExpression.ts\";\nexport * from \"./validators/generated/index.ts\";\n\n// react\nexport const react = {\n  isReactComponent,\n  isCompatTag,\n  buildChildren,\n};\n\nexport type * from \"./ast-types/generated/index.ts\";\n\n// this is used by @babel/traverse to warn about deprecated visitors\nexport { default as __internal__deprecationWarning } from \"./utils/deprecationWarning.ts\";\n\nif (!process.env.BABEL_8_BREAKING && !USE_ESM && !IS_STANDALONE) {\n  // eslint-disable-next-line no-restricted-globals\n  exports.toSequenceExpression =\n    // eslint-disable-next-line no-restricted-globals\n    require(\"./converters/toSequenceExpression.js\").default;\n}\n\nif (!process.env.BABEL_8_BREAKING && process.env.BABEL_TYPES_8_BREAKING) {\n  console.warn(\n    \"BABEL_TYPES_8_BREAKING is not supported anymore. Use the latest Babel 8.0.0 pre-release instead!\",\n  );\n}\n", "import assert from \"assert\";\nimport {\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  identifier,\n  importDeclaration,\n  importDefaultSpecifier,\n  importNamespaceSpecifier,\n  importSpecifier,\n  memberExpression,\n  stringLiteral,\n  variableDeclaration,\n  variableDeclarator,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport type { Scope, HubInterface } from \"@babel/traverse\";\n\n/**\n * A class to track and accumulate mutations to the AST that will eventually\n * output a new require/import statement list.\n */\nexport default class ImportBuilder {\n  private _statements: t.Statement[] = [];\n  private _resultName: t.Identifier | t.MemberExpression = null;\n\n  declare _scope: Scope;\n  declare _hub: HubInterface;\n  private _importedSource: string;\n\n  constructor(importedSource: string, scope: Scope, hub: HubInterface) {\n    this._scope = scope;\n    this._hub = hub;\n    this._importedSource = importedSource;\n  }\n\n  done() {\n    return {\n      statements: this._statements,\n      resultName: this._resultName,\n    };\n  }\n\n  import() {\n    this._statements.push(\n      importDeclaration([], stringLiteral(this._importedSource)),\n    );\n    return this;\n  }\n\n  require() {\n    this._statements.push(\n      expressionStatement(\n        callExpression(identifier(\"require\"), [\n          stringLiteral(this._importedSource),\n        ]),\n      ),\n    );\n    return this;\n  }\n\n  namespace(name = \"namespace\") {\n    const local = this._scope.generateUidIdentifier(name);\n\n    const statement = this._statements[this._statements.length - 1];\n    assert(statement.type === \"ImportDeclaration\");\n    assert(statement.specifiers.length === 0);\n    statement.specifiers = [importNamespaceSpecifier(local)];\n    this._resultName = cloneNode(local);\n    return this;\n  }\n  default(name: string) {\n    const id = this._scope.generateUidIdentifier(name);\n    const statement = this._statements[this._statements.length - 1];\n    assert(statement.type === \"ImportDeclaration\");\n    assert(statement.specifiers.length === 0);\n    statement.specifiers = [importDefaultSpecifier(id)];\n    this._resultName = cloneNode(id);\n    return this;\n  }\n  named(name: string, importName: string) {\n    if (importName === \"default\") return this.default(name);\n\n    const id = this._scope.generateUidIdentifier(name);\n    const statement = this._statements[this._statements.length - 1];\n    assert(statement.type === \"ImportDeclaration\");\n    assert(statement.specifiers.length === 0);\n    statement.specifiers = [importSpecifier(id, identifier(importName))];\n    this._resultName = cloneNode(id);\n    return this;\n  }\n\n  var(name: string) {\n    const id = this._scope.generateUidIdentifier(name);\n    let statement = this._statements[this._statements.length - 1];\n    if (statement.type !== \"ExpressionStatement\") {\n      assert(this._resultName);\n      statement = expressionStatement(this._resultName);\n      this._statements.push(statement);\n    }\n    this._statements[this._statements.length - 1] = variableDeclaration(\"var\", [\n      variableDeclarator(id, statement.expression),\n    ]);\n    this._resultName = cloneNode(id);\n    return this;\n  }\n\n  defaultInterop() {\n    return this._interop(this._hub.addHelper(\"interopRequireDefault\"));\n  }\n  wildcardInterop() {\n    return this._interop(this._hub.addHelper(\"interopRequireWildcard\"));\n  }\n\n  _interop(callee: t.Expression) {\n    const statement = this._statements[this._statements.length - 1];\n    if (statement.type === \"ExpressionStatement\") {\n      statement.expression = callExpression(callee, [statement.expression]);\n    } else if (statement.type === \"VariableDeclaration\") {\n      assert(statement.declarations.length === 1);\n      statement.declarations[0].init = callExpression(callee, [\n        statement.declarations[0].init,\n      ]);\n    } else {\n      assert.fail(\"Unexpected type.\");\n    }\n    return this;\n  }\n\n  prop(name: string) {\n    const statement = this._statements[this._statements.length - 1];\n    if (statement.type === \"ExpressionStatement\") {\n      statement.expression = memberExpression(\n        statement.expression,\n        identifier(name),\n      );\n    } else if (statement.type === \"VariableDeclaration\") {\n      assert(statement.declarations.length === 1);\n      statement.declarations[0].init = memberExpression(\n        statement.declarations[0].init,\n        identifier(name),\n      );\n    } else {\n      assert.fail(\"Unexpected type:\" + statement.type);\n    }\n    return this;\n  }\n\n  read(name: string) {\n    this._resultName = memberExpression(this._resultName, identifier(name));\n  }\n}\n", "import type { NodePath } from \"@babel/traverse\";\nimport type * as t from \"@babel/types\";\n\n/**\n * A small utility to check if a file qualifies as a module.\n */\nexport default function isModule(path: NodePath<t.Program>) {\n  return path.node.sourceType === \"module\";\n}\n", "import assert from \"assert\";\nimport {\n  identifier,\n  importSpecifier,\n  numericLiteral,\n  sequenceExpression,\n  isImportDeclaration,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport type { NodePath, Scope, HubInterface } from \"@babel/traverse\";\n\nimport ImportBuilder from \"./import-builder.ts\";\nimport isModule from \"./is-module.ts\";\n\nexport type ImportOptions = {\n  /**\n   * The module being referenced.\n   */\n  importedSource: string | null;\n  /**\n   * The type of module being imported:\n   *\n   *  * 'es6'      - An ES6 module.\n   *  * 'commonjs' - A CommonJS module. (Default)\n   */\n  importedType: \"es6\" | \"commonjs\";\n  /**\n   * The type of interop behavior for namespace/default/named when loading\n   * CommonJS modules.\n   *\n   * ## 'babel' (Default)\n   *\n   * Load using Babel's interop.\n   *\n   * If '.__esModule' is true, treat as 'compiled', else:\n   *\n   * * Namespace: A copy of the module.exports with .default\n   *     populated by the module.exports object.\n   * * Default: The module.exports value.\n   * * Named: The .named property of module.exports.\n   *\n   * The 'ensureLiveReference' has no effect on the liveness of these.\n   *\n   * ## 'compiled'\n   *\n   * Assume the module is ES6 compiled to CommonJS. Useful to avoid injecting\n   * interop logic if you are confident that the module is a certain format.\n   *\n   * * Namespace: The root module.exports object.\n   * * Default: The .default property of the namespace.\n   * * Named: The .named property of the namespace.\n   *\n   * Will return erroneous results if the imported module is _not_ compiled\n   * from ES6 with Babel.\n   *\n   * ## 'uncompiled'\n   *\n   * Assume the module is _not_ ES6 compiled to CommonJS. Used a simplified\n   * access pattern that doesn't require additional function calls.\n   *\n   * Will return erroneous results if the imported module _is_ compiled\n   * from ES6 with Babel.\n   *\n   * * Namespace: The module.exports object.\n   * * Default: The module.exports object.\n   * * Named: The .named property of module.exports.\n   */\n  importedInterop: \"babel\" | \"node\" | \"compiled\" | \"uncompiled\";\n  /**\n   * The type of CommonJS interop included in the environment that will be\n   * loading the output code.\n   *\n   *  * 'babel' - CommonJS modules load with Babel's interop. (Default)\n   *  * 'node'  - CommonJS modules load with Node's interop.\n   *\n   * See descriptions in 'importedInterop' for more details.\n   */\n  importingInterop: \"babel\" | \"node\";\n  /**\n   * Define whether we explicitly care that the import be a live reference.\n   * Only applies when importing default and named imports, not the namespace.\n   *\n   *  * true  - Force imported values to be live references.\n   *  * false - No particular requirements. Keeps the code simplest. (Default)\n   */\n  ensureLiveReference: boolean;\n  /**\n   * Define if we explicitly care that the result not be a property reference.\n   *\n   *  * true  - Force calls to exclude context. Useful if the value is going to\n   *            be used as function callee.\n   *  * false - No particular requirements for context of the access. (Default)\n   */\n  ensureNoContext: boolean;\n  /**\n   * Define whether the import should be loaded before or after the existing imports.\n   * \"after\" is only allowed inside ECMAScript modules, since it's not possible to\n   * reliably pick the location _after_ require() calls but _before_ other code in CJS.\n   */\n  importPosition: \"before\" | \"after\";\n\n  nameHint?: string;\n  blockHoist?: number;\n};\n\n/**\n * A general helper classes add imports via transforms. See README for usage.\n */\nexport default class ImportInjector {\n  /**\n   * The path used for manipulation.\n   */\n  declare _programPath: NodePath<t.Program>;\n\n  /**\n   * The scope used to generate unique variable names.\n   */\n  declare _programScope: Scope;\n\n  /**\n   * The file used to inject helpers and resolve paths.\n   */\n  declare _hub: HubInterface;\n\n  /**\n   * The default options to use with this instance when imports are added.\n   */\n  _defaultOpts: ImportOptions = {\n    importedSource: null,\n    importedType: \"commonjs\",\n    importedInterop: \"babel\",\n    importingInterop: \"babel\",\n    ensureLiveReference: false,\n    ensureNoContext: false,\n    importPosition: \"before\",\n  };\n\n  constructor(\n    path: NodePath,\n    importedSource?: string,\n    opts?: Partial<ImportOptions>,\n  ) {\n    const programPath = path.find(p => p.isProgram()) as NodePath<t.Program>;\n\n    this._programPath = programPath;\n    this._programScope = programPath.scope;\n    this._hub = programPath.hub;\n\n    this._defaultOpts = this._applyDefaults(importedSource, opts, true);\n  }\n\n  addDefault(importedSourceIn: string, opts: Partial<ImportOptions>) {\n    return this.addNamed(\"default\", importedSourceIn, opts);\n  }\n\n  addNamed(\n    importName: string,\n    importedSourceIn: string,\n    opts: Partial<ImportOptions>,\n  ) {\n    assert(typeof importName === \"string\");\n\n    return this._generateImport(\n      this._applyDefaults(importedSourceIn, opts),\n      importName,\n    );\n  }\n\n  addNamespace(importedSourceIn: string, opts: Partial<ImportOptions>) {\n    return this._generateImport(\n      this._applyDefaults(importedSourceIn, opts),\n      null,\n    );\n  }\n\n  addSideEffect(importedSourceIn: string, opts: Partial<ImportOptions>) {\n    return this._generateImport(\n      this._applyDefaults(importedSourceIn, opts),\n      void 0,\n    );\n  }\n\n  _applyDefaults(\n    importedSource: string | Partial<ImportOptions>,\n    opts: Partial<ImportOptions> | undefined,\n    isInit = false,\n  ) {\n    let newOpts: ImportOptions;\n    if (typeof importedSource === \"string\") {\n      newOpts = { ...this._defaultOpts, importedSource, ...opts };\n    } else {\n      assert(!opts, \"Unexpected secondary arguments.\");\n      newOpts = { ...this._defaultOpts, ...importedSource };\n    }\n\n    if (!isInit && opts) {\n      if (opts.nameHint !== undefined) newOpts.nameHint = opts.nameHint;\n      if (opts.blockHoist !== undefined) newOpts.blockHoist = opts.blockHoist;\n    }\n    return newOpts;\n  }\n\n  _generateImport(\n    opts: Partial<ImportOptions>,\n    importName: string | null | undefined,\n  ) {\n    const isDefault = importName === \"default\";\n    const isNamed = !!importName && !isDefault;\n    const isNamespace = importName === null;\n\n    const {\n      importedSource,\n      importedType,\n      importedInterop,\n      importingInterop,\n      ensureLiveReference,\n      ensureNoContext,\n      nameHint,\n      importPosition,\n\n      // Not meant for public usage. Allows code that absolutely must control\n      // ordering to set a specific hoist value on the import nodes.\n      // This is ignored when \"importPosition\" is \"after\".\n      blockHoist,\n    } = opts;\n\n    // Provide a hint for generateUidIdentifier for the local variable name\n    // to use for the import, if the code will generate a simple assignment\n    // to a variable.\n    let name = nameHint || importName;\n\n    const isMod = isModule(this._programPath);\n    const isModuleForNode = isMod && importingInterop === \"node\";\n    const isModuleForBabel = isMod && importingInterop === \"babel\";\n\n    if (importPosition === \"after\" && !isMod) {\n      throw new Error(`\"importPosition\": \"after\" is only supported in modules`);\n    }\n\n    const builder = new ImportBuilder(\n      importedSource,\n      this._programScope,\n      this._hub,\n    );\n\n    if (importedType === \"es6\") {\n      if (!isModuleForNode && !isModuleForBabel) {\n        throw new Error(\"Cannot import an ES6 module from CommonJS\");\n      }\n\n      // import * as namespace from ''; namespace\n      // import def from ''; def\n      // import { named } from ''; named\n      builder.import();\n      if (isNamespace) {\n        builder.namespace(nameHint || importedSource);\n      } else if (isDefault || isNamed) {\n        builder.named(name, importName);\n      }\n    } else if (importedType !== \"commonjs\") {\n      throw new Error(`Unexpected interopType \"${importedType}\"`);\n    } else if (importedInterop === \"babel\") {\n      if (isModuleForNode) {\n        // import _tmp from ''; var namespace = interopRequireWildcard(_tmp); namespace\n        // import _tmp from ''; var def = interopRequireDefault(_tmp).default; def\n        // import _tmp from ''; _tmp.named\n        name = name !== \"default\" ? name : importedSource;\n        const es6Default = `${importedSource}$es6Default`;\n\n        builder.import();\n        if (isNamespace) {\n          builder\n            .default(es6Default)\n            .var(name || importedSource)\n            .wildcardInterop();\n        } else if (isDefault) {\n          if (ensureLiveReference) {\n            builder\n              .default(es6Default)\n              .var(name || importedSource)\n              .defaultInterop()\n              .read(\"default\");\n          } else {\n            builder\n              .default(es6Default)\n              .var(name)\n              .defaultInterop()\n              .prop(importName);\n          }\n        } else if (isNamed) {\n          builder.default(es6Default).read(importName);\n        }\n      } else if (isModuleForBabel) {\n        // import * as namespace from ''; namespace\n        // import def from ''; def\n        // import { named } from ''; named\n        builder.import();\n        if (isNamespace) {\n          builder.namespace(name || importedSource);\n        } else if (isDefault || isNamed) {\n          builder.named(name, importName);\n        }\n      } else {\n        // var namespace = interopRequireWildcard(require(''));\n        // var def = interopRequireDefault(require('')).default; def\n        // var named = require('').named; named\n        builder.require();\n        if (isNamespace) {\n          builder.var(name || importedSource).wildcardInterop();\n        } else if ((isDefault || isNamed) && ensureLiveReference) {\n          if (isDefault) {\n            name = name !== \"default\" ? name : importedSource;\n            builder.var(name).read(importName);\n            builder.defaultInterop();\n          } else {\n            builder.var(importedSource).read(importName);\n          }\n        } else if (isDefault) {\n          builder.var(name).defaultInterop().prop(importName);\n        } else if (isNamed) {\n          builder.var(name).prop(importName);\n        }\n      }\n    } else if (importedInterop === \"compiled\") {\n      if (isModuleForNode) {\n        // import namespace from ''; namespace\n        // import namespace from ''; namespace.default\n        // import namespace from ''; namespace.named\n\n        builder.import();\n        if (isNamespace) {\n          builder.default(name || importedSource);\n        } else if (isDefault || isNamed) {\n          builder.default(importedSource).read(name);\n        }\n      } else if (isModuleForBabel) {\n        // import * as namespace from ''; namespace\n        // import def from ''; def\n        // import { named } from ''; named\n        // Note: These lookups will break if the module has no __esModule set,\n        // hence the warning that 'compiled' will not work on standard CommonJS.\n\n        builder.import();\n        if (isNamespace) {\n          builder.namespace(name || importedSource);\n        } else if (isDefault || isNamed) {\n          builder.named(name, importName);\n        }\n      } else {\n        // var namespace = require(''); namespace\n        // var namespace = require(''); namespace.default\n        // var namespace = require(''); namespace.named\n        // var named = require('').named;\n        builder.require();\n        if (isNamespace) {\n          builder.var(name || importedSource);\n        } else if (isDefault || isNamed) {\n          if (ensureLiveReference) {\n            builder.var(importedSource).read(name);\n          } else {\n            builder.prop(importName).var(name);\n          }\n        }\n      }\n    } else if (importedInterop === \"uncompiled\") {\n      if (isDefault && ensureLiveReference) {\n        throw new Error(\"No live reference for commonjs default\");\n      }\n\n      if (isModuleForNode) {\n        // import namespace from ''; namespace\n        // import def from ''; def;\n        // import namespace from ''; namespace.named\n        builder.import();\n        if (isNamespace) {\n          builder.default(name || importedSource);\n        } else if (isDefault) {\n          builder.default(name);\n        } else if (isNamed) {\n          builder.default(importedSource).read(name);\n        }\n      } else if (isModuleForBabel) {\n        // import namespace from '';\n        // import def from '';\n        // import { named } from ''; named;\n        // Note: These lookups will break if the module has __esModule set,\n        // hence the warning that 'uncompiled' will not work on ES6 transpiled\n        // to CommonJS.\n\n        builder.import();\n        if (isNamespace) {\n          builder.default(name || importedSource);\n        } else if (isDefault) {\n          builder.default(name);\n        } else if (isNamed) {\n          builder.named(name, importName);\n        }\n      } else {\n        // var namespace = require(''); namespace\n        // var def = require(''); def\n        // var namespace = require(''); namespace.named\n        // var named = require('').named;\n        builder.require();\n        if (isNamespace) {\n          builder.var(name || importedSource);\n        } else if (isDefault) {\n          builder.var(name);\n        } else if (isNamed) {\n          if (ensureLiveReference) {\n            builder.var(importedSource).read(name);\n          } else {\n            builder.var(name).prop(importName);\n          }\n        }\n      }\n    } else {\n      throw new Error(`Unknown importedInterop \"${importedInterop}\".`);\n    }\n\n    const { statements, resultName } = builder.done();\n\n    this._insertStatements(statements, importPosition, blockHoist);\n\n    if (\n      (isDefault || isNamed) &&\n      ensureNoContext &&\n      resultName.type !== \"Identifier\"\n    ) {\n      return sequenceExpression([numericLiteral(0), resultName]);\n    }\n    return resultName;\n  }\n\n  _insertStatements(\n    statements: t.Statement[],\n    importPosition = \"before\",\n    blockHoist = 3,\n  ) {\n    if (importPosition === \"after\") {\n      if (this._insertStatementsAfter(statements)) return;\n    } else {\n      if (this._insertStatementsBefore(statements, blockHoist)) return;\n    }\n\n    this._programPath.unshiftContainer(\"body\", statements);\n  }\n\n  _insertStatementsBefore(statements: t.Statement[], blockHoist: number) {\n    if (\n      statements.length === 1 &&\n      isImportDeclaration(statements[0]) &&\n      isValueImport(statements[0])\n    ) {\n      const firstImportDecl = this._programPath\n        .get(\"body\")\n        .find((p): p is NodePath<t.ImportDeclaration> => {\n          return p.isImportDeclaration() && isValueImport(p.node);\n        });\n\n      if (\n        firstImportDecl?.node.source.value === statements[0].source.value &&\n        maybeAppendImportSpecifiers(firstImportDecl.node, statements[0])\n      ) {\n        return true;\n      }\n    }\n\n    statements.forEach(node => {\n      // @ts-expect-error handle _blockHoist\n      node._blockHoist = blockHoist;\n    });\n\n    const targetPath = this._programPath.get(\"body\").find(p => {\n      // @ts-expect-error todo(flow->ts): avoid mutations\n      const val = p.node._blockHoist;\n      return Number.isFinite(val) && val < 4;\n    });\n\n    if (targetPath) {\n      targetPath.insertBefore(statements);\n      return true;\n    }\n\n    return false;\n  }\n\n  _insertStatementsAfter(statements: t.Statement[]): boolean {\n    const statementsSet = new Set(statements);\n    const importDeclarations: Map<string, t.ImportDeclaration[]> = new Map();\n\n    for (const statement of statements) {\n      if (isImportDeclaration(statement) && isValueImport(statement)) {\n        const source = statement.source.value;\n        if (!importDeclarations.has(source)) importDeclarations.set(source, []);\n        importDeclarations.get(source).push(statement);\n      }\n    }\n\n    let lastImportPath = null;\n    for (const bodyStmt of this._programPath.get(\"body\")) {\n      if (bodyStmt.isImportDeclaration() && isValueImport(bodyStmt.node)) {\n        lastImportPath = bodyStmt;\n\n        const source = bodyStmt.node.source.value;\n        const newImports = importDeclarations.get(source);\n        if (!newImports) continue;\n\n        for (const decl of newImports) {\n          if (!statementsSet.has(decl)) continue;\n          if (maybeAppendImportSpecifiers(bodyStmt.node, decl)) {\n            statementsSet.delete(decl);\n          }\n        }\n      }\n    }\n\n    if (statementsSet.size === 0) return true;\n\n    if (lastImportPath) lastImportPath.insertAfter(Array.from(statementsSet));\n\n    return !!lastImportPath;\n  }\n}\n\nfunction isValueImport(node: t.ImportDeclaration) {\n  return node.importKind !== \"type\" && node.importKind !== \"typeof\";\n}\n\nfunction hasNamespaceImport(node: t.ImportDeclaration) {\n  return (\n    (node.specifiers.length === 1 &&\n      node.specifiers[0].type === \"ImportNamespaceSpecifier\") ||\n    (node.specifiers.length === 2 &&\n      node.specifiers[1].type === \"ImportNamespaceSpecifier\")\n  );\n}\n\nfunction hasDefaultImport(node: t.ImportDeclaration) {\n  return (\n    node.specifiers.length > 0 &&\n    node.specifiers[0].type === \"ImportDefaultSpecifier\"\n  );\n}\n\nfunction maybeAppendImportSpecifiers(\n  target: t.ImportDeclaration,\n  source: t.ImportDeclaration,\n): boolean {\n  if (!target.specifiers.length) {\n    target.specifiers = source.specifiers;\n    return true;\n  }\n  if (!source.specifiers.length) return true;\n\n  if (hasNamespaceImport(target) || hasNamespaceImport(source)) return false;\n\n  if (hasDefaultImport(source)) {\n    if (hasDefaultImport(target)) {\n      source.specifiers[0] = importSpecifier(\n        source.specifiers[0].local,\n        identifier(\"default\"),\n      );\n    } else {\n      target.specifiers.unshift(source.specifiers.shift());\n    }\n  }\n\n  target.specifiers.push(...source.specifiers);\n\n  return true;\n}\n", "import ImportInjector, { type ImportOptions } from \"./import-injector.ts\";\nimport type { NodePath } from \"@babel/traverse\";\nimport type * as t from \"@babel/types\";\n\nexport { ImportInjector };\n\nexport { default as isModule } from \"./is-module.ts\";\n\nexport function addDefault(\n  path: NodePath,\n  importedSource: string,\n  opts?: Partial<ImportOptions>,\n) {\n  return new ImportInjector(path).addDefault(importedSource, opts);\n}\n\nfunction addNamed(\n  path: NodePath,\n  name: string,\n  importedSource: string,\n  opts?: Omit<\n    Partial<ImportOptions>,\n    \"ensureLiveReference\" | \"ensureNoContext\"\n  >,\n): t.Identifier;\nfunction addNamed(\n  path: NodePath,\n  name: string,\n  importedSource: string,\n  opts?: Omit<Partial<ImportOptions>, \"ensureLiveReference\"> & {\n    ensureLiveReference: true;\n  },\n): t.MemberExpression;\nfunction addNamed(\n  path: NodePath,\n  name: string,\n  importedSource: string,\n  opts?: Omit<Partial<ImportOptions>, \"ensureNoContext\"> & {\n    ensureNoContext: true;\n  },\n): t.SequenceExpression;\n/**\n * add a named import to the program path of given path\n *\n * @export\n * @param {NodePath} path The starting path to find a program path\n * @param {string} name The name of the generated binding. Babel will prefix it with `_`\n * @param {string} importedSource The source of the import\n * @param {Partial<ImportOptions>} [opts]\n * @returns {t.Identifier | t.MemberExpression | t.SequenceExpression} If opts.ensureNoContext is true, returns a SequenceExpression,\n *   else if opts.ensureLiveReference is true, returns a MemberExpression, else returns an Identifier\n */\nfunction addNamed(\n  path: NodePath,\n  name: string,\n  importedSource: string,\n  opts?: Partial<ImportOptions>,\n) {\n  return new ImportInjector(path).addNamed(name, importedSource, opts);\n}\nexport { addNamed };\n\nexport function addNamespace(\n  path: NodePath,\n  importedSource: string,\n  opts?: Partial<ImportOptions>,\n) {\n  return new ImportInjector(path).addNamespace(importedSource, opts);\n}\n\nexport function addSideEffect(\n  path: NodePath,\n  importedSource: string,\n  opts?: Partial<ImportOptions>,\n) {\n  return new ImportInjector(path).addSideEffect(importedSource, opts);\n}\n", "module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"os\" has been externalized for browser compatibility. Cannot access \"os.${key}\" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "'use strict';\n\nvar os = require('os');\n\n// adapted from https://github.com/sindresorhus/os-homedir/blob/11e089f4754db38bb535e5a8416320c4446e8cfd/index.js\n\nmodule.exports = os.homedir || function homedir() {\n    var home = process.env.HOME;\n    var user = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;\n\n    if (process.platform === 'win32') {\n        return process.env.USERPROFILE || process.env.HOMEDRIVE + process.env.HOMEPATH || home || null;\n    }\n\n    if (process.platform === 'darwin') {\n        return home || (user ? '/Users/' + user : null);\n    }\n\n    if (process.platform === 'linux') {\n        return home || (process.getuid() === 0 ? '/root' : (user ? '/home/' + user : null)); // eslint-disable-line no-extra-parens\n    }\n\n    return home || null;\n};\n", "module.exports = function () {\n    // see https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n    var origPrepareStackTrace = Error.prepareStackTrace;\n    Error.prepareStackTrace = function (_, stack) { return stack; };\n    var stack = (new Error()).stack;\n    Error.prepareStackTrace = origPrepareStackTrace;\n    return stack[2].getFileName();\n};\n", "'use strict';\n\nvar isWindows = process.platform === 'win32';\n\n// Regex to split a windows path into into [dir, root, basename, name, ext]\nvar splitWindowsRe =\n    /^(((?:[a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?[\\\\\\/]?)(?:[^\\\\\\/]*[\\\\\\/])*)((\\.{1,2}|[^\\\\\\/]+?|)(\\.[^.\\/\\\\]*|))[\\\\\\/]*$/;\n\nvar win32 = {};\n\nfunction win32SplitPath(filename) {\n  return splitWindowsRe.exec(filename).slice(1);\n}\n\nwin32.parse = function(pathString) {\n  if (typeof pathString !== 'string') {\n    throw new TypeError(\n        \"Parameter 'pathString' must be a string, not \" + typeof pathString\n    );\n  }\n  var allParts = win32SplitPath(pathString);\n  if (!allParts || allParts.length !== 5) {\n    throw new TypeError(\"Invalid path '\" + pathString + \"'\");\n  }\n  return {\n    root: allParts[1],\n    dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),\n    base: allParts[2],\n    ext: allParts[4],\n    name: allParts[3]\n  };\n};\n\n\n\n// Split a filename into [dir, root, basename, name, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^((\\/?)(?:[^\\/]*\\/)*)((\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))[\\/]*$/;\nvar posix = {};\n\n\nfunction posixSplitPath(filename) {\n  return splitPathRe.exec(filename).slice(1);\n}\n\n\nposix.parse = function(pathString) {\n  if (typeof pathString !== 'string') {\n    throw new TypeError(\n        \"Parameter 'pathString' must be a string, not \" + typeof pathString\n    );\n  }\n  var allParts = posixSplitPath(pathString);\n  if (!allParts || allParts.length !== 5) {\n    throw new TypeError(\"Invalid path '\" + pathString + \"'\");\n  }\n  \n  return {\n    root: allParts[1],\n    dir: allParts[0].slice(0, -1),\n    base: allParts[2],\n    ext: allParts[4],\n    name: allParts[3],\n  };\n};\n\n\nif (isWindows)\n  module.exports = win32.parse;\nelse /* posix */\n  module.exports = posix.parse;\n\nmodule.exports.posix = posix.parse;\nmodule.exports.win32 = win32.parse;\n", "var path = require('path');\nvar parse = path.parse || require('path-parse'); // eslint-disable-line global-require\n\nvar getNodeModulesDirs = function getNodeModulesDirs(absoluteStart, modules) {\n    var prefix = '/';\n    if ((/^([A-Za-z]:)/).test(absoluteStart)) {\n        prefix = '';\n    } else if ((/^\\\\\\\\/).test(absoluteStart)) {\n        prefix = '\\\\\\\\';\n    }\n\n    var paths = [absoluteStart];\n    var parsed = parse(absoluteStart);\n    while (parsed.dir !== paths[paths.length - 1]) {\n        paths.push(parsed.dir);\n        parsed = parse(parsed.dir);\n    }\n\n    return paths.reduce(function (dirs, aPath) {\n        return dirs.concat(modules.map(function (moduleDir) {\n            return path.resolve(prefix, aPath, moduleDir);\n        }));\n    }, []);\n};\n\nmodule.exports = function nodeModulesPaths(start, opts, request) {\n    var modules = opts && opts.moduleDirectory\n        ? [].concat(opts.moduleDirectory)\n        : ['node_modules'];\n\n    if (opts && typeof opts.paths === 'function') {\n        return opts.paths(\n            request,\n            start,\n            function () { return getNodeModulesDirs(start, modules); },\n            opts\n        );\n    }\n\n    var dirs = getNodeModulesDirs(start, modules);\n    return opts && opts.paths ? dirs.concat(opts.paths) : dirs;\n};\n", "module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"module\" has been externalized for browser compatibility. Cannot access \"module.${key}\" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "// Info: this file has been generated by Yarn with the approval of the\n// `resolve` maintainers. Bugs caused by a code located here should be\n// opened against the Yarn repository.\n\nconst path = require(`path`);\n\nmodule.exports = function (_, opts) {\n  opts = opts || {};\n\n  if (opts.forceNodeResolution || !process.versions.pnp)\n    return opts;\n\n  // It would be nice if we could throw, but that would break the transparent\n  // compatibility with packages that use `resolve` today (such as Gulp). Since\n  // it's the whole point of this patch, we don't.\n  //\n  // if (opts.packageIterator || opts.paths)\n  //   throw new Error(`The \"packageIterator\" and \"paths\" options cannot be used in PnP environments. Set \"forceNodeResolution: true\" if absolutely needed, or branch on process.versions.pnp otherwise.`);\n\n  const {findPnpApi} = require(`module`);\n\n  const runPnpResolution = (request, basedir) => {\n    // Extract the name of the package being requested (1=package name, 2=internal path)\n    const parts = request.match(/^((?:@[^/]+\\/)?[^/]+)(\\/.*)?/);\n    if (!parts)\n      throw new Error(`Assertion failed: Expected the \"resolve\" package to call the \"paths\" callback with package names only (got \"${request}\")`);\n\n    // Make sure that basedir ends with a slash\n    if (basedir.charAt(basedir.length - 1) !== `/`)\n      basedir = path.join(basedir, `/`);\n\n    const api = findPnpApi(basedir);\n    if (api === null)\n      return undefined;\n\n    // This is guaranteed to return the path to the \"package.json\" file from the given package\n    let manifestPath;\n    try {\n      manifestPath = api.resolveToUnqualified(`${parts[1]}/package.json`, basedir, {considerBuiltins: false});\n    } catch (err) {\n      return null;\n    }\n\n    if (manifestPath === null)\n      throw new Error(`Assertion failed: The resolution thinks that \"${parts[1]}\" is a Node builtin`);\n\n    // Strip the package.json to get the package folder\n    const packagePath = path.dirname(manifestPath);\n\n    // Attach the internal path to the resolved package directory\n    const unqualifiedPath = typeof parts[2] !== `undefined`\n      ? path.join(packagePath, parts[2])\n      : packagePath;\n\n    return {packagePath, unqualifiedPath};\n  };\n\n  const runPnpResolutionOnArray = (request, paths) => {\n    for (let i = 0; i < paths.length; i++) {\n      const resolution = runPnpResolution(request, paths[i]);\n      if (resolution || i === paths.length - 1) {\n        return resolution;\n      }\n    }\n\n    return null;\n  };\n\n  const originalPaths = Array.isArray(opts.paths) ? opts.paths : [];\n\n  const packageIterator = (request, basedir, getCandidates, opts) => {\n    const pathsToTest = [basedir].concat(originalPaths);\n    const resolution = runPnpResolutionOnArray(request, pathsToTest);\n    if (resolution == null)\n      return getCandidates();\n\n    return [resolution.unqualifiedPath];\n  };\n\n  const paths = (request, basedir, getNodeModulePaths, opts) => {\n    const pathsToTest = [basedir].concat(originalPaths);\n    const resolution = runPnpResolutionOnArray(request, pathsToTest);\n    if (resolution == null)\n      return getNodeModulePaths().concat(originalPaths);\n\n    // Stip the local named folder\n    let nodeModules = path.dirname(resolution.packagePath);\n\n    // Strip the scope named folder if needed\n    if (request.match(/^@[^/]+\\//))\n      nodeModules = path.dirname(nodeModules);\n\n    return [nodeModules];\n  };\n\n  // We need to keep track whether we're in `packageIterator` or not so that\n  // the code is compatible with both `resolve` 1.9+ and `resolve` 1.15+\n  let isInsideIterator = false;\n\n  if (!opts.__skipPackageIterator) {\n    opts.packageIterator = function (request, basedir, getCandidates, opts) {\n      isInsideIterator = true;\n      try {\n        return packageIterator(request, basedir, getCandidates, opts);\n      } finally {\n        isInsideIterator = false;\n      }\n    };\n  }\n\n  opts.paths = function (request, basedir, getNodeModulePaths, opts) {\n    if (isInsideIterator)\n      return getNodeModulePaths().concat(originalPaths);\n\n    return paths(request, basedir, getNodeModulePaths, opts);\n  };\n\n  return opts;\n};\n", "'use strict';\n\n/* eslint no-invalid-this: 1 */\n\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar toStr = Object.prototype.toString;\nvar max = Math.max;\nvar funcType = '[object Function]';\n\nvar concatty = function concatty(a, b) {\n    var arr = [];\n\n    for (var i = 0; i < a.length; i += 1) {\n        arr[i] = a[i];\n    }\n    for (var j = 0; j < b.length; j += 1) {\n        arr[j + a.length] = b[j];\n    }\n\n    return arr;\n};\n\nvar slicy = function slicy(arrLike, offset) {\n    var arr = [];\n    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {\n        arr[j] = arrLike[i];\n    }\n    return arr;\n};\n\nvar joiny = function (arr, joiner) {\n    var str = '';\n    for (var i = 0; i < arr.length; i += 1) {\n        str += arr[i];\n        if (i + 1 < arr.length) {\n            str += joiner;\n        }\n    }\n    return str;\n};\n\nmodule.exports = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slicy(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                concatty(args, arguments)\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        }\n        return target.apply(\n            that,\n            concatty(args, arguments)\n        );\n\n    };\n\n    var boundLength = max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs[i] = '$' + i;\n    }\n\n    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n", "'use strict';\n\nvar implementation = require('./implementation');\n\nmodule.exports = Function.prototype.bind || implementation;\n", "'use strict';\n\nvar call = Function.prototype.call;\nvar $hasOwn = Object.prototype.hasOwnProperty;\nvar bind = require('function-bind');\n\n/** @type {import('.')} */\nmodule.exports = bind.call(call, $hasOwn);\n", "{\n\t\"assert\": true,\n\t\"node:assert\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"assert/strict\": \">= 15\",\n\t\"node:assert/strict\": \">= 16\",\n\t\"async_hooks\": \">= 8\",\n\t\"node:async_hooks\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"buffer_ieee754\": \">= 0.5 && < 0.9.7\",\n\t\"buffer\": true,\n\t\"node:buffer\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"child_process\": true,\n\t\"node:child_process\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"cluster\": \">= 0.5\",\n\t\"node:cluster\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"console\": true,\n\t\"node:console\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"constants\": true,\n\t\"node:constants\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"crypto\": true,\n\t\"node:crypto\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_debug_agent\": \">= 1 && < 8\",\n\t\"_debugger\": \"< 8\",\n\t\"dgram\": true,\n\t\"node:dgram\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"diagnostics_channel\": [\">= 14.17 && < 15\", \">= 15.1\"],\n\t\"node:diagnostics_channel\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"dns\": true,\n\t\"node:dns\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"dns/promises\": \">= 15\",\n\t\"node:dns/promises\": \">= 16\",\n\t\"domain\": \">= 0.7.12\",\n\t\"node:domain\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"events\": true,\n\t\"node:events\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"freelist\": \"< 6\",\n\t\"fs\": true,\n\t\"node:fs\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"fs/promises\": [\">= 10 && < 10.1\", \">= 14\"],\n\t\"node:fs/promises\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_http_agent\": \">= 0.11.1\",\n\t\"node:_http_agent\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_http_client\": \">= 0.11.1\",\n\t\"node:_http_client\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_http_common\": \">= 0.11.1\",\n\t\"node:_http_common\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_http_incoming\": \">= 0.11.1\",\n\t\"node:_http_incoming\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_http_outgoing\": \">= 0.11.1\",\n\t\"node:_http_outgoing\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_http_server\": \">= 0.11.1\",\n\t\"node:_http_server\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"http\": true,\n\t\"node:http\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"http2\": \">= 8.8\",\n\t\"node:http2\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"https\": true,\n\t\"node:https\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"inspector\": \">= 8\",\n\t\"node:inspector\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"inspector/promises\": [\">= 19\"],\n\t\"node:inspector/promises\": [\">= 19\"],\n\t\"_linklist\": \"< 8\",\n\t\"module\": true,\n\t\"node:module\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"net\": true,\n\t\"node:net\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"node-inspect/lib/_inspect\": \">= 7.6 && < 12\",\n\t\"node-inspect/lib/internal/inspect_client\": \">= 7.6 && < 12\",\n\t\"node-inspect/lib/internal/inspect_repl\": \">= 7.6 && < 12\",\n\t\"os\": true,\n\t\"node:os\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"path\": true,\n\t\"node:path\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"path/posix\": \">= 15.3\",\n\t\"node:path/posix\": \">= 16\",\n\t\"path/win32\": \">= 15.3\",\n\t\"node:path/win32\": \">= 16\",\n\t\"perf_hooks\": \">= 8.5\",\n\t\"node:perf_hooks\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"process\": \">= 1\",\n\t\"node:process\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"punycode\": \">= 0.5\",\n\t\"node:punycode\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"querystring\": true,\n\t\"node:querystring\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"readline\": true,\n\t\"node:readline\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"readline/promises\": \">= 17\",\n\t\"node:readline/promises\": \">= 17\",\n\t\"repl\": true,\n\t\"node:repl\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"node:sea\": [\">= 20.12 && < 21\", \">= 21.7\"],\n\t\"smalloc\": \">= 0.11.5 && < 3\",\n\t\"_stream_duplex\": \">= 0.9.4\",\n\t\"node:_stream_duplex\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_stream_transform\": \">= 0.9.4\",\n\t\"node:_stream_transform\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_stream_wrap\": \">= 1.4.1\",\n\t\"node:_stream_wrap\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_stream_passthrough\": \">= 0.9.4\",\n\t\"node:_stream_passthrough\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_stream_readable\": \">= 0.9.4\",\n\t\"node:_stream_readable\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_stream_writable\": \">= 0.9.4\",\n\t\"node:_stream_writable\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"stream\": true,\n\t\"node:stream\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"stream/consumers\": \">= 16.7\",\n\t\"node:stream/consumers\": \">= 16.7\",\n\t\"stream/promises\": \">= 15\",\n\t\"node:stream/promises\": \">= 16\",\n\t\"stream/web\": \">= 16.5\",\n\t\"node:stream/web\": \">= 16.5\",\n\t\"string_decoder\": true,\n\t\"node:string_decoder\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"sys\": [\">= 0.4 && < 0.7\", \">= 0.8\"],\n\t\"node:sys\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"test/reporters\": \">= 19.9 && < 20.2\",\n\t\"node:test/reporters\": [\">= 18.17 && < 19\", \">= 19.9\", \">= 20\"],\n\t\"test/mock_loader\": \">= 22.3 && < 22.7\",\n\t\"node:test/mock_loader\": \">= 22.3 && < 22.7\",\n\t\"node:test\": [\">= 16.17 && < 17\", \">= 18\"],\n\t\"timers\": true,\n\t\"node:timers\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"timers/promises\": \">= 15\",\n\t\"node:timers/promises\": \">= 16\",\n\t\"_tls_common\": \">= 0.11.13\",\n\t\"node:_tls_common\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_tls_legacy\": \">= 0.11.3 && < 10\",\n\t\"_tls_wrap\": \">= 0.11.3\",\n\t\"node:_tls_wrap\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"tls\": true,\n\t\"node:tls\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"trace_events\": \">= 10\",\n\t\"node:trace_events\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"tty\": true,\n\t\"node:tty\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"url\": true,\n\t\"node:url\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"util\": true,\n\t\"node:util\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"util/types\": \">= 15.3\",\n\t\"node:util/types\": \">= 16\",\n\t\"v8/tools/arguments\": \">= 10 && < 12\",\n\t\"v8/tools/codemap\": [\">= 4.4 && < 5\", \">= 5.2 && < 12\"],\n\t\"v8/tools/consarray\": [\">= 4.4 && < 5\", \">= 5.2 && < 12\"],\n\t\"v8/tools/csvparser\": [\">= 4.4 && < 5\", \">= 5.2 && < 12\"],\n\t\"v8/tools/logreader\": [\">= 4.4 && < 5\", \">= 5.2 && < 12\"],\n\t\"v8/tools/profile_view\": [\">= 4.4 && < 5\", \">= 5.2 && < 12\"],\n\t\"v8/tools/splaytree\": [\">= 4.4 && < 5\", \">= 5.2 && < 12\"],\n\t\"v8\": \">= 1\",\n\t\"node:v8\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"vm\": true,\n\t\"node:vm\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"wasi\": [\">= 13.4 && < 13.5\", \">= 18.17 && < 19\", \">= 20\"],\n\t\"node:wasi\": [\">= 18.17 && < 19\", \">= 20\"],\n\t\"worker_threads\": \">= 11.7\",\n\t\"node:worker_threads\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"zlib\": \">= 0.5\",\n\t\"node:zlib\": [\">= 14.18 && < 15\", \">= 16\"]\n}\n", "'use strict';\n\nvar hasOwn = require('hasown');\n\nfunction specifierIncluded(current, specifier) {\n\tvar nodeParts = current.split('.');\n\tvar parts = specifier.split(' ');\n\tvar op = parts.length > 1 ? parts[0] : '=';\n\tvar versionParts = (parts.length > 1 ? parts[1] : parts[0]).split('.');\n\n\tfor (var i = 0; i < 3; ++i) {\n\t\tvar cur = parseInt(nodeParts[i] || 0, 10);\n\t\tvar ver = parseInt(versionParts[i] || 0, 10);\n\t\tif (cur === ver) {\n\t\t\tcontinue; // eslint-disable-line no-restricted-syntax, no-continue\n\t\t}\n\t\tif (op === '<') {\n\t\t\treturn cur < ver;\n\t\t}\n\t\tif (op === '>=') {\n\t\t\treturn cur >= ver;\n\t\t}\n\t\treturn false;\n\t}\n\treturn op === '>=';\n}\n\nfunction matchesRange(current, range) {\n\tvar specifiers = range.split(/ ?&& ?/);\n\tif (specifiers.length === 0) {\n\t\treturn false;\n\t}\n\tfor (var i = 0; i < specifiers.length; ++i) {\n\t\tif (!specifierIncluded(current, specifiers[i])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nfunction versionIncluded(nodeVersion, specifierValue) {\n\tif (typeof specifierValue === 'boolean') {\n\t\treturn specifierValue;\n\t}\n\n\tvar current = typeof nodeVersion === 'undefined'\n\t\t? process.versions && process.versions.node\n\t\t: nodeVersion;\n\n\tif (typeof current !== 'string') {\n\t\tthrow new TypeError(typeof nodeVersion === 'undefined' ? 'Unable to determine current node version' : 'If provided, a valid node version is required');\n\t}\n\n\tif (specifierValue && typeof specifierValue === 'object') {\n\t\tfor (var i = 0; i < specifierValue.length; ++i) {\n\t\t\tif (matchesRange(current, specifierValue[i])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\treturn matchesRange(current, specifierValue);\n}\n\nvar data = require('./core.json');\n\nmodule.exports = function isCore(x, nodeVersion) {\n\treturn hasOwn(data, x) && versionIncluded(nodeVersion, data[x]);\n};\n", "var fs = require('fs');\nvar getHomedir = require('./homedir');\nvar path = require('path');\nvar caller = require('./caller');\nvar nodeModulesPaths = require('./node-modules-paths');\nvar normalizeOptions = require('./normalize-options');\nvar isCore = require('is-core-module');\n\nvar realpathFS = process.platform !== 'win32' && fs.realpath && typeof fs.realpath.native === 'function' ? fs.realpath.native : fs.realpath;\n\nvar homedir = getHomedir();\nvar defaultPaths = function () {\n    return [\n        path.join(homedir, '.node_modules'),\n        path.join(homedir, '.node_libraries')\n    ];\n};\n\nvar defaultIsFile = function isFile(file, cb) {\n    fs.stat(file, function (err, stat) {\n        if (!err) {\n            return cb(null, stat.isFile() || stat.isFIFO());\n        }\n        if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);\n        return cb(err);\n    });\n};\n\nvar defaultIsDir = function isDirectory(dir, cb) {\n    fs.stat(dir, function (err, stat) {\n        if (!err) {\n            return cb(null, stat.isDirectory());\n        }\n        if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);\n        return cb(err);\n    });\n};\n\nvar defaultRealpath = function realpath(x, cb) {\n    realpathFS(x, function (realpathErr, realPath) {\n        if (realpathErr && realpathErr.code !== 'ENOENT') cb(realpathErr);\n        else cb(null, realpathErr ? x : realPath);\n    });\n};\n\nvar maybeRealpath = function maybeRealpath(realpath, x, opts, cb) {\n    if (opts && opts.preserveSymlinks === false) {\n        realpath(x, cb);\n    } else {\n        cb(null, x);\n    }\n};\n\nvar defaultReadPackage = function defaultReadPackage(readFile, pkgfile, cb) {\n    readFile(pkgfile, function (readFileErr, body) {\n        if (readFileErr) cb(readFileErr);\n        else {\n            try {\n                var pkg = JSON.parse(body);\n                cb(null, pkg);\n            } catch (jsonErr) {\n                cb(null);\n            }\n        }\n    });\n};\n\nvar getPackageCandidates = function getPackageCandidates(x, start, opts) {\n    var dirs = nodeModulesPaths(start, opts, x);\n    for (var i = 0; i < dirs.length; i++) {\n        dirs[i] = path.join(dirs[i], x);\n    }\n    return dirs;\n};\n\nmodule.exports = function resolve(x, options, callback) {\n    var cb = callback;\n    var opts = options;\n    if (typeof options === 'function') {\n        cb = opts;\n        opts = {};\n    }\n    if (typeof x !== 'string') {\n        var err = new TypeError('Path must be a string.');\n        return process.nextTick(function () {\n            cb(err);\n        });\n    }\n\n    opts = normalizeOptions(x, opts);\n\n    var isFile = opts.isFile || defaultIsFile;\n    var isDirectory = opts.isDirectory || defaultIsDir;\n    var readFile = opts.readFile || fs.readFile;\n    var realpath = opts.realpath || defaultRealpath;\n    var readPackage = opts.readPackage || defaultReadPackage;\n    if (opts.readFile && opts.readPackage) {\n        var conflictErr = new TypeError('`readFile` and `readPackage` are mutually exclusive.');\n        return process.nextTick(function () {\n            cb(conflictErr);\n        });\n    }\n    var packageIterator = opts.packageIterator;\n\n    var extensions = opts.extensions || ['.js'];\n    var includeCoreModules = opts.includeCoreModules !== false;\n    var basedir = opts.basedir || path.dirname(caller());\n    var parent = opts.filename || basedir;\n\n    opts.paths = opts.paths || defaultPaths();\n\n    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory\n    var absoluteStart = path.resolve(basedir);\n\n    maybeRealpath(\n        realpath,\n        absoluteStart,\n        opts,\n        function (err, realStart) {\n            if (err) cb(err);\n            else init(realStart);\n        }\n    );\n\n    var res;\n    function init(basedir) {\n        if ((/^(?:\\.\\.?(?:\\/|$)|\\/|([A-Za-z]:)?[/\\\\])/).test(x)) {\n            res = path.resolve(basedir, x);\n            if (x === '.' || x === '..' || x.slice(-1) === '/') res += '/';\n            if ((/\\/$/).test(x) && res === basedir) {\n                loadAsDirectory(res, opts.package, onfile);\n            } else loadAsFile(res, opts.package, onfile);\n        } else if (includeCoreModules && isCore(x)) {\n            return cb(null, x);\n        } else loadNodeModules(x, basedir, function (err, n, pkg) {\n            if (err) cb(err);\n            else if (n) {\n                return maybeRealpath(realpath, n, opts, function (err, realN) {\n                    if (err) {\n                        cb(err);\n                    } else {\n                        cb(null, realN, pkg);\n                    }\n                });\n            } else {\n                var moduleError = new Error(\"Cannot find module '\" + x + \"' from '\" + parent + \"'\");\n                moduleError.code = 'MODULE_NOT_FOUND';\n                cb(moduleError);\n            }\n        });\n    }\n\n    function onfile(err, m, pkg) {\n        if (err) cb(err);\n        else if (m) cb(null, m, pkg);\n        else loadAsDirectory(res, function (err, d, pkg) {\n            if (err) cb(err);\n            else if (d) {\n                maybeRealpath(realpath, d, opts, function (err, realD) {\n                    if (err) {\n                        cb(err);\n                    } else {\n                        cb(null, realD, pkg);\n                    }\n                });\n            } else {\n                var moduleError = new Error(\"Cannot find module '\" + x + \"' from '\" + parent + \"'\");\n                moduleError.code = 'MODULE_NOT_FOUND';\n                cb(moduleError);\n            }\n        });\n    }\n\n    function loadAsFile(x, thePackage, callback) {\n        var loadAsFilePackage = thePackage;\n        var cb = callback;\n        if (typeof loadAsFilePackage === 'function') {\n            cb = loadAsFilePackage;\n            loadAsFilePackage = undefined;\n        }\n\n        var exts = [''].concat(extensions);\n        load(exts, x, loadAsFilePackage);\n\n        function load(exts, x, loadPackage) {\n            if (exts.length === 0) return cb(null, undefined, loadPackage);\n            var file = x + exts[0];\n\n            var pkg = loadPackage;\n            if (pkg) onpkg(null, pkg);\n            else loadpkg(path.dirname(file), onpkg);\n\n            function onpkg(err, pkg_, dir) {\n                pkg = pkg_;\n                if (err) return cb(err);\n                if (dir && pkg && opts.pathFilter) {\n                    var rfile = path.relative(dir, file);\n                    var rel = rfile.slice(0, rfile.length - exts[0].length);\n                    var r = opts.pathFilter(pkg, x, rel);\n                    if (r) return load(\n                        [''].concat(extensions.slice()),\n                        path.resolve(dir, r),\n                        pkg\n                    );\n                }\n                isFile(file, onex);\n            }\n            function onex(err, ex) {\n                if (err) return cb(err);\n                if (ex) return cb(null, file, pkg);\n                load(exts.slice(1), x, pkg);\n            }\n        }\n    }\n\n    function loadpkg(dir, cb) {\n        if (dir === '' || dir === '/') return cb(null);\n        if (process.platform === 'win32' && (/^\\w:[/\\\\]*$/).test(dir)) {\n            return cb(null);\n        }\n        if ((/[/\\\\]node_modules[/\\\\]*$/).test(dir)) return cb(null);\n\n        maybeRealpath(realpath, dir, opts, function (unwrapErr, pkgdir) {\n            if (unwrapErr) return loadpkg(path.dirname(dir), cb);\n            var pkgfile = path.join(pkgdir, 'package.json');\n            isFile(pkgfile, function (err, ex) {\n                // on err, ex is false\n                if (!ex) return loadpkg(path.dirname(dir), cb);\n\n                readPackage(readFile, pkgfile, function (err, pkgParam) {\n                    if (err) cb(err);\n\n                    var pkg = pkgParam;\n\n                    if (pkg && opts.packageFilter) {\n                        pkg = opts.packageFilter(pkg, pkgfile);\n                    }\n                    cb(null, pkg, dir);\n                });\n            });\n        });\n    }\n\n    function loadAsDirectory(x, loadAsDirectoryPackage, callback) {\n        var cb = callback;\n        var fpkg = loadAsDirectoryPackage;\n        if (typeof fpkg === 'function') {\n            cb = fpkg;\n            fpkg = opts.package;\n        }\n\n        maybeRealpath(realpath, x, opts, function (unwrapErr, pkgdir) {\n            if (unwrapErr) return cb(unwrapErr);\n            var pkgfile = path.join(pkgdir, 'package.json');\n            isFile(pkgfile, function (err, ex) {\n                if (err) return cb(err);\n                if (!ex) return loadAsFile(path.join(x, 'index'), fpkg, cb);\n\n                readPackage(readFile, pkgfile, function (err, pkgParam) {\n                    if (err) return cb(err);\n\n                    var pkg = pkgParam;\n\n                    if (pkg && opts.packageFilter) {\n                        pkg = opts.packageFilter(pkg, pkgfile);\n                    }\n\n                    if (pkg && pkg.main) {\n                        if (typeof pkg.main !== 'string') {\n                            var mainError = new TypeError('package ' + pkg.name + ' `main` must be a string');\n                            mainError.code = 'INVALID_PACKAGE_MAIN';\n                            return cb(mainError);\n                        }\n                        if (pkg.main === '.' || pkg.main === './') {\n                            pkg.main = 'index';\n                        }\n                        loadAsFile(path.resolve(x, pkg.main), pkg, function (err, m, pkg) {\n                            if (err) return cb(err);\n                            if (m) return cb(null, m, pkg);\n                            if (!pkg) return loadAsFile(path.join(x, 'index'), pkg, cb);\n\n                            var dir = path.resolve(x, pkg.main);\n                            loadAsDirectory(dir, pkg, function (err, n, pkg) {\n                                if (err) return cb(err);\n                                if (n) return cb(null, n, pkg);\n                                loadAsFile(path.join(x, 'index'), pkg, cb);\n                            });\n                        });\n                        return;\n                    }\n\n                    loadAsFile(path.join(x, '/index'), pkg, cb);\n                });\n            });\n        });\n    }\n\n    function processDirs(cb, dirs) {\n        if (dirs.length === 0) return cb(null, undefined);\n        var dir = dirs[0];\n\n        isDirectory(path.dirname(dir), isdir);\n\n        function isdir(err, isdir) {\n            if (err) return cb(err);\n            if (!isdir) return processDirs(cb, dirs.slice(1));\n            loadAsFile(dir, opts.package, onfile);\n        }\n\n        function onfile(err, m, pkg) {\n            if (err) return cb(err);\n            if (m) return cb(null, m, pkg);\n            loadAsDirectory(dir, opts.package, ondir);\n        }\n\n        function ondir(err, n, pkg) {\n            if (err) return cb(err);\n            if (n) return cb(null, n, pkg);\n            processDirs(cb, dirs.slice(1));\n        }\n    }\n    function loadNodeModules(x, start, cb) {\n        var thunk = function () { return getPackageCandidates(x, start, opts); };\n        processDirs(\n            cb,\n            packageIterator ? packageIterator(x, start, thunk, opts) : thunk()\n        );\n    }\n};\n", "{\n\t\"assert\": true,\n\t\"node:assert\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"assert/strict\": \">= 15\",\n\t\"node:assert/strict\": \">= 16\",\n\t\"async_hooks\": \">= 8\",\n\t\"node:async_hooks\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"buffer_ieee754\": \">= 0.5 && < 0.9.7\",\n\t\"buffer\": true,\n\t\"node:buffer\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"child_process\": true,\n\t\"node:child_process\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"cluster\": \">= 0.5\",\n\t\"node:cluster\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"console\": true,\n\t\"node:console\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"constants\": true,\n\t\"node:constants\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"crypto\": true,\n\t\"node:crypto\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_debug_agent\": \">= 1 && < 8\",\n\t\"_debugger\": \"< 8\",\n\t\"dgram\": true,\n\t\"node:dgram\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"diagnostics_channel\": [\">= 14.17 && < 15\", \">= 15.1\"],\n\t\"node:diagnostics_channel\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"dns\": true,\n\t\"node:dns\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"dns/promises\": \">= 15\",\n\t\"node:dns/promises\": \">= 16\",\n\t\"domain\": \">= 0.7.12\",\n\t\"node:domain\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"events\": true,\n\t\"node:events\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"freelist\": \"< 6\",\n\t\"fs\": true,\n\t\"node:fs\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"fs/promises\": [\">= 10 && < 10.1\", \">= 14\"],\n\t\"node:fs/promises\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_http_agent\": \">= 0.11.1\",\n\t\"node:_http_agent\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_http_client\": \">= 0.11.1\",\n\t\"node:_http_client\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_http_common\": \">= 0.11.1\",\n\t\"node:_http_common\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_http_incoming\": \">= 0.11.1\",\n\t\"node:_http_incoming\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_http_outgoing\": \">= 0.11.1\",\n\t\"node:_http_outgoing\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_http_server\": \">= 0.11.1\",\n\t\"node:_http_server\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"http\": true,\n\t\"node:http\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"http2\": \">= 8.8\",\n\t\"node:http2\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"https\": true,\n\t\"node:https\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"inspector\": \">= 8\",\n\t\"node:inspector\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"inspector/promises\": [\">= 19\"],\n\t\"node:inspector/promises\": [\">= 19\"],\n\t\"_linklist\": \"< 8\",\n\t\"module\": true,\n\t\"node:module\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"net\": true,\n\t\"node:net\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"node-inspect/lib/_inspect\": \">= 7.6 && < 12\",\n\t\"node-inspect/lib/internal/inspect_client\": \">= 7.6 && < 12\",\n\t\"node-inspect/lib/internal/inspect_repl\": \">= 7.6 && < 12\",\n\t\"os\": true,\n\t\"node:os\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"path\": true,\n\t\"node:path\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"path/posix\": \">= 15.3\",\n\t\"node:path/posix\": \">= 16\",\n\t\"path/win32\": \">= 15.3\",\n\t\"node:path/win32\": \">= 16\",\n\t\"perf_hooks\": \">= 8.5\",\n\t\"node:perf_hooks\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"process\": \">= 1\",\n\t\"node:process\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"punycode\": \">= 0.5\",\n\t\"node:punycode\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"querystring\": true,\n\t\"node:querystring\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"readline\": true,\n\t\"node:readline\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"readline/promises\": \">= 17\",\n\t\"node:readline/promises\": \">= 17\",\n\t\"repl\": true,\n\t\"node:repl\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"smalloc\": \">= 0.11.5 && < 3\",\n\t\"_stream_duplex\": \">= 0.9.4\",\n\t\"node:_stream_duplex\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_stream_transform\": \">= 0.9.4\",\n\t\"node:_stream_transform\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_stream_wrap\": \">= 1.4.1\",\n\t\"node:_stream_wrap\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_stream_passthrough\": \">= 0.9.4\",\n\t\"node:_stream_passthrough\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_stream_readable\": \">= 0.9.4\",\n\t\"node:_stream_readable\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_stream_writable\": \">= 0.9.4\",\n\t\"node:_stream_writable\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"stream\": true,\n\t\"node:stream\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"stream/consumers\": \">= 16.7\",\n\t\"node:stream/consumers\": \">= 16.7\",\n\t\"stream/promises\": \">= 15\",\n\t\"node:stream/promises\": \">= 16\",\n\t\"stream/web\": \">= 16.5\",\n\t\"node:stream/web\": \">= 16.5\",\n\t\"string_decoder\": true,\n\t\"node:string_decoder\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"sys\": [\">= 0.4 && < 0.7\", \">= 0.8\"],\n\t\"node:sys\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"test/reporters\": \">= 19.9 && < 20.2\",\n\t\"node:test/reporters\": [\">= 18.17 && < 19\", \">= 19.9\", \">= 20\"],\n\t\"node:test\": [\">= 16.17 && < 17\", \">= 18\"],\n\t\"timers\": true,\n\t\"node:timers\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"timers/promises\": \">= 15\",\n\t\"node:timers/promises\": \">= 16\",\n\t\"_tls_common\": \">= 0.11.13\",\n\t\"node:_tls_common\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_tls_legacy\": \">= 0.11.3 && < 10\",\n\t\"_tls_wrap\": \">= 0.11.3\",\n\t\"node:_tls_wrap\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"tls\": true,\n\t\"node:tls\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"trace_events\": \">= 10\",\n\t\"node:trace_events\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"tty\": true,\n\t\"node:tty\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"url\": true,\n\t\"node:url\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"util\": true,\n\t\"node:util\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"util/types\": \">= 15.3\",\n\t\"node:util/types\": \">= 16\",\n\t\"v8/tools/arguments\": \">= 10 && < 12\",\n\t\"v8/tools/codemap\": [\">= 4.4 && < 5\", \">= 5.2 && < 12\"],\n\t\"v8/tools/consarray\": [\">= 4.4 && < 5\", \">= 5.2 && < 12\"],\n\t\"v8/tools/csvparser\": [\">= 4.4 && < 5\", \">= 5.2 && < 12\"],\n\t\"v8/tools/logreader\": [\">= 4.4 && < 5\", \">= 5.2 && < 12\"],\n\t\"v8/tools/profile_view\": [\">= 4.4 && < 5\", \">= 5.2 && < 12\"],\n\t\"v8/tools/splaytree\": [\">= 4.4 && < 5\", \">= 5.2 && < 12\"],\n\t\"v8\": \">= 1\",\n\t\"node:v8\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"vm\": true,\n\t\"node:vm\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"wasi\": [\">= 13.4 && < 13.5\", \">= 18.17 && < 19\", \">= 20\"],\n\t\"node:wasi\": [\">= 18.17 && < 19\", \">= 20\"],\n\t\"worker_threads\": \">= 11.7\",\n\t\"node:worker_threads\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"zlib\": \">= 0.5\",\n\t\"node:zlib\": [\">= 14.18 && < 15\", \">= 16\"]\n}\n", "'use strict';\n\nvar isCoreModule = require('is-core-module');\nvar data = require('./core.json');\n\nvar core = {};\nfor (var mod in data) { // eslint-disable-line no-restricted-syntax\n    if (Object.prototype.hasOwnProperty.call(data, mod)) {\n        core[mod] = isCoreModule(mod);\n    }\n}\nmodule.exports = core;\n", "var isCoreModule = require('is-core-module');\n\nmodule.exports = function isCore(x) {\n    return isCoreModule(x);\n};\n", "var isCore = require('is-core-module');\nvar fs = require('fs');\nvar path = require('path');\nvar getHomedir = require('./homedir');\nvar caller = require('./caller');\nvar nodeModulesPaths = require('./node-modules-paths');\nvar normalizeOptions = require('./normalize-options');\n\nvar realpathFS = process.platform !== 'win32' && fs.realpathSync && typeof fs.realpathSync.native === 'function' ? fs.realpathSync.native : fs.realpathSync;\n\nvar homedir = getHomedir();\nvar defaultPaths = function () {\n    return [\n        path.join(homedir, '.node_modules'),\n        path.join(homedir, '.node_libraries')\n    ];\n};\n\nvar defaultIsFile = function isFile(file) {\n    try {\n        var stat = fs.statSync(file, { throwIfNoEntry: false });\n    } catch (e) {\n        if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;\n        throw e;\n    }\n    return !!stat && (stat.isFile() || stat.isFIFO());\n};\n\nvar defaultIsDir = function isDirectory(dir) {\n    try {\n        var stat = fs.statSync(dir, { throwIfNoEntry: false });\n    } catch (e) {\n        if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;\n        throw e;\n    }\n    return !!stat && stat.isDirectory();\n};\n\nvar defaultRealpathSync = function realpathSync(x) {\n    try {\n        return realpathFS(x);\n    } catch (realpathErr) {\n        if (realpathErr.code !== 'ENOENT') {\n            throw realpathErr;\n        }\n    }\n    return x;\n};\n\nvar maybeRealpathSync = function maybeRealpathSync(realpathSync, x, opts) {\n    if (opts && opts.preserveSymlinks === false) {\n        return realpathSync(x);\n    }\n    return x;\n};\n\nvar defaultReadPackageSync = function defaultReadPackageSync(readFileSync, pkgfile) {\n    var body = readFileSync(pkgfile);\n    try {\n        var pkg = JSON.parse(body);\n        return pkg;\n    } catch (jsonErr) {}\n};\n\nvar getPackageCandidates = function getPackageCandidates(x, start, opts) {\n    var dirs = nodeModulesPaths(start, opts, x);\n    for (var i = 0; i < dirs.length; i++) {\n        dirs[i] = path.join(dirs[i], x);\n    }\n    return dirs;\n};\n\nmodule.exports = function resolveSync(x, options) {\n    if (typeof x !== 'string') {\n        throw new TypeError('Path must be a string.');\n    }\n    var opts = normalizeOptions(x, options);\n\n    var isFile = opts.isFile || defaultIsFile;\n    var readFileSync = opts.readFileSync || fs.readFileSync;\n    var isDirectory = opts.isDirectory || defaultIsDir;\n    var realpathSync = opts.realpathSync || defaultRealpathSync;\n    var readPackageSync = opts.readPackageSync || defaultReadPackageSync;\n    if (opts.readFileSync && opts.readPackageSync) {\n        throw new TypeError('`readFileSync` and `readPackageSync` are mutually exclusive.');\n    }\n    var packageIterator = opts.packageIterator;\n\n    var extensions = opts.extensions || ['.js'];\n    var includeCoreModules = opts.includeCoreModules !== false;\n    var basedir = opts.basedir || path.dirname(caller());\n    var parent = opts.filename || basedir;\n\n    opts.paths = opts.paths || defaultPaths();\n\n    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory\n    var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);\n\n    if ((/^(?:\\.\\.?(?:\\/|$)|\\/|([A-Za-z]:)?[/\\\\])/).test(x)) {\n        var res = path.resolve(absoluteStart, x);\n        if (x === '.' || x === '..' || x.slice(-1) === '/') res += '/';\n        var m = loadAsFileSync(res) || loadAsDirectorySync(res);\n        if (m) return maybeRealpathSync(realpathSync, m, opts);\n    } else if (includeCoreModules && isCore(x)) {\n        return x;\n    } else {\n        var n = loadNodeModulesSync(x, absoluteStart);\n        if (n) return maybeRealpathSync(realpathSync, n, opts);\n    }\n\n    var err = new Error(\"Cannot find module '\" + x + \"' from '\" + parent + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n\n    function loadAsFileSync(x) {\n        var pkg = loadpkg(path.dirname(x));\n\n        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {\n            var rfile = path.relative(pkg.dir, x);\n            var r = opts.pathFilter(pkg.pkg, x, rfile);\n            if (r) {\n                x = path.resolve(pkg.dir, r); // eslint-disable-line no-param-reassign\n            }\n        }\n\n        if (isFile(x)) {\n            return x;\n        }\n\n        for (var i = 0; i < extensions.length; i++) {\n            var file = x + extensions[i];\n            if (isFile(file)) {\n                return file;\n            }\n        }\n    }\n\n    function loadpkg(dir) {\n        if (dir === '' || dir === '/') return;\n        if (process.platform === 'win32' && (/^\\w:[/\\\\]*$/).test(dir)) {\n            return;\n        }\n        if ((/[/\\\\]node_modules[/\\\\]*$/).test(dir)) return;\n\n        var pkgfile = path.join(maybeRealpathSync(realpathSync, dir, opts), 'package.json');\n\n        if (!isFile(pkgfile)) {\n            return loadpkg(path.dirname(dir));\n        }\n\n        var pkg = readPackageSync(readFileSync, pkgfile);\n\n        if (pkg && opts.packageFilter) {\n            // v2 will pass pkgfile\n            pkg = opts.packageFilter(pkg, /*pkgfile,*/ dir); // eslint-disable-line spaced-comment\n        }\n\n        return { pkg: pkg, dir: dir };\n    }\n\n    function loadAsDirectorySync(x) {\n        var pkgfile = path.join(maybeRealpathSync(realpathSync, x, opts), '/package.json');\n        if (isFile(pkgfile)) {\n            try {\n                var pkg = readPackageSync(readFileSync, pkgfile);\n            } catch (e) {}\n\n            if (pkg && opts.packageFilter) {\n                // v2 will pass pkgfile\n                pkg = opts.packageFilter(pkg, /*pkgfile,*/ x); // eslint-disable-line spaced-comment\n            }\n\n            if (pkg && pkg.main) {\n                if (typeof pkg.main !== 'string') {\n                    var mainError = new TypeError('package ' + pkg.name + ' `main` must be a string');\n                    mainError.code = 'INVALID_PACKAGE_MAIN';\n                    throw mainError;\n                }\n                if (pkg.main === '.' || pkg.main === './') {\n                    pkg.main = 'index';\n                }\n                try {\n                    var m = loadAsFileSync(path.resolve(x, pkg.main));\n                    if (m) return m;\n                    var n = loadAsDirectorySync(path.resolve(x, pkg.main));\n                    if (n) return n;\n                } catch (e) {}\n            }\n        }\n\n        return loadAsFileSync(path.join(x, '/index'));\n    }\n\n    function loadNodeModulesSync(x, start) {\n        var thunk = function () { return getPackageCandidates(x, start, opts); };\n        var dirs = packageIterator ? packageIterator(x, start, thunk, opts) : thunk();\n\n        for (var i = 0; i < dirs.length; i++) {\n            var dir = dirs[i];\n            if (isDirectory(path.dirname(dir))) {\n                var m = loadAsFileSync(dir);\n                if (m) return m;\n                var n = loadAsDirectorySync(dir);\n                if (n) return n;\n            }\n        }\n    }\n};\n", "var async = require('./lib/async');\nasync.core = require('./lib/core');\nasync.isCore = require('./lib/is-core');\nasync.sync = require('./lib/sync');\n\nmodule.exports = async;\n", "'use strict';\nconst path = require('path');\nconst Module = require('module');\nconst fs = require('fs');\n\nconst resolveFrom = (fromDir, moduleId, silent) => {\n\tif (typeof fromDir !== 'string') {\n\t\tthrow new TypeError(`Expected \\`fromDir\\` to be of type \\`string\\`, got \\`${typeof fromDir}\\``);\n\t}\n\n\tif (typeof moduleId !== 'string') {\n\t\tthrow new TypeError(`Expected \\`moduleId\\` to be of type \\`string\\`, got \\`${typeof moduleId}\\``);\n\t}\n\n\ttry {\n\t\tfromDir = fs.realpathSync(fromDir);\n\t} catch (err) {\n\t\tif (err.code === 'ENOENT') {\n\t\t\tfromDir = path.resolve(fromDir);\n\t\t} else if (silent) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\tconst fromFile = path.join(fromDir, 'noop.js');\n\n\tconst resolveFileName = () => Module._resolveFilename(moduleId, {\n\t\tid: fromFile,\n\t\tfilename: fromFile,\n\t\tpaths: Module._nodeModulePaths(fromDir)\n\t});\n\n\tif (silent) {\n\t\ttry {\n\t\t\treturn resolveFileName();\n\t\t} catch (err) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\treturn resolveFileName();\n};\n\nmodule.exports = (fromDir, moduleId) => resolveFrom(fromDir, moduleId);\nmodule.exports.silent = (fromDir, moduleId) => resolveFrom(fromDir, moduleId, true);\n", "'use strict';\n\nconst callsites = () => {\n\tconst _prepareStackTrace = Error.prepareStackTrace;\n\tError.prepareStackTrace = (_, stack) => stack;\n\tconst stack = new Error().stack.slice(1);\n\tError.prepareStackTrace = _prepareStackTrace;\n\treturn stack;\n};\n\nmodule.exports = callsites;\n// TODO: Remove this for the next major release\nmodule.exports.default = callsites;\n", "'use strict';\nconst callsites = require('callsites');\n\nmodule.exports = filepath => {\n\tconst stacks = callsites();\n\n\tif (!filepath) {\n\t\treturn stacks[2].getFileName();\n\t}\n\n\tlet seenVal = false;\n\n\t// Skip the first stack as it's this function\n\tstacks.shift();\n\n\tfor (const stack of stacks) {\n\t\tconst parentFilepath = stack.getFileName();\n\n\t\tif (typeof parentFilepath !== 'string') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (parentFilepath === filepath) {\n\t\t\tseenVal = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Skip native modules\n\t\tif (parentFilepath === 'module.js') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (seenVal && parentFilepath !== filepath) {\n\t\t\treturn parentFilepath;\n\t\t}\n\t}\n};\n", "'use strict';\nconst path = require('path');\nconst resolveFrom = require('resolve-from');\nconst parentModule = require('parent-module');\n\nmodule.exports = moduleId => {\n\tif (typeof moduleId !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\tconst parentPath = parentModule(__filename);\n\n\tconst cwd = parentPath ? path.dirname(parentPath) : __dirname;\n\tconst filePath = resolveFrom(cwd, moduleId);\n\n\tconst oldModule = require.cache[filePath];\n\t// Delete itself from module parent\n\tif (oldModule && oldModule.parent) {\n\t\tlet i = oldModule.parent.children.length;\n\n\t\twhile (i--) {\n\t\t\tif (oldModule.parent.children[i].id === filePath) {\n\t\t\t\toldModule.parent.children.splice(i, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tdelete require.cache[filePath]; // Delete module from cache\n\n\tconst parent = require.cache[parentPath]; // If `filePath` and `parentPath` are the same, cache will already be deleted so we won't get a memory leak in next step\n\n\treturn parent === undefined ? require(filePath) : parent.require(filePath); // In case cache doesn't have parent, fall back to normal require\n};\n", "module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"util\" has been externalized for browser compatibility. Cannot access \"util.${key}\" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "'use strict';\n\nmodule.exports = function isArrayish(obj) {\n\tif (!obj) {\n\t\treturn false;\n\t}\n\n\treturn obj instanceof Array || Array.isArray(obj) ||\n\t\t(obj.length >= 0 && obj.splice instanceof Function);\n};\n", "'use strict';\n\nvar util = require('util');\nvar isArrayish = require('is-arrayish');\n\nvar errorEx = function errorEx(name, properties) {\n\tif (!name || name.constructor !== String) {\n\t\tproperties = name || {};\n\t\tname = Error.name;\n\t}\n\n\tvar errorExError = function ErrorEXError(message) {\n\t\tif (!this) {\n\t\t\treturn new ErrorEXError(message);\n\t\t}\n\n\t\tmessage = message instanceof Error\n\t\t\t? message.message\n\t\t\t: (message || this.message);\n\n\t\tError.call(this, message);\n\t\tError.captureStackTrace(this, errorExError);\n\n\t\tthis.name = name;\n\n\t\tObject.defineProperty(this, 'message', {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tget: function () {\n\t\t\t\tvar newMessage = message.split(/\\r?\\n/g);\n\n\t\t\t\tfor (var key in properties) {\n\t\t\t\t\tif (!properties.hasOwnProperty(key)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar modifier = properties[key];\n\n\t\t\t\t\tif ('message' in modifier) {\n\t\t\t\t\t\tnewMessage = modifier.message(this[key], newMessage) || newMessage;\n\t\t\t\t\t\tif (!isArrayish(newMessage)) {\n\t\t\t\t\t\t\tnewMessage = [newMessage];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn newMessage.join('\\n');\n\t\t\t},\n\t\t\tset: function (v) {\n\t\t\t\tmessage = v;\n\t\t\t}\n\t\t});\n\n\t\tvar overwrittenStack = null;\n\n\t\tvar stackDescriptor = Object.getOwnPropertyDescriptor(this, 'stack');\n\t\tvar stackGetter = stackDescriptor.get;\n\t\tvar stackValue = stackDescriptor.value;\n\t\tdelete stackDescriptor.value;\n\t\tdelete stackDescriptor.writable;\n\n\t\tstackDescriptor.set = function (newstack) {\n\t\t\toverwrittenStack = newstack;\n\t\t};\n\n\t\tstackDescriptor.get = function () {\n\t\t\tvar stack = (overwrittenStack || ((stackGetter)\n\t\t\t\t? stackGetter.call(this)\n\t\t\t\t: stackValue)).split(/\\r?\\n+/g);\n\n\t\t\t// starting in Node 7, the stack builder caches the message.\n\t\t\t// just replace it.\n\t\t\tif (!overwrittenStack) {\n\t\t\t\tstack[0] = this.name + ': ' + this.message;\n\t\t\t}\n\n\t\t\tvar lineCount = 1;\n\t\t\tfor (var key in properties) {\n\t\t\t\tif (!properties.hasOwnProperty(key)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tvar modifier = properties[key];\n\n\t\t\t\tif ('line' in modifier) {\n\t\t\t\t\tvar line = modifier.line(this[key]);\n\t\t\t\t\tif (line) {\n\t\t\t\t\t\tstack.splice(lineCount++, 0, '    ' + line);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ('stack' in modifier) {\n\t\t\t\t\tmodifier.stack(this[key], stack);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn stack.join('\\n');\n\t\t};\n\n\t\tObject.defineProperty(this, 'stack', stackDescriptor);\n\t};\n\n\tif (Object.setPrototypeOf) {\n\t\tObject.setPrototypeOf(errorExError.prototype, Error.prototype);\n\t\tObject.setPrototypeOf(errorExError, Error);\n\t} else {\n\t\tutil.inherits(errorExError, Error);\n\t}\n\n\treturn errorExError;\n};\n\nerrorEx.append = function (str, def) {\n\treturn {\n\t\tmessage: function (v, message) {\n\t\t\tv = v || def;\n\n\t\t\tif (v) {\n\t\t\t\tmessage[0] += ' ' + str.replace('%s', v.toString());\n\t\t\t}\n\n\t\t\treturn message;\n\t\t}\n\t};\n};\n\nerrorEx.line = function (str, def) {\n\treturn {\n\t\tline: function (v) {\n\t\t\tv = v || def;\n\n\t\t\tif (v) {\n\t\t\t\treturn str.replace('%s', v.toString());\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t};\n};\n\nmodule.exports = errorEx;\n", "'use strict'\n\nconst hexify = char => {\n  const h = char.charCodeAt(0).toString(16).toUpperCase()\n  return '0x' + (h.length % 2 ? '0' : '') + h\n}\n\nconst parseError = (e, txt, context) => {\n  if (!txt) {\n    return {\n      message: e.message + ' while parsing empty string',\n      position: 0,\n    }\n  }\n  const badToken = e.message.match(/^Unexpected token (.) .*position\\s+(\\d+)/i)\n  const errIdx = badToken ? +badToken[2]\n    : e.message.match(/^Unexpected end of JSON.*/i) ? txt.length - 1\n    : null\n\n  const msg = badToken ? e.message.replace(/^Unexpected token ./, `Unexpected token ${\n      JSON.stringify(badToken[1])\n    } (${hexify(badToken[1])})`)\n    : e.message\n\n  if (errIdx !== null && errIdx !== undefined) {\n    const start = errIdx <= context ? 0\n      : errIdx - context\n\n    const end = errIdx + context >= txt.length ? txt.length\n      : errIdx + context\n\n    const slice = (start === 0 ? '' : '...') +\n      txt.slice(start, end) +\n      (end === txt.length ? '' : '...')\n\n    const near = txt === slice ? '' : 'near '\n\n    return {\n      message: msg + ` while parsing ${near}${JSON.stringify(slice)}`,\n      position: errIdx,\n    }\n  } else {\n    return {\n      message: msg + ` while parsing '${txt.slice(0, context * 2)}'`,\n      position: 0,\n    }\n  }\n}\n\nclass JSONParseError extends SyntaxError {\n  constructor (er, txt, context, caller) {\n    context = context || 20\n    const metadata = parseError(er, txt, context)\n    super(metadata.message)\n    Object.assign(this, metadata)\n    this.code = 'EJSONPARSE'\n    this.systemError = er\n    Error.captureStackTrace(this, caller || this.constructor)\n  }\n  get name () { return this.constructor.name }\n  set name (n) {}\n  get [Symbol.toStringTag] () { return this.constructor.name }\n}\n\nconst kIndent = Symbol.for('indent')\nconst kNewline = Symbol.for('newline')\n// only respect indentation if we got a line break, otherwise squash it\n// things other than objects and arrays aren't indented, so ignore those\n// Important: in both of these regexps, the $1 capture group is the newline\n// or undefined, and the $2 capture group is the indent, or undefined.\nconst formatRE = /^\\s*[{\\[]((?:\\r?\\n)+)([\\s\\t]*)/\nconst emptyRE = /^(?:\\{\\}|\\[\\])((?:\\r?\\n)+)?$/\n\nconst parseJson = (txt, reviver, context) => {\n  const parseText = stripBOM(txt)\n  context = context || 20\n  try {\n    // get the indentation so that we can save it back nicely\n    // if the file starts with {\" then we have an indent of '', ie, none\n    // otherwise, pick the indentation of the next line after the first \\n\n    // If the pattern doesn't match, then it means no indentation.\n    // JSON.stringify ignores symbols, so this is reasonably safe.\n    // if the string is '{}' or '[]', then use the default 2-space indent.\n    const [, newline = '\\n', indent = '  '] = parseText.match(emptyRE) ||\n      parseText.match(formatRE) ||\n      [, '', '']\n\n    const result = JSON.parse(parseText, reviver)\n    if (result && typeof result === 'object') {\n      result[kNewline] = newline\n      result[kIndent] = indent\n    }\n    return result\n  } catch (e) {\n    if (typeof txt !== 'string' && !Buffer.isBuffer(txt)) {\n      const isEmptyArray = Array.isArray(txt) && txt.length === 0\n      throw Object.assign(new TypeError(\n        `Cannot parse ${isEmptyArray ? 'an empty array' : String(txt)}`\n      ), {\n        code: 'EJSONPARSE',\n        systemError: e,\n      })\n    }\n\n    throw new JSONParseError(e, parseText, context, parseJson)\n  }\n}\n\n// Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n// because the buffer-to-string conversion in `fs.readFileSync()`\n// translates it to FEFF, the UTF-16 BOM.\nconst stripBOM = txt => String(txt).replace(/^\\uFEFF/, '')\n\nmodule.exports = parseJson\nparseJson.JSONParseError = JSONParseError\n\nparseJson.noExceptions = (txt, reviver) => {\n  try {\n    return JSON.parse(stripBOM(txt), reviver)\n  } catch (e) {}\n}\n", "\"use strict\";\nexports.__esModule = true;\nexports.LinesAndColumns = void 0;\nvar LF = '\\n';\nvar CR = '\\r';\nvar LinesAndColumns = /** @class */ (function () {\n    function LinesAndColumns(string) {\n        this.string = string;\n        var offsets = [0];\n        for (var offset = 0; offset < string.length;) {\n            switch (string[offset]) {\n                case LF:\n                    offset += LF.length;\n                    offsets.push(offset);\n                    break;\n                case CR:\n                    offset += CR.length;\n                    if (string[offset] === LF) {\n                        offset += LF.length;\n                    }\n                    offsets.push(offset);\n                    break;\n                default:\n                    offset++;\n                    break;\n            }\n        }\n        this.offsets = offsets;\n    }\n    LinesAndColumns.prototype.locationForIndex = function (index) {\n        if (index < 0 || index > this.string.length) {\n            return null;\n        }\n        var line = 0;\n        var offsets = this.offsets;\n        while (offsets[line + 1] <= index) {\n            line++;\n        }\n        var column = index - offsets[line];\n        return { line: line, column: column };\n    };\n    LinesAndColumns.prototype.indexForLocation = function (location) {\n        var line = location.line, column = location.column;\n        if (line < 0 || line >= this.offsets.length) {\n            return null;\n        }\n        if (column < 0 || column > this.lengthOfLine(line)) {\n            return null;\n        }\n        return this.offsets[line] + column;\n    };\n    LinesAndColumns.prototype.lengthOfLine = function (line) {\n        var offset = this.offsets[line];\n        var nextOffset = line === this.offsets.length - 1\n            ? this.string.length\n            : this.offsets[line + 1];\n        return nextOffset - offset;\n    };\n    return LinesAndColumns;\n}());\nexports.LinesAndColumns = LinesAndColumns;\nexports[\"default\"] = LinesAndColumns;\n", "var x=String;\nvar create=function() {return {isColorSupported:false,reset:x,bold:x,dim:x,italic:x,underline:x,inverse:x,hidden:x,strikethrough:x,black:x,red:x,green:x,yellow:x,blue:x,magenta:x,cyan:x,white:x,gray:x,bgBlack:x,bgRed:x,bgGreen:x,bgYellow:x,bgBlue:x,bgMagenta:x,bgCyan:x,bgWhite:x,blackBright:x,redBright:x,greenBright:x,yellowBright:x,blueBright:x,magentaBright:x,cyanBright:x,whiteBright:x,bgBlackBright:x,bgRedBright:x,bgGreenBright:x,bgYellowBright:x,bgBlueBright:x,bgMagentaBright:x,bgCyanBright:x,bgWhiteBright:x}};\nmodule.exports=create();\nmodule.exports.createColors = create;\n", "// Copyright 2014, 2015, 2016, 2017, 2018 Simon Lydell\n// License: MIT. (See LICENSE.)\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n})\n\n// This regex comes from regex.coffee, and is inserted here by generate-index.js\n// (run `npm run build`).\nexports.default = /((['\"])(?:(?!\\2|\\\\).|\\\\(?:\\r\\n|[\\s\\S]))*(\\2)?|`(?:[^`\\\\$]|\\\\[\\s\\S]|\\$(?!\\{)|\\$\\{(?:[^{}]|\\{[^}]*\\}?)*\\}?)*(`)?)|(\\/\\/.*)|(\\/\\*(?:[^*]|\\*(?!\\/))*(\\*\\/)?)|(\\/(?!\\*)(?:\\[(?:(?![\\]\\\\]).|\\\\.)*\\]|(?![\\/\\]\\\\]).|\\\\.)+\\/(?:(?!\\s*(?:\\b|[\\u0080-\\uFFFF$\\\\'\"~({]|[+\\-!](?!=)|\\.?\\d))|[gmiyus]{1,6}\\b(?![\\u0080-\\uFFFF$\\\\]|\\s*(?:[+\\-*%&|^<>!=?({]|\\/(?![\\/*])))))|(0[xX][\\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?)|((?!\\d)(?:(?!\\s)[$\\w\\u0080-\\uFFFF]|\\\\u[\\da-fA-F]{4}|\\\\u\\{[\\da-fA-F]+\\})+)|(--|\\+\\+|&&|\\|\\||=>|\\.{3}|(?:[+\\-\\/%&|^]|\\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\\](){}])|(\\s+)|(^$|[\\s\\S])/g\n\nexports.matchToToken = function(match) {\n  var token = {type: \"invalid\", value: match[0], closed: undefined}\n       if (match[ 1]) token.type = \"string\" , token.closed = !!(match[3] || match[4])\n  else if (match[ 5]) token.type = \"comment\"\n  else if (match[ 6]) token.type = \"comment\", token.closed = !!match[7]\n  else if (match[ 8]) token.type = \"regex\"\n  else if (match[ 9]) token.type = \"number\"\n  else if (match[10]) token.type = \"name\"\n  else if (match[11]) token.type = \"punctuator\"\n  else if (match[12]) token.type = \"whitespace\"\n  return token\n}\n", "import picocolors, { createColors } from \"picocolors\";\nimport type { Colors, Formatter } from \"picocolors/types\";\n\nexport function isColorSupported() {\n  return (\n    // See https://github.com/alexeyraspopov/picocolors/issues/62\n    typeof process === \"object\" &&\n      (process.env.FORCE_COLOR === \"0\" || process.env.FORCE_COLOR === \"false\")\n      ? false\n      : picocolors.isColorSupported\n  );\n}\n\nexport type InternalTokenType =\n  | \"keyword\"\n  | \"capitalized\"\n  | \"jsxIdentifier\"\n  | \"punctuator\"\n  | \"number\"\n  | \"string\"\n  | \"regex\"\n  | \"comment\"\n  | \"invalid\";\n\ntype UITokens = \"gutter\" | \"marker\" | \"message\";\n\nexport type Defs = {\n  [_ in InternalTokenType | UITokens | \"reset\"]: Formatter;\n};\n\nconst compose: <T, U, V>(f: (gv: U) => V, g: (v: T) => U) => (v: T) => V =\n  (f, g) => v =>\n    f(g(v));\n\n/**\n * Styles for token types.\n */\nfunction buildDefs(colors: Colors): Defs {\n  return {\n    keyword: colors.cyan,\n    capitalized: colors.yellow,\n    jsxIdentifier: colors.yellow,\n    punctuator: colors.yellow,\n    number: colors.magenta,\n    string: colors.green,\n    regex: colors.magenta,\n    comment: colors.gray,\n    invalid: compose(compose(colors.white, colors.bgRed), colors.bold),\n\n    gutter: colors.gray,\n    marker: compose(colors.red, colors.bold),\n    message: compose(colors.red, colors.bold),\n\n    reset: colors.reset,\n  };\n}\n\nconst defsOn = buildDefs(createColors(true));\nconst defsOff = buildDefs(createColors(false));\n\nexport function getDefs(enabled: boolean): Defs {\n  return enabled ? defsOn : defsOff;\n}\n", "import type { Token as JSToken, JSXToken } from \"js-tokens\";\nimport jsTokens from \"js-tokens\";\n\nimport {\n  isStrictReservedWord,\n  isKeyword,\n} from \"@babel/helper-validator-identifier\";\n\nimport { getDefs, type InternalTokenType } from \"./defs.ts\";\n\n/**\n * Names that are always allowed as identifiers, but also appear as keywords\n * within certain syntactic productions.\n *\n * https://tc39.es/ecma262/#sec-keywords-and-reserved-words\n *\n * `target` has been omitted since it is very likely going to be a false\n * positive.\n */\nconst sometimesKeywords = new Set([\"as\", \"async\", \"from\", \"get\", \"of\", \"set\"]);\n\ntype Token = {\n  type: InternalTokenType | \"uncolored\";\n  value: string;\n};\n\n/**\n * RegExp to test for newlines in terminal.\n */\nconst NEWLINE = /\\r\\n|[\\n\\r\\u2028\\u2029]/;\n\n/**\n * RegExp to test for the three types of brackets.\n */\nconst BRACKET = /^[()[\\]{}]$/;\n\nlet tokenize: (\n  text: string,\n) => Generator<{ type: InternalTokenType | \"uncolored\"; value: string }>;\n\nif (process.env.BABEL_8_BREAKING) {\n  /**\n   * Get the type of token, specifying punctuator type.\n   */\n  const getTokenType = function (\n    token: JSToken | JSXToken,\n  ): InternalTokenType | \"uncolored\" {\n    if (token.type === \"IdentifierName\") {\n      if (\n        isKeyword(token.value) ||\n        isStrictReservedWord(token.value, true) ||\n        sometimesKeywords.has(token.value)\n      ) {\n        return \"keyword\";\n      }\n\n      if (token.value[0] !== token.value[0].toLowerCase()) {\n        return \"capitalized\";\n      }\n    }\n\n    if (token.type === \"Punctuator\" && BRACKET.test(token.value)) {\n      return \"uncolored\";\n    }\n\n    if (token.type === \"Invalid\" && token.value === \"@\") {\n      return \"punctuator\";\n    }\n\n    switch (token.type) {\n      case \"NumericLiteral\":\n        return \"number\";\n\n      case \"StringLiteral\":\n      case \"JSXString\":\n      case \"NoSubstitutionTemplate\":\n        return \"string\";\n\n      case \"RegularExpressionLiteral\":\n        return \"regex\";\n\n      case \"Punctuator\":\n      case \"JSXPunctuator\":\n        return \"punctuator\";\n\n      case \"MultiLineComment\":\n      case \"SingleLineComment\":\n        return \"comment\";\n\n      case \"Invalid\":\n      case \"JSXInvalid\":\n        return \"invalid\";\n\n      case \"JSXIdentifier\":\n        return \"jsxIdentifier\";\n\n      default:\n        return \"uncolored\";\n    }\n  };\n\n  /**\n   * Turn a string of JS into an array of objects.\n   */\n  tokenize = function* (text: string): Generator<Token> {\n    for (const token of jsTokens(text, { jsx: true })) {\n      switch (token.type) {\n        case \"TemplateHead\":\n          yield { type: \"string\", value: token.value.slice(0, -2) };\n          yield { type: \"punctuator\", value: \"${\" };\n          break;\n\n        case \"TemplateMiddle\":\n          yield { type: \"punctuator\", value: \"}\" };\n          yield { type: \"string\", value: token.value.slice(1, -2) };\n          yield { type: \"punctuator\", value: \"${\" };\n          break;\n\n        case \"TemplateTail\":\n          yield { type: \"punctuator\", value: \"}\" };\n          yield { type: \"string\", value: token.value.slice(1) };\n          break;\n\n        default:\n          yield {\n            type: getTokenType(token),\n            value: token.value,\n          };\n      }\n    }\n  };\n} else {\n  /**\n   * RegExp to test for what seems to be a JSX tag name.\n   */\n  const JSX_TAG = /^[a-z][\\w-]*$/i;\n\n  // The token here is defined in js-tokens@4. However we don't bother\n  // typing it since the whole block will be removed in Babel 8\n  const getTokenType = function (token: any, offset: number, text: string) {\n    if (token.type === \"name\") {\n      if (\n        isKeyword(token.value) ||\n        isStrictReservedWord(token.value, true) ||\n        sometimesKeywords.has(token.value)\n      ) {\n        return \"keyword\";\n      }\n\n      if (\n        JSX_TAG.test(token.value) &&\n        (text[offset - 1] === \"<\" || text.slice(offset - 2, offset) === \"</\")\n      ) {\n        return \"jsxIdentifier\";\n      }\n\n      if (token.value[0] !== token.value[0].toLowerCase()) {\n        return \"capitalized\";\n      }\n    }\n\n    if (token.type === \"punctuator\" && BRACKET.test(token.value)) {\n      return \"bracket\";\n    }\n\n    if (\n      token.type === \"invalid\" &&\n      (token.value === \"@\" || token.value === \"#\")\n    ) {\n      return \"punctuator\";\n    }\n\n    return token.type;\n  };\n\n  tokenize = function* (text: string) {\n    let match;\n    while ((match = (jsTokens as any).default.exec(text))) {\n      const token = (jsTokens as any).matchToToken(match);\n\n      yield {\n        type: getTokenType(token, match.index, text),\n        value: token.value,\n      };\n    }\n  };\n}\n\nexport function highlight(text: string) {\n  if (text === \"\") return \"\";\n\n  const defs = getDefs(true);\n\n  let highlighted = \"\";\n\n  for (const { type, value } of tokenize(text)) {\n    if (type in defs) {\n      highlighted += value\n        .split(NEWLINE)\n        .map(str => defs[type as InternalTokenType](str))\n        .join(\"\\n\");\n    } else {\n      highlighted += value;\n    }\n  }\n\n  return highlighted;\n}\n", "import { getDefs, isColorSupported } from \"./defs.ts\";\nimport { highlight } from \"./highlight.ts\";\n\nexport { highlight };\n\nlet deprecationWarningShown = false;\n\ntype Location = {\n  column: number;\n  line: number;\n};\n\ntype NodeLocation = {\n  end?: Location;\n  start: Location;\n};\n\nexport interface Options {\n  /** Syntax highlight the code as JavaScript for terminals. default: false */\n  highlightCode?: boolean;\n  /**  The number of lines to show above the error. default: 2 */\n  linesAbove?: number;\n  /**  The number of lines to show below the error. default: 3 */\n  linesBelow?: number;\n  /**\n   * Forcibly syntax highlight the code as JavaScript (for non-terminals);\n   * overrides highlightCode.\n   * default: false\n   */\n  forceColor?: boolean;\n  /**\n   * Pass in a string to be displayed inline (if possible) next to the\n   * highlighted location in the code. If it can't be positioned inline,\n   * it will be placed above the code frame.\n   * default: nothing\n   */\n  message?: string;\n}\n\n/**\n * RegExp to test for newlines in terminal.\n */\n\nconst NEWLINE = /\\r\\n|[\\n\\r\\u2028\\u2029]/;\n\n/**\n * Extract what lines should be marked and highlighted.\n */\n\ntype MarkerLines = Record<number, true | [number, number]>;\n\nfunction getMarkerLines(\n  loc: NodeLocation,\n  source: Array<string>,\n  opts: Options,\n): {\n  start: number;\n  end: number;\n  markerLines: MarkerLines;\n} {\n  const startLoc: Location = {\n    column: 0,\n    line: -1,\n    ...loc.start,\n  };\n  const endLoc: Location = {\n    ...startLoc,\n    ...loc.end,\n  };\n  const { linesAbove = 2, linesBelow = 3 } = opts || {};\n  const startLine = startLoc.line;\n  const startColumn = startLoc.column;\n  const endLine = endLoc.line;\n  const endColumn = endLoc.column;\n\n  let start = Math.max(startLine - (linesAbove + 1), 0);\n  let end = Math.min(source.length, endLine + linesBelow);\n\n  if (startLine === -1) {\n    start = 0;\n  }\n\n  if (endLine === -1) {\n    end = source.length;\n  }\n\n  const lineDiff = endLine - startLine;\n  const markerLines: MarkerLines = {};\n\n  if (lineDiff) {\n    for (let i = 0; i <= lineDiff; i++) {\n      const lineNumber = i + startLine;\n\n      if (!startColumn) {\n        markerLines[lineNumber] = true;\n      } else if (i === 0) {\n        const sourceLength = source[lineNumber - 1].length;\n\n        markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];\n      } else if (i === lineDiff) {\n        markerLines[lineNumber] = [0, endColumn];\n      } else {\n        const sourceLength = source[lineNumber - i].length;\n\n        markerLines[lineNumber] = [0, sourceLength];\n      }\n    }\n  } else {\n    if (startColumn === endColumn) {\n      if (startColumn) {\n        markerLines[startLine] = [startColumn, 0];\n      } else {\n        markerLines[startLine] = true;\n      }\n    } else {\n      markerLines[startLine] = [startColumn, endColumn - startColumn];\n    }\n  }\n\n  return { start, end, markerLines };\n}\n\nexport function codeFrameColumns(\n  rawLines: string,\n  loc: NodeLocation,\n  opts: Options = {},\n): string {\n  const shouldHighlight =\n    opts.forceColor || (isColorSupported() && opts.highlightCode);\n  const defs = getDefs(shouldHighlight);\n\n  const lines = rawLines.split(NEWLINE);\n  const { start, end, markerLines } = getMarkerLines(loc, lines, opts);\n  const hasColumns = loc.start && typeof loc.start.column === \"number\";\n\n  const numberMaxWidth = String(end).length;\n\n  const highlightedLines = shouldHighlight ? highlight(rawLines) : rawLines;\n\n  let frame = highlightedLines\n    .split(NEWLINE, end)\n    .slice(start, end)\n    .map((line, index) => {\n      const number = start + 1 + index;\n      const paddedNumber = ` ${number}`.slice(-numberMaxWidth);\n      const gutter = ` ${paddedNumber} |`;\n      const hasMarker = markerLines[number];\n      const lastMarkerLine = !markerLines[number + 1];\n      if (hasMarker) {\n        let markerLine = \"\";\n        if (Array.isArray(hasMarker)) {\n          const markerSpacing = line\n            .slice(0, Math.max(hasMarker[0] - 1, 0))\n            .replace(/[^\\t]/g, \" \");\n          const numberOfMarkers = hasMarker[1] || 1;\n\n          markerLine = [\n            \"\\n \",\n            defs.gutter(gutter.replace(/\\d/g, \" \")),\n            \" \",\n            markerSpacing,\n            defs.marker(\"^\").repeat(numberOfMarkers),\n          ].join(\"\");\n\n          if (lastMarkerLine && opts.message) {\n            markerLine += \" \" + defs.message(opts.message);\n          }\n        }\n        return [\n          defs.marker(\">\"),\n          defs.gutter(gutter),\n          line.length > 0 ? ` ${line}` : \"\",\n          markerLine,\n        ].join(\"\");\n      } else {\n        return ` ${defs.gutter(gutter)}${line.length > 0 ? ` ${line}` : \"\"}`;\n      }\n    })\n    .join(\"\\n\");\n\n  if (opts.message && !hasColumns) {\n    frame = `${\" \".repeat(numberMaxWidth + 1)}${opts.message}\\n${frame}`;\n  }\n\n  if (shouldHighlight) {\n    return defs.reset(frame);\n  } else {\n    return frame;\n  }\n}\n\n/**\n * Create a code frame, adding line numbers, code highlighting, and pointing to a given position.\n */\n\nexport default function (\n  rawLines: string,\n  lineNumber: number,\n  colNumber?: number | null,\n  opts: Options = {},\n): string {\n  if (!deprecationWarningShown) {\n    deprecationWarningShown = true;\n\n    const message =\n      \"Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.\";\n\n    if (process.emitWarning) {\n      // A string is directly supplied to emitWarning, because when supplying an\n      // Error object node throws in the tests because of different contexts\n      process.emitWarning(message, \"DeprecationWarning\");\n    } else {\n      const deprecationError = new Error(message);\n      deprecationError.name = \"DeprecationWarning\";\n      console.warn(new Error(message));\n    }\n  }\n\n  colNumber = Math.max(colNumber, 0);\n\n  const location: NodeLocation = {\n    start: { column: colNumber, line: lineNumber },\n  };\n\n  return codeFrameColumns(rawLines, location, opts);\n}\n", "'use strict';\nconst errorEx = require('error-ex');\nconst fallback = require('json-parse-even-better-errors');\nconst {default: LinesAndColumns} = require('lines-and-columns');\nconst {codeFrameColumns} = require('@babel/code-frame');\n\nconst JSONError = errorEx('JSONError', {\n\tfileName: errorEx.append('in %s'),\n\tcodeFrame: errorEx.append('\\n\\n%s\\n')\n});\n\nconst parseJson = (string, reviver, filename) => {\n\tif (typeof reviver === 'string') {\n\t\tfilename = reviver;\n\t\treviver = null;\n\t}\n\n\ttry {\n\t\ttry {\n\t\t\treturn JSON.parse(string, reviver);\n\t\t} catch (error) {\n\t\t\tfallback(string, reviver);\n\t\t\tthrow error;\n\t\t}\n\t} catch (error) {\n\t\terror.message = error.message.replace(/\\n/g, '');\n\t\tconst indexMatch = error.message.match(/in JSON at position (\\d+) while parsing/);\n\n\t\tconst jsonError = new JSONError(error);\n\t\tif (filename) {\n\t\t\tjsonError.fileName = filename;\n\t\t}\n\n\t\tif (indexMatch && indexMatch.length > 0) {\n\t\t\tconst lines = new LinesAndColumns(string);\n\t\t\tconst index = Number(indexMatch[1]);\n\t\t\tconst location = lines.locationForIndex(index);\n\n\t\t\tconst codeFrame = codeFrameColumns(\n\t\t\t\tstring,\n\t\t\t\t{start: {line: location.line + 1, column: location.column + 1}},\n\t\t\t\t{highlightCode: true}\n\t\t\t);\n\n\t\t\tjsonError.codeFrame = codeFrame;\n\t\t}\n\n\t\tthrow jsonError;\n\t}\n};\n\nparseJson.JSONError = JSONError;\n\nmodule.exports = parseJson;\n", "function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toArray(arr) {\n  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = o[Symbol.iterator]();\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nvar Char = {\n  ANCHOR: '&',\n  COMMENT: '#',\n  TAG: '!',\n  DIRECTIVES_END: '-',\n  DOCUMENT_END: '.'\n};\nvar Type = {\n  ALIAS: 'ALIAS',\n  BLANK_LINE: 'BLANK_LINE',\n  BLOCK_FOLDED: 'BLOCK_FOLDED',\n  BLOCK_LITERAL: 'BLOCK_LITERAL',\n  COMMENT: 'COMMENT',\n  DIRECTIVE: 'DIRECTIVE',\n  DOCUMENT: 'DOCUMENT',\n  FLOW_MAP: 'FLOW_MAP',\n  FLOW_SEQ: 'FLOW_SEQ',\n  MAP: 'MAP',\n  MAP_KEY: 'MAP_KEY',\n  MAP_VALUE: 'MAP_VALUE',\n  PLAIN: 'PLAIN',\n  QUOTE_DOUBLE: 'QUOTE_DOUBLE',\n  QUOTE_SINGLE: 'QUOTE_SINGLE',\n  SEQ: 'SEQ',\n  SEQ_ITEM: 'SEQ_ITEM'\n};\nvar defaultTagPrefix = 'tag:yaml.org,2002:';\nvar defaultTags = {\n  MAP: 'tag:yaml.org,2002:map',\n  SEQ: 'tag:yaml.org,2002:seq',\n  STR: 'tag:yaml.org,2002:str'\n};\n\nfunction findLineStarts(src) {\n  var ls = [0];\n  var offset = src.indexOf('\\n');\n\n  while (offset !== -1) {\n    offset += 1;\n    ls.push(offset);\n    offset = src.indexOf('\\n', offset);\n  }\n\n  return ls;\n}\n\nfunction getSrcInfo(cst) {\n  var lineStarts, src;\n\n  if (typeof cst === 'string') {\n    lineStarts = findLineStarts(cst);\n    src = cst;\n  } else {\n    if (Array.isArray(cst)) cst = cst[0];\n\n    if (cst && cst.context) {\n      if (!cst.lineStarts) cst.lineStarts = findLineStarts(cst.context.src);\n      lineStarts = cst.lineStarts;\n      src = cst.context.src;\n    }\n  }\n\n  return {\n    lineStarts: lineStarts,\n    src: src\n  };\n}\n/**\n * @typedef {Object} LinePos - One-indexed position in the source\n * @property {number} line\n * @property {number} col\n */\n\n/**\n * Determine the line/col position matching a character offset.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns a one-indexed `{ line, col }` location if found, or\n * `undefined` otherwise.\n *\n * @param {number} offset\n * @param {string|Document|Document[]} cst\n * @returns {?LinePos}\n */\n\n\nfunction getLinePos(offset, cst) {\n  if (typeof offset !== 'number' || offset < 0) return null;\n\n  var _getSrcInfo = getSrcInfo(cst),\n      lineStarts = _getSrcInfo.lineStarts,\n      src = _getSrcInfo.src;\n\n  if (!lineStarts || !src || offset > src.length) return null;\n\n  for (var i = 0; i < lineStarts.length; ++i) {\n    var start = lineStarts[i];\n\n    if (offset < start) {\n      return {\n        line: i,\n        col: offset - lineStarts[i - 1] + 1\n      };\n    }\n\n    if (offset === start) return {\n      line: i + 1,\n      col: 1\n    };\n  }\n\n  var line = lineStarts.length;\n  return {\n    line: line,\n    col: offset - lineStarts[line - 1] + 1\n  };\n}\n/**\n * Get a specified line from the source.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns the line as a string if found, or `null` otherwise.\n *\n * @param {number} line One-indexed line number\n * @param {string|Document|Document[]} cst\n * @returns {?string}\n */\n\nfunction getLine(line, cst) {\n  var _getSrcInfo2 = getSrcInfo(cst),\n      lineStarts = _getSrcInfo2.lineStarts,\n      src = _getSrcInfo2.src;\n\n  if (!lineStarts || !(line >= 1) || line > lineStarts.length) return null;\n  var start = lineStarts[line - 1];\n  var end = lineStarts[line]; // undefined for last line; that's ok for slice()\n\n  while (end && end > start && src[end - 1] === '\\n') {\n    --end;\n  }\n\n  return src.slice(start, end);\n}\n/**\n * Pretty-print the starting line from the source indicated by the range `pos`\n *\n * Trims output to `maxWidth` chars while keeping the starting column visible,\n * using `` at either end to indicate dropped characters.\n *\n * Returns a two-line string (or `null`) with `\\n` as separator; the second line\n * will hold appropriately indented `^` marks indicating the column range.\n *\n * @param {Object} pos\n * @param {LinePos} pos.start\n * @param {LinePos} [pos.end]\n * @param {string|Document|Document[]*} cst\n * @param {number} [maxWidth=80]\n * @returns {?string}\n */\n\nfunction getPrettyContext(_ref, cst) {\n  var start = _ref.start,\n      end = _ref.end;\n  var maxWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 80;\n  var src = getLine(start.line, cst);\n  if (!src) return null;\n  var col = start.col;\n\n  if (src.length > maxWidth) {\n    if (col <= maxWidth - 10) {\n      src = src.substr(0, maxWidth - 1) + '';\n    } else {\n      var halfWidth = Math.round(maxWidth / 2);\n      if (src.length > col + halfWidth) src = src.substr(0, col + halfWidth - 1) + '';\n      col -= src.length - maxWidth;\n      src = '' + src.substr(1 - maxWidth);\n    }\n  }\n\n  var errLen = 1;\n  var errEnd = '';\n\n  if (end) {\n    if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {\n      errLen = end.col - start.col;\n    } else {\n      errLen = Math.min(src.length + 1, maxWidth) - col;\n      errEnd = '';\n    }\n  }\n\n  var offset = col > 1 ? ' '.repeat(col - 1) : '';\n  var err = '^'.repeat(errLen);\n  return \"\".concat(src, \"\\n\").concat(offset).concat(err).concat(errEnd);\n}\n\nvar Range = /*#__PURE__*/function () {\n  function Range(start, end) {\n    _classCallCheck(this, Range);\n\n    this.start = start;\n    this.end = end || start;\n  }\n\n  _createClass(Range, [{\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return typeof this.start !== 'number' || !this.end || this.end <= this.start;\n    }\n    /**\n     * Set `origStart` and `origEnd` to point to the original source range for\n     * this node, which may differ due to dropped CR characters.\n     *\n     * @param {number[]} cr - Positions of dropped CR characters\n     * @param {number} offset - Starting index of `cr` from the last call\n     * @returns {number} - The next offset, matching the one found for `origStart`\n     */\n\n  }, {\n    key: \"setOrigRange\",\n    value: function setOrigRange(cr, offset) {\n      var start = this.start,\n          end = this.end;\n\n      if (cr.length === 0 || end <= cr[0]) {\n        this.origStart = start;\n        this.origEnd = end;\n        return offset;\n      }\n\n      var i = offset;\n\n      while (i < cr.length) {\n        if (cr[i] > start) break;else ++i;\n      }\n\n      this.origStart = start + i;\n      var nextOffset = i;\n\n      while (i < cr.length) {\n        // if end was at \\n, it should now be at \\r\n        if (cr[i] >= end) break;else ++i;\n      }\n\n      this.origEnd = end + i;\n      return nextOffset;\n    }\n  }], [{\n    key: \"copy\",\n    value: function copy(orig) {\n      return new Range(orig.start, orig.end);\n    }\n  }]);\n\n  return Range;\n}();\n\n/** Root class of all nodes */\n\nvar Node = /*#__PURE__*/function () {\n  function Node(type, props, context) {\n    _classCallCheck(this, Node);\n\n    Object.defineProperty(this, 'context', {\n      value: context || null,\n      writable: true\n    });\n    this.error = null;\n    this.range = null;\n    this.valueRange = null;\n    this.props = props || [];\n    this.type = type;\n    this.value = null;\n  }\n\n  _createClass(Node, [{\n    key: \"getPropValue\",\n    value: function getPropValue(idx, key, skipKey) {\n      if (!this.context) return null;\n      var src = this.context.src;\n      var prop = this.props[idx];\n      return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;\n    }\n  }, {\n    key: \"anchor\",\n    get: function get() {\n      for (var i = 0; i < this.props.length; ++i) {\n        var anchor = this.getPropValue(i, Char.ANCHOR, true);\n        if (anchor != null) return anchor;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"comment\",\n    get: function get() {\n      var comments = [];\n\n      for (var i = 0; i < this.props.length; ++i) {\n        var comment = this.getPropValue(i, Char.COMMENT, true);\n        if (comment != null) comments.push(comment);\n      }\n\n      return comments.length > 0 ? comments.join('\\n') : null;\n    }\n  }, {\n    key: \"commentHasRequiredWhitespace\",\n    value: function commentHasRequiredWhitespace(start) {\n      var src = this.context.src;\n      if (this.header && start === this.header.end) return false;\n      if (!this.valueRange) return false;\n      var end = this.valueRange.end;\n      return start !== end || Node.atBlank(src, end - 1);\n    }\n  }, {\n    key: \"hasComment\",\n    get: function get() {\n      if (this.context) {\n        var src = this.context.src;\n\n        for (var i = 0; i < this.props.length; ++i) {\n          if (src[this.props[i].start] === Char.COMMENT) return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"hasProps\",\n    get: function get() {\n      if (this.context) {\n        var src = this.context.src;\n\n        for (var i = 0; i < this.props.length; ++i) {\n          if (src[this.props[i].start] !== Char.COMMENT) return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return false;\n    }\n  }, {\n    key: \"jsonLike\",\n    get: function get() {\n      var jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];\n      return jsonLikeTypes.indexOf(this.type) !== -1;\n    }\n  }, {\n    key: \"rangeAsLinePos\",\n    get: function get() {\n      if (!this.range || !this.context) return undefined;\n      var start = getLinePos(this.range.start, this.context.root);\n      if (!start) return undefined;\n      var end = getLinePos(this.range.end, this.context.root);\n      return {\n        start: start,\n        end: end\n      };\n    }\n  }, {\n    key: \"rawValue\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      return this.context.src.slice(start, end);\n    }\n  }, {\n    key: \"tag\",\n    get: function get() {\n      for (var i = 0; i < this.props.length; ++i) {\n        var tag = this.getPropValue(i, Char.TAG, false);\n\n        if (tag != null) {\n          if (tag[1] === '<') {\n            return {\n              verbatim: tag.slice(2, -1)\n            };\n          } else {\n            // eslint-disable-next-line no-unused-vars\n            var _tag$match = tag.match(/^(.*!)([^!]*)$/),\n                _tag$match2 = _slicedToArray(_tag$match, 3);\n                _tag$match2[0];\n                var handle = _tag$match2[1],\n                suffix = _tag$match2[2];\n\n            return {\n              handle: handle,\n              suffix: suffix\n            };\n          }\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"valueRangeContainsNewline\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return false;\n      var _this$valueRange2 = this.valueRange,\n          start = _this$valueRange2.start,\n          end = _this$valueRange2.end;\n      var src = this.context.src;\n\n      for (var i = start; i < end; ++i) {\n        if (src[i] === '\\n') return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"parseComment\",\n    value: function parseComment(start) {\n      var src = this.context.src;\n\n      if (src[start] === Char.COMMENT) {\n        var end = Node.endOfLine(src, start + 1);\n        var commentRange = new Range(start, end);\n        this.props.push(commentRange);\n        return end;\n      }\n\n      return start;\n    }\n    /**\n     * Populates the `origStart` and `origEnd` values of all ranges for this\n     * node. Extended by child classes to handle descendant nodes.\n     *\n     * @param {number[]} cr - Positions of dropped CR characters\n     * @param {number} offset - Starting index of `cr` from the last call\n     * @returns {number} - The next offset, matching the one found for `origStart`\n     */\n\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      if (this.range) offset = this.range.setOrigRange(cr, offset);\n      if (this.valueRange) this.valueRange.setOrigRange(cr, offset);\n      this.props.forEach(function (prop) {\n        return prop.setOrigRange(cr, offset);\n      });\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var str = src.slice(range.start, range.end);\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }], [{\n    key: \"addStringTerminator\",\n    value: function addStringTerminator(src, offset, str) {\n      if (str[str.length - 1] === '\\n') return str;\n      var next = Node.endOfWhiteSpace(src, offset);\n      return next >= src.length || src[next] === '\\n' ? str + '\\n' : str;\n    } // ^(---|...)\n\n  }, {\n    key: \"atDocumentBoundary\",\n    value: function atDocumentBoundary(src, offset, sep) {\n      var ch0 = src[offset];\n      if (!ch0) return true;\n      var prev = src[offset - 1];\n      if (prev && prev !== '\\n') return false;\n\n      if (sep) {\n        if (ch0 !== sep) return false;\n      } else {\n        if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END) return false;\n      }\n\n      var ch1 = src[offset + 1];\n      var ch2 = src[offset + 2];\n      if (ch1 !== ch0 || ch2 !== ch0) return false;\n      var ch3 = src[offset + 3];\n      return !ch3 || ch3 === '\\n' || ch3 === '\\t' || ch3 === ' ';\n    }\n  }, {\n    key: \"endOfIdentifier\",\n    value: function endOfIdentifier(src, offset) {\n      var ch = src[offset];\n      var isVerbatim = ch === '<';\n      var notOk = isVerbatim ? ['\\n', '\\t', ' ', '>'] : ['\\n', '\\t', ' ', '[', ']', '{', '}', ','];\n\n      while (ch && notOk.indexOf(ch) === -1) {\n        ch = src[offset += 1];\n      }\n\n      if (isVerbatim && ch === '>') offset += 1;\n      return offset;\n    }\n  }, {\n    key: \"endOfIndent\",\n    value: function endOfIndent(src, offset) {\n      var ch = src[offset];\n\n      while (ch === ' ') {\n        ch = src[offset += 1];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"endOfLine\",\n    value: function endOfLine(src, offset) {\n      var ch = src[offset];\n\n      while (ch && ch !== '\\n') {\n        ch = src[offset += 1];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"endOfWhiteSpace\",\n    value: function endOfWhiteSpace(src, offset) {\n      var ch = src[offset];\n\n      while (ch === '\\t' || ch === ' ') {\n        ch = src[offset += 1];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"startOfLine\",\n    value: function startOfLine(src, offset) {\n      var ch = src[offset - 1];\n      if (ch === '\\n') return offset;\n\n      while (ch && ch !== '\\n') {\n        ch = src[offset -= 1];\n      }\n\n      return offset + 1;\n    }\n    /**\n     * End of indentation, or null if the line's indent level is not more\n     * than `indent`\n     *\n     * @param {string} src\n     * @param {number} indent\n     * @param {number} lineStart\n     * @returns {?number}\n     */\n\n  }, {\n    key: \"endOfBlockIndent\",\n    value: function endOfBlockIndent(src, indent, lineStart) {\n      var inEnd = Node.endOfIndent(src, lineStart);\n\n      if (inEnd > lineStart + indent) {\n        return inEnd;\n      } else {\n        var wsEnd = Node.endOfWhiteSpace(src, inEnd);\n        var ch = src[wsEnd];\n        if (!ch || ch === '\\n') return wsEnd;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"atBlank\",\n    value: function atBlank(src, offset, endAsBlank) {\n      var ch = src[offset];\n      return ch === '\\n' || ch === '\\t' || ch === ' ' || endAsBlank && !ch;\n    }\n  }, {\n    key: \"nextNodeIsIndented\",\n    value: function nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {\n      if (!ch || indentDiff < 0) return false;\n      if (indentDiff > 0) return true;\n      return indicatorAsIndent && ch === '-';\n    } // should be at line or string end, or at next non-whitespace char\n\n  }, {\n    key: \"normalizeOffset\",\n    value: function normalizeOffset(src, offset) {\n      var ch = src[offset];\n      return !ch ? offset : ch !== '\\n' && src[offset - 1] === '\\n' ? offset - 1 : Node.endOfWhiteSpace(src, offset);\n    } // fold single newline into space, multiple newlines to N - 1 newlines\n    // presumes src[offset] === '\\n'\n\n  }, {\n    key: \"foldNewline\",\n    value: function foldNewline(src, offset, indent) {\n      var inCount = 0;\n      var error = false;\n      var fold = '';\n      var ch = src[offset + 1];\n\n      while (ch === ' ' || ch === '\\t' || ch === '\\n') {\n        switch (ch) {\n          case '\\n':\n            inCount = 0;\n            offset += 1;\n            fold += '\\n';\n            break;\n\n          case '\\t':\n            if (inCount <= indent) error = true;\n            offset = Node.endOfWhiteSpace(src, offset + 2) - 1;\n            break;\n\n          case ' ':\n            inCount += 1;\n            offset += 1;\n            break;\n        }\n\n        ch = src[offset + 1];\n      }\n\n      if (!fold) fold = ' ';\n      if (ch && inCount <= indent) error = true;\n      return {\n        fold: fold,\n        offset: offset,\n        error: error\n      };\n    }\n  }]);\n\n  return Node;\n}();\n\nvar YAMLError = /*#__PURE__*/function (_Error) {\n  _inherits(YAMLError, _Error);\n\n  var _super = _createSuper(YAMLError);\n\n  function YAMLError(name, source, message) {\n    var _this;\n\n    _classCallCheck(this, YAMLError);\n\n    if (!message || !(source instanceof Node)) throw new Error(\"Invalid arguments for new \".concat(name));\n    _this = _super.call(this);\n    _this.name = name;\n    _this.message = message;\n    _this.source = source;\n    return _this;\n  }\n\n  _createClass(YAMLError, [{\n    key: \"makePretty\",\n    value: function makePretty() {\n      if (!this.source) return;\n      this.nodeType = this.source.type;\n      var cst = this.source.context && this.source.context.root;\n\n      if (typeof this.offset === 'number') {\n        this.range = new Range(this.offset, this.offset + 1);\n        var start = cst && getLinePos(this.offset, cst);\n\n        if (start) {\n          var end = {\n            line: start.line,\n            col: start.col + 1\n          };\n          this.linePos = {\n            start: start,\n            end: end\n          };\n        }\n\n        delete this.offset;\n      } else {\n        this.range = this.source.range;\n        this.linePos = this.source.rangeAsLinePos;\n      }\n\n      if (this.linePos) {\n        var _this$linePos$start = this.linePos.start,\n            line = _this$linePos$start.line,\n            col = _this$linePos$start.col;\n        this.message += \" at line \".concat(line, \", column \").concat(col);\n        var ctx = cst && getPrettyContext(this.linePos, cst);\n        if (ctx) this.message += \":\\n\\n\".concat(ctx, \"\\n\");\n      }\n\n      delete this.source;\n    }\n  }]);\n\n  return YAMLError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nvar YAMLReferenceError = /*#__PURE__*/function (_YAMLError) {\n  _inherits(YAMLReferenceError, _YAMLError);\n\n  var _super2 = _createSuper(YAMLReferenceError);\n\n  function YAMLReferenceError(source, message) {\n    _classCallCheck(this, YAMLReferenceError);\n\n    return _super2.call(this, 'YAMLReferenceError', source, message);\n  }\n\n  return YAMLReferenceError;\n}(YAMLError);\nvar YAMLSemanticError = /*#__PURE__*/function (_YAMLError2) {\n  _inherits(YAMLSemanticError, _YAMLError2);\n\n  var _super3 = _createSuper(YAMLSemanticError);\n\n  function YAMLSemanticError(source, message) {\n    _classCallCheck(this, YAMLSemanticError);\n\n    return _super3.call(this, 'YAMLSemanticError', source, message);\n  }\n\n  return YAMLSemanticError;\n}(YAMLError);\nvar YAMLSyntaxError = /*#__PURE__*/function (_YAMLError3) {\n  _inherits(YAMLSyntaxError, _YAMLError3);\n\n  var _super4 = _createSuper(YAMLSyntaxError);\n\n  function YAMLSyntaxError(source, message) {\n    _classCallCheck(this, YAMLSyntaxError);\n\n    return _super4.call(this, 'YAMLSyntaxError', source, message);\n  }\n\n  return YAMLSyntaxError;\n}(YAMLError);\nvar YAMLWarning = /*#__PURE__*/function (_YAMLError4) {\n  _inherits(YAMLWarning, _YAMLError4);\n\n  var _super5 = _createSuper(YAMLWarning);\n\n  function YAMLWarning(source, message) {\n    _classCallCheck(this, YAMLWarning);\n\n    return _super5.call(this, 'YAMLWarning', source, message);\n  }\n\n  return YAMLWarning;\n}(YAMLError);\n\nvar PlainValue = /*#__PURE__*/function (_Node) {\n  _inherits(PlainValue, _Node);\n\n  var _super = _createSuper(PlainValue);\n\n  function PlainValue() {\n    _classCallCheck(this, PlainValue);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(PlainValue, [{\n    key: \"strValue\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var src = this.context.src;\n      var ch = src[end - 1];\n\n      while (start < end && (ch === '\\n' || ch === '\\t' || ch === ' ')) {\n        ch = src[--end - 1];\n      }\n\n      var str = '';\n\n      for (var i = start; i < end; ++i) {\n        var _ch = src[i];\n\n        if (_ch === '\\n') {\n          var _Node$foldNewline = Node.foldNewline(src, i, -1),\n              fold = _Node$foldNewline.fold,\n              offset = _Node$foldNewline.offset;\n\n          str += fold;\n          i = offset;\n        } else if (_ch === ' ' || _ch === '\\t') {\n          // trim trailing whitespace\n          var wsStart = i;\n          var next = src[i + 1];\n\n          while (i < end && (next === ' ' || next === '\\t')) {\n            i += 1;\n            next = src[i + 1];\n          }\n\n          if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : _ch;\n        } else {\n          str += _ch;\n        }\n      }\n\n      var ch0 = src[start];\n\n      switch (ch0) {\n        case '\\t':\n          {\n            var msg = 'Plain value cannot start with a tab character';\n            var errors = [new YAMLSemanticError(this, msg)];\n            return {\n              errors: errors,\n              str: str\n            };\n          }\n\n        case '@':\n        case '`':\n          {\n            var _msg = \"Plain value cannot start with reserved character \".concat(ch0);\n\n            var _errors = [new YAMLSemanticError(this, _msg)];\n            return {\n              errors: _errors,\n              str: str\n            };\n          }\n\n        default:\n          return str;\n      }\n    }\n  }, {\n    key: \"parseBlockValue\",\n    value: function parseBlockValue(start) {\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          inFlow = _this$context.inFlow,\n          src = _this$context.src;\n      var offset = start;\n      var valueEnd = start;\n\n      for (var ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n        if (Node.atDocumentBoundary(src, offset + 1)) break;\n        var end = Node.endOfBlockIndent(src, indent, offset + 1);\n        if (end === null || src[end] === '#') break;\n\n        if (src[end] === '\\n') {\n          offset = end;\n        } else {\n          valueEnd = PlainValue.endOfLine(src, end, inFlow);\n          offset = valueEnd;\n        }\n      }\n\n      if (this.valueRange.isEmpty()) this.valueRange.start = start;\n      this.valueRange.end = valueEnd;\n      return valueEnd;\n    }\n    /**\n     * Parses a plain value from the source\n     *\n     * Accepted forms are:\n     * ```\n     * #comment\n     *\n     * first line\n     *\n     * first line #comment\n     *\n     * first line\n     * block\n     * lines\n     *\n     * #comment\n     * block\n     * lines\n     * ```\n     * where block lines are empty or have an indent level greater than `indent`.\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar, may be `\\n`\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var inFlow = context.inFlow,\n          src = context.src;\n      var offset = start;\n      var ch = src[offset];\n\n      if (ch && ch !== '#' && ch !== '\\n') {\n        offset = PlainValue.endOfLine(src, start, inFlow);\n      }\n\n      this.valueRange = new Range(start, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n\n      if (!this.hasComment || this.valueRange.isEmpty()) {\n        offset = this.parseBlockValue(offset);\n      }\n\n      return offset;\n    }\n  }], [{\n    key: \"endOfLine\",\n    value: function endOfLine(src, start, inFlow) {\n      var ch = src[start];\n      var offset = start;\n\n      while (ch && ch !== '\\n') {\n        if (inFlow && (ch === '[' || ch === ']' || ch === '{' || ch === '}' || ch === ',')) break;\n        var next = src[offset + 1];\n        if (ch === ':' && (!next || next === '\\n' || next === '\\t' || next === ' ' || inFlow && next === ',')) break;\n        if ((ch === ' ' || ch === '\\t') && next === '#') break;\n        offset += 1;\n        ch = next;\n      }\n\n      return offset;\n    }\n  }]);\n\n  return PlainValue;\n}(Node);\n\nexport { Char as C, Node as N, PlainValue as P, Range as R, Type as T, YAMLSyntaxError as Y, _createForOfIteratorHelper as _, _typeof as a, _createClass as b, _classCallCheck as c, defaultTagPrefix as d, _defineProperty as e, YAMLWarning as f, YAMLSemanticError as g, _slicedToArray as h, YAMLError as i, _inherits as j, _createSuper as k, _get as l, _getPrototypeOf as m, defaultTags as n, YAMLReferenceError as o, _assertThisInitialized as p, _toArray as q, _possibleConstructorReturn as r };\n", "import { j as _inherits, k as _createSuper, c as _classCallCheck, T as Type, b as _createClass, R as Range, N as Node, g as YAMLSemanticError, l as _get, m as _getPrototypeOf, Y as YAMLSyntaxError, C as Char, e as _defineProperty, P as PlainValue } from './PlainValue-b8036b75.js';\n\nvar BlankLine = /*#__PURE__*/function (_Node) {\n  _inherits(BlankLine, _Node);\n\n  var _super = _createSuper(BlankLine);\n\n  function BlankLine() {\n    _classCallCheck(this, BlankLine);\n\n    return _super.call(this, Type.BLANK_LINE);\n  }\n  /* istanbul ignore next */\n\n\n  _createClass(BlankLine, [{\n    key: \"includesTrailingLines\",\n    get: function get() {\n      // This is never called from anywhere, but if it were,\n      // this is the value it should return.\n      return true;\n    }\n    /**\n     * Parses a blank line from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first \\n character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      this.range = new Range(start, start + 1);\n      return start + 1;\n    }\n  }]);\n\n  return BlankLine;\n}(Node);\n\nvar CollectionItem = /*#__PURE__*/function (_Node) {\n  _inherits(CollectionItem, _Node);\n\n  var _super = _createSuper(CollectionItem);\n\n  function CollectionItem(type, props) {\n    var _this;\n\n    _classCallCheck(this, CollectionItem);\n\n    _this = _super.call(this, type, props);\n    _this.node = null;\n    return _this;\n  }\n\n  _createClass(CollectionItem, [{\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return !!this.node && this.node.includesTrailingLines;\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var parseNode = context.parseNode,\n          src = context.src;\n      var atLineStart = context.atLineStart,\n          lineStart = context.lineStart;\n      if (!atLineStart && this.type === Type.SEQ_ITEM) this.error = new YAMLSemanticError(this, 'Sequence items must not have preceding content on the same line');\n      var indent = atLineStart ? start - lineStart : context.indent;\n      var offset = Node.endOfWhiteSpace(src, start + 1);\n      var ch = src[offset];\n      var inlineComment = ch === '#';\n      var comments = [];\n      var blankLine = null;\n\n      while (ch === '\\n' || ch === '#') {\n        if (ch === '#') {\n          var _end = Node.endOfLine(src, offset + 1);\n\n          comments.push(new Range(offset, _end));\n          offset = _end;\n        } else {\n          atLineStart = true;\n          lineStart = offset + 1;\n          var wsEnd = Node.endOfWhiteSpace(src, lineStart);\n\n          if (src[wsEnd] === '\\n' && comments.length === 0) {\n            blankLine = new BlankLine();\n            lineStart = blankLine.parse({\n              src: src\n            }, lineStart);\n          }\n\n          offset = Node.endOfIndent(src, lineStart);\n        }\n\n        ch = src[offset];\n      }\n\n      if (Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== Type.SEQ_ITEM)) {\n        this.node = parseNode({\n          atLineStart: atLineStart,\n          inCollection: false,\n          indent: indent,\n          lineStart: lineStart,\n          parent: this\n        }, offset);\n      } else if (ch && lineStart > start + 1) {\n        offset = lineStart - 1;\n      }\n\n      if (this.node) {\n        if (blankLine) {\n          // Only blank lines preceding non-empty nodes are captured. Note that\n          // this means that collection item range start indices do not always\n          // increase monotonically. -- eemeli/yaml#126\n          var items = context.parent.items || context.parent.contents;\n          if (items) items.push(blankLine);\n        }\n\n        if (comments.length) Array.prototype.push.apply(this.props, comments);\n        offset = this.node.range.end;\n      } else {\n        if (inlineComment) {\n          var c = comments[0];\n          this.props.push(c);\n          offset = c.end;\n        } else {\n          offset = Node.endOfLine(src, start + 1);\n        }\n      }\n\n      var end = this.node ? this.node.valueRange.end : offset;\n      this.valueRange = new Range(start, end);\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(CollectionItem.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      return this.node ? this.node.setOrigRanges(cr, offset) : offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          node = this.node,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }]);\n\n  return CollectionItem;\n}(Node);\n\nvar Comment = /*#__PURE__*/function (_Node) {\n  _inherits(Comment, _Node);\n\n  var _super = _createSuper(Comment);\n\n  function Comment() {\n    _classCallCheck(this, Comment);\n\n    return _super.call(this, Type.COMMENT);\n  }\n  /**\n   * Parses a comment line from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  _createClass(Comment, [{\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var offset = this.parseComment(start);\n      this.range = new Range(start, offset);\n      return offset;\n    }\n  }]);\n\n  return Comment;\n}(Node);\n\nfunction grabCollectionEndComments(node) {\n  var cnode = node;\n\n  while (cnode instanceof CollectionItem) {\n    cnode = cnode.node;\n  }\n\n  if (!(cnode instanceof Collection)) return null;\n  var len = cnode.items.length;\n  var ci = -1;\n\n  for (var i = len - 1; i >= 0; --i) {\n    var n = cnode.items[i];\n\n    if (n.type === Type.COMMENT) {\n      // Keep sufficiently indented comments with preceding node\n      var _n$context = n.context,\n          indent = _n$context.indent,\n          lineStart = _n$context.lineStart;\n      if (indent > 0 && n.range.start >= lineStart + indent) break;\n      ci = i;\n    } else if (n.type === Type.BLANK_LINE) ci = i;else break;\n  }\n\n  if (ci === -1) return null;\n  var ca = cnode.items.splice(ci, len - ci);\n  var prevEnd = ca[0].range.start;\n\n  while (true) {\n    cnode.range.end = prevEnd;\n    if (cnode.valueRange && cnode.valueRange.end > prevEnd) cnode.valueRange.end = prevEnd;\n    if (cnode === node) break;\n    cnode = cnode.context.parent;\n  }\n\n  return ca;\n}\nvar Collection = /*#__PURE__*/function (_Node) {\n  _inherits(Collection, _Node);\n\n  var _super = _createSuper(Collection);\n\n  function Collection(firstItem) {\n    var _this;\n\n    _classCallCheck(this, Collection);\n\n    _this = _super.call(this, firstItem.type === Type.SEQ_ITEM ? Type.SEQ : Type.MAP);\n\n    for (var i = firstItem.props.length - 1; i >= 0; --i) {\n      if (firstItem.props[i].start < firstItem.context.lineStart) {\n        // props on previous line are assumed by the collection\n        _this.props = firstItem.props.slice(0, i + 1);\n        firstItem.props = firstItem.props.slice(i + 1);\n        var itemRange = firstItem.props[0] || firstItem.valueRange;\n        firstItem.range.start = itemRange.start;\n        break;\n      }\n    }\n\n    _this.items = [firstItem];\n    var ec = grabCollectionEndComments(firstItem);\n    if (ec) Array.prototype.push.apply(_this.items, ec);\n    return _this;\n  }\n\n  _createClass(Collection, [{\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return this.items.length > 0;\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var parseNode = context.parseNode,\n          src = context.src; // It's easier to recalculate lineStart here rather than tracking down the\n      // last context from which to read it -- eemeli/yaml#2\n\n      var lineStart = Node.startOfLine(src, start);\n      var firstItem = this.items[0]; // First-item context needs to be correct for later comment handling\n      // -- eemeli/yaml#17\n\n      firstItem.context.parent = this;\n      this.valueRange = Range.copy(firstItem.valueRange);\n      var indent = firstItem.range.start - firstItem.context.lineStart;\n      var offset = start;\n      offset = Node.normalizeOffset(src, offset);\n      var ch = src[offset];\n      var atLineStart = Node.endOfWhiteSpace(src, lineStart) === offset;\n      var prevIncludesTrailingLines = false;\n\n      while (ch) {\n        while (ch === '\\n' || ch === '#') {\n          if (atLineStart && ch === '\\n' && !prevIncludesTrailingLines) {\n            var blankLine = new BlankLine();\n            offset = blankLine.parse({\n              src: src\n            }, offset);\n            this.valueRange.end = offset;\n\n            if (offset >= src.length) {\n              ch = null;\n              break;\n            }\n\n            this.items.push(blankLine);\n            offset -= 1; // blankLine.parse() consumes terminal newline\n          } else if (ch === '#') {\n            if (offset < lineStart + indent && !Collection.nextContentHasIndent(src, offset, indent)) {\n              return offset;\n            }\n\n            var comment = new Comment();\n            offset = comment.parse({\n              indent: indent,\n              lineStart: lineStart,\n              src: src\n            }, offset);\n            this.items.push(comment);\n            this.valueRange.end = offset;\n\n            if (offset >= src.length) {\n              ch = null;\n              break;\n            }\n          }\n\n          lineStart = offset + 1;\n          offset = Node.endOfIndent(src, lineStart);\n\n          if (Node.atBlank(src, offset)) {\n            var wsEnd = Node.endOfWhiteSpace(src, offset);\n            var next = src[wsEnd];\n\n            if (!next || next === '\\n' || next === '#') {\n              offset = wsEnd;\n            }\n          }\n\n          ch = src[offset];\n          atLineStart = true;\n        }\n\n        if (!ch) {\n          break;\n        }\n\n        if (offset !== lineStart + indent && (atLineStart || ch !== ':')) {\n          if (offset < lineStart + indent) {\n            if (lineStart > start) offset = lineStart;\n            break;\n          } else if (!this.error) {\n            var msg = 'All collection items must start at the same column';\n            this.error = new YAMLSyntaxError(this, msg);\n          }\n        }\n\n        if (firstItem.type === Type.SEQ_ITEM) {\n          if (ch !== '-') {\n            if (lineStart > start) offset = lineStart;\n            break;\n          }\n        } else if (ch === '-' && !this.error) {\n          // map key may start with -, as long as it's followed by a non-whitespace char\n          var _next = src[offset + 1];\n\n          if (!_next || _next === '\\n' || _next === '\\t' || _next === ' ') {\n            var _msg = 'A collection cannot be both a mapping and a sequence';\n            this.error = new YAMLSyntaxError(this, _msg);\n          }\n        }\n\n        var node = parseNode({\n          atLineStart: atLineStart,\n          inCollection: true,\n          indent: indent,\n          lineStart: lineStart,\n          parent: this\n        }, offset);\n        if (!node) return offset; // at next document start\n\n        this.items.push(node);\n        this.valueRange.end = node.valueRange.end;\n        offset = Node.normalizeOffset(src, node.range.end);\n        ch = src[offset];\n        atLineStart = false;\n        prevIncludesTrailingLines = node.includesTrailingLines; // Need to reset lineStart and atLineStart here if preceding node's range\n        // has advanced to check the current line's indentation level\n        // -- eemeli/yaml#10 & eemeli/yaml#38\n\n        if (ch) {\n          var ls = offset - 1;\n          var prev = src[ls];\n\n          while (prev === ' ' || prev === '\\t') {\n            prev = src[--ls];\n          }\n\n          if (prev === '\\n') {\n            lineStart = ls + 1;\n            atLineStart = true;\n          }\n        }\n\n        var ec = grabCollectionEndComments(node);\n        if (ec) Array.prototype.push.apply(this.items, ec);\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(Collection.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      this.items.forEach(function (node) {\n        offset = node.setOrigRanges(cr, offset);\n      });\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          items = this.items,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var str = src.slice(range.start, items[0].range.start) + String(items[0]);\n\n      for (var i = 1; i < items.length; ++i) {\n        var item = items[i];\n        var _item$context = item.context,\n            atLineStart = _item$context.atLineStart,\n            indent = _item$context.indent;\n        if (atLineStart) for (var _i = 0; _i < indent; ++_i) {\n          str += ' ';\n        }\n        str += String(item);\n      }\n\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }], [{\n    key: \"nextContentHasIndent\",\n    value: function nextContentHasIndent(src, offset, indent) {\n      var lineStart = Node.endOfLine(src, offset) + 1;\n      offset = Node.endOfWhiteSpace(src, lineStart);\n      var ch = src[offset];\n      if (!ch) return false;\n      if (offset >= lineStart + indent) return true;\n      if (ch !== '#' && ch !== '\\n') return false;\n      return Collection.nextContentHasIndent(src, offset, indent);\n    }\n  }]);\n\n  return Collection;\n}(Node);\n\nvar Directive = /*#__PURE__*/function (_Node) {\n  _inherits(Directive, _Node);\n\n  var _super = _createSuper(Directive);\n\n  function Directive() {\n    var _this;\n\n    _classCallCheck(this, Directive);\n\n    _this = _super.call(this, Type.DIRECTIVE);\n    _this.name = null;\n    return _this;\n  }\n\n  _createClass(Directive, [{\n    key: \"parameters\",\n    get: function get() {\n      var raw = this.rawValue;\n      return raw ? raw.trim().split(/[ \\t]+/) : [];\n    }\n  }, {\n    key: \"parseName\",\n    value: function parseName(start) {\n      var src = this.context.src;\n      var offset = start;\n      var ch = src[offset];\n\n      while (ch && ch !== '\\n' && ch !== '\\t' && ch !== ' ') {\n        ch = src[offset += 1];\n      }\n\n      this.name = src.slice(start, offset);\n      return offset;\n    }\n  }, {\n    key: \"parseParameters\",\n    value: function parseParameters(start) {\n      var src = this.context.src;\n      var offset = start;\n      var ch = src[offset];\n\n      while (ch && ch !== '\\n' && ch !== '#') {\n        ch = src[offset += 1];\n      }\n\n      this.valueRange = new Range(start, offset);\n      return offset;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var offset = this.parseName(start + 1);\n      offset = this.parseParameters(offset);\n      offset = this.parseComment(offset);\n      this.range = new Range(start, offset);\n      return offset;\n    }\n  }]);\n\n  return Directive;\n}(Node);\n\nvar Document = /*#__PURE__*/function (_Node) {\n  _inherits(Document, _Node);\n\n  var _super = _createSuper(Document);\n\n  function Document() {\n    var _this;\n\n    _classCallCheck(this, Document);\n\n    _this = _super.call(this, Type.DOCUMENT);\n    _this.directives = null;\n    _this.contents = null;\n    _this.directivesEndMarker = null;\n    _this.documentEndMarker = null;\n    return _this;\n  }\n\n  _createClass(Document, [{\n    key: \"parseDirectives\",\n    value: function parseDirectives(start) {\n      var src = this.context.src;\n      this.directives = [];\n      var atLineStart = true;\n      var hasDirectives = false;\n      var offset = start;\n\n      while (!Node.atDocumentBoundary(src, offset, Char.DIRECTIVES_END)) {\n        offset = Document.startCommentOrEndBlankLine(src, offset);\n\n        switch (src[offset]) {\n          case '\\n':\n            if (atLineStart) {\n              var blankLine = new BlankLine();\n              offset = blankLine.parse({\n                src: src\n              }, offset);\n\n              if (offset < src.length) {\n                this.directives.push(blankLine);\n              }\n            } else {\n              offset += 1;\n              atLineStart = true;\n            }\n\n            break;\n\n          case '#':\n            {\n              var comment = new Comment();\n              offset = comment.parse({\n                src: src\n              }, offset);\n              this.directives.push(comment);\n              atLineStart = false;\n            }\n            break;\n\n          case '%':\n            {\n              var directive = new Directive();\n              offset = directive.parse({\n                parent: this,\n                src: src\n              }, offset);\n              this.directives.push(directive);\n              hasDirectives = true;\n              atLineStart = false;\n            }\n            break;\n\n          default:\n            if (hasDirectives) {\n              this.error = new YAMLSemanticError(this, 'Missing directives-end indicator line');\n            } else if (this.directives.length > 0) {\n              this.contents = this.directives;\n              this.directives = [];\n            }\n\n            return offset;\n        }\n      }\n\n      if (src[offset]) {\n        this.directivesEndMarker = new Range(offset, offset + 3);\n        return offset + 3;\n      }\n\n      if (hasDirectives) {\n        this.error = new YAMLSemanticError(this, 'Missing directives-end indicator line');\n      } else if (this.directives.length > 0) {\n        this.contents = this.directives;\n        this.directives = [];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"parseContents\",\n    value: function parseContents(start) {\n      var _this$context = this.context,\n          parseNode = _this$context.parseNode,\n          src = _this$context.src;\n      if (!this.contents) this.contents = [];\n      var lineStart = start;\n\n      while (src[lineStart - 1] === '-') {\n        lineStart -= 1;\n      }\n\n      var offset = Node.endOfWhiteSpace(src, start);\n      var atLineStart = lineStart === start;\n      this.valueRange = new Range(offset);\n\n      while (!Node.atDocumentBoundary(src, offset, Char.DOCUMENT_END)) {\n        switch (src[offset]) {\n          case '\\n':\n            if (atLineStart) {\n              var blankLine = new BlankLine();\n              offset = blankLine.parse({\n                src: src\n              }, offset);\n\n              if (offset < src.length) {\n                this.contents.push(blankLine);\n              }\n            } else {\n              offset += 1;\n              atLineStart = true;\n            }\n\n            lineStart = offset;\n            break;\n\n          case '#':\n            {\n              var comment = new Comment();\n              offset = comment.parse({\n                src: src\n              }, offset);\n              this.contents.push(comment);\n              atLineStart = false;\n            }\n            break;\n\n          default:\n            {\n              var iEnd = Node.endOfIndent(src, offset);\n              var context = {\n                atLineStart: atLineStart,\n                indent: -1,\n                inFlow: false,\n                inCollection: false,\n                lineStart: lineStart,\n                parent: this\n              };\n              var node = parseNode(context, iEnd);\n              if (!node) return this.valueRange.end = iEnd; // at next document start\n\n              this.contents.push(node);\n              offset = node.range.end;\n              atLineStart = false;\n              var ec = grabCollectionEndComments(node);\n              if (ec) Array.prototype.push.apply(this.contents, ec);\n            }\n        }\n\n        offset = Document.startCommentOrEndBlankLine(src, offset);\n      }\n\n      this.valueRange.end = offset;\n\n      if (src[offset]) {\n        this.documentEndMarker = new Range(offset, offset + 3);\n        offset += 3;\n\n        if (src[offset]) {\n          offset = Node.endOfWhiteSpace(src, offset);\n\n          if (src[offset] === '#') {\n            var _comment = new Comment();\n\n            offset = _comment.parse({\n              src: src\n            }, offset);\n            this.contents.push(_comment);\n          }\n\n          switch (src[offset]) {\n            case '\\n':\n              offset += 1;\n              break;\n\n            case undefined:\n              break;\n\n            default:\n              this.error = new YAMLSyntaxError(this, 'Document end marker line cannot have a non-comment suffix');\n          }\n        }\n      }\n\n      return offset;\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      context.root = this;\n      this.context = context;\n      var src = context.src;\n      var offset = src.charCodeAt(start) === 0xfeff ? start + 1 : start; // skip BOM\n\n      offset = this.parseDirectives(offset);\n      offset = this.parseContents(offset);\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(Document.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      this.directives.forEach(function (node) {\n        offset = node.setOrigRanges(cr, offset);\n      });\n      if (this.directivesEndMarker) offset = this.directivesEndMarker.setOrigRange(cr, offset);\n      this.contents.forEach(function (node) {\n        offset = node.setOrigRanges(cr, offset);\n      });\n      if (this.documentEndMarker) offset = this.documentEndMarker.setOrigRange(cr, offset);\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var contents = this.contents,\n          directives = this.directives,\n          value = this.value;\n      if (value != null) return value;\n      var str = directives.join('');\n\n      if (contents.length > 0) {\n        if (directives.length > 0 || contents[0].type === Type.COMMENT) str += '---\\n';\n        str += contents.join('');\n      }\n\n      if (str[str.length - 1] !== '\\n') str += '\\n';\n      return str;\n    }\n  }], [{\n    key: \"startCommentOrEndBlankLine\",\n    value: function startCommentOrEndBlankLine(src, start) {\n      var offset = Node.endOfWhiteSpace(src, start);\n      var ch = src[offset];\n      return ch === '#' || ch === '\\n' ? offset : start;\n    }\n  }]);\n\n  return Document;\n}(Node);\n\nvar Alias = /*#__PURE__*/function (_Node) {\n  _inherits(Alias, _Node);\n\n  var _super = _createSuper(Alias);\n\n  function Alias() {\n    _classCallCheck(this, Alias);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Alias, [{\n    key: \"parse\",\n    value:\n    /**\n     * Parses an *alias from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar\n     */\n    function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = Node.endOfIdentifier(src, start + 1);\n      this.valueRange = new Range(start + 1, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      return offset;\n    }\n  }]);\n\n  return Alias;\n}(Node);\n\nvar Chomp = {\n  CLIP: 'CLIP',\n  KEEP: 'KEEP',\n  STRIP: 'STRIP'\n};\nvar BlockValue = /*#__PURE__*/function (_Node) {\n  _inherits(BlockValue, _Node);\n\n  var _super = _createSuper(BlockValue);\n\n  function BlockValue(type, props) {\n    var _this;\n\n    _classCallCheck(this, BlockValue);\n\n    _this = _super.call(this, type, props);\n    _this.blockIndent = null;\n    _this.chomping = Chomp.CLIP;\n    _this.header = null;\n    return _this;\n  }\n\n  _createClass(BlockValue, [{\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return this.chomping === Chomp.KEEP;\n    }\n  }, {\n    key: \"strValue\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          src = _this$context.src;\n      if (this.valueRange.isEmpty()) return '';\n      var lastNewLine = null;\n      var ch = src[end - 1];\n\n      while (ch === '\\n' || ch === '\\t' || ch === ' ') {\n        end -= 1;\n\n        if (end <= start) {\n          if (this.chomping === Chomp.KEEP) break;else return ''; // probably never happens\n        }\n\n        if (ch === '\\n') lastNewLine = end;\n        ch = src[end - 1];\n      }\n\n      var keepStart = end + 1;\n\n      if (lastNewLine) {\n        if (this.chomping === Chomp.KEEP) {\n          keepStart = lastNewLine;\n          end = this.valueRange.end;\n        } else {\n          end = lastNewLine;\n        }\n      }\n\n      var bi = indent + this.blockIndent;\n      var folded = this.type === Type.BLOCK_FOLDED;\n      var atStart = true;\n      var str = '';\n      var sep = '';\n      var prevMoreIndented = false;\n\n      for (var i = start; i < end; ++i) {\n        for (var j = 0; j < bi; ++j) {\n          if (src[i] !== ' ') break;\n          i += 1;\n        }\n\n        var _ch = src[i];\n\n        if (_ch === '\\n') {\n          if (sep === '\\n') str += '\\n';else sep = '\\n';\n        } else {\n          var lineEnd = Node.endOfLine(src, i);\n          var line = src.slice(i, lineEnd);\n          i = lineEnd;\n\n          if (folded && (_ch === ' ' || _ch === '\\t') && i < keepStart) {\n            if (sep === ' ') sep = '\\n';else if (!prevMoreIndented && !atStart && sep === '\\n') sep = '\\n\\n';\n            str += sep + line; //+ ((lineEnd < end && src[lineEnd]) || '')\n\n            sep = lineEnd < end && src[lineEnd] || '';\n            prevMoreIndented = true;\n          } else {\n            str += sep + line;\n            sep = folded && i < keepStart ? ' ' : '\\n';\n            prevMoreIndented = false;\n          }\n\n          if (atStart && line !== '') atStart = false;\n        }\n      }\n\n      return this.chomping === Chomp.STRIP ? str : str + '\\n';\n    }\n  }, {\n    key: \"parseBlockHeader\",\n    value: function parseBlockHeader(start) {\n      var src = this.context.src;\n      var offset = start + 1;\n      var bi = '';\n\n      while (true) {\n        var ch = src[offset];\n\n        switch (ch) {\n          case '-':\n            this.chomping = Chomp.STRIP;\n            break;\n\n          case '+':\n            this.chomping = Chomp.KEEP;\n            break;\n\n          case '0':\n          case '1':\n          case '2':\n          case '3':\n          case '4':\n          case '5':\n          case '6':\n          case '7':\n          case '8':\n          case '9':\n            bi += ch;\n            break;\n\n          default:\n            this.blockIndent = Number(bi) || null;\n            this.header = new Range(start, offset);\n            return offset;\n        }\n\n        offset += 1;\n      }\n    }\n  }, {\n    key: \"parseBlockValue\",\n    value: function parseBlockValue(start) {\n      var _this$context2 = this.context,\n          indent = _this$context2.indent,\n          src = _this$context2.src;\n      var explicit = !!this.blockIndent;\n      var offset = start;\n      var valueEnd = start;\n      var minBlockIndent = 1;\n\n      for (var ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n        offset += 1;\n        if (Node.atDocumentBoundary(src, offset)) break;\n        var end = Node.endOfBlockIndent(src, indent, offset); // should not include tab?\n\n        if (end === null) break;\n        var _ch2 = src[end];\n        var lineIndent = end - (offset + indent);\n\n        if (!this.blockIndent) {\n          // no explicit block indent, none yet detected\n          if (src[end] !== '\\n') {\n            // first line with non-whitespace content\n            if (lineIndent < minBlockIndent) {\n              var msg = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';\n              this.error = new YAMLSemanticError(this, msg);\n            }\n\n            this.blockIndent = lineIndent;\n          } else if (lineIndent > minBlockIndent) {\n            // empty line with more whitespace\n            minBlockIndent = lineIndent;\n          }\n        } else if (_ch2 && _ch2 !== '\\n' && lineIndent < this.blockIndent) {\n          if (src[end] === '#') break;\n\n          if (!this.error) {\n            var _src = explicit ? 'explicit indentation indicator' : 'first line';\n\n            var _msg = \"Block scalars must not be less indented than their \".concat(_src);\n\n            this.error = new YAMLSemanticError(this, _msg);\n          }\n        }\n\n        if (src[end] === '\\n') {\n          offset = end;\n        } else {\n          offset = valueEnd = Node.endOfLine(src, end);\n        }\n      }\n\n      if (this.chomping !== Chomp.KEEP) {\n        offset = src[valueEnd] ? valueEnd + 1 : valueEnd;\n      }\n\n      this.valueRange = new Range(start + 1, offset);\n      return offset;\n    }\n    /**\n     * Parses a block value from the source\n     *\n     * Accepted forms are:\n     * ```\n     * BS\n     * block\n     * lines\n     *\n     * BS #comment\n     * block\n     * lines\n     * ```\n     * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines\n     * are empty or have an indent level greater than `indent`.\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this block\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = this.parseBlockHeader(start);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      offset = this.parseBlockValue(offset);\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(BlockValue.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      return this.header ? this.header.setOrigRange(cr, offset) : offset;\n    }\n  }]);\n\n  return BlockValue;\n}(Node);\n\nvar FlowCollection = /*#__PURE__*/function (_Node) {\n  _inherits(FlowCollection, _Node);\n\n  var _super = _createSuper(FlowCollection);\n\n  function FlowCollection(type, props) {\n    var _this;\n\n    _classCallCheck(this, FlowCollection);\n\n    _this = _super.call(this, type, props);\n    _this.items = null;\n    return _this;\n  }\n\n  _createClass(FlowCollection, [{\n    key: \"prevNodeIsJsonLike\",\n    value: function prevNodeIsJsonLike() {\n      var idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.items.length;\n      var node = this.items[idx - 1];\n      return !!node && (node.jsonLike || node.type === Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var parseNode = context.parseNode,\n          src = context.src;\n      var indent = context.indent,\n          lineStart = context.lineStart;\n      var char = src[start]; // { or [\n\n      this.items = [{\n        char: char,\n        offset: start\n      }];\n      var offset = Node.endOfWhiteSpace(src, start + 1);\n      char = src[offset];\n\n      while (char && char !== ']' && char !== '}') {\n        switch (char) {\n          case '\\n':\n            {\n              lineStart = offset + 1;\n              var wsEnd = Node.endOfWhiteSpace(src, lineStart);\n\n              if (src[wsEnd] === '\\n') {\n                var blankLine = new BlankLine();\n                lineStart = blankLine.parse({\n                  src: src\n                }, lineStart);\n                this.items.push(blankLine);\n              }\n\n              offset = Node.endOfIndent(src, lineStart);\n\n              if (offset <= lineStart + indent) {\n                char = src[offset];\n\n                if (offset < lineStart + indent || char !== ']' && char !== '}') {\n                  var msg = 'Insufficient indentation in flow collection';\n                  this.error = new YAMLSemanticError(this, msg);\n                }\n              }\n            }\n            break;\n\n          case ',':\n            {\n              this.items.push({\n                char: char,\n                offset: offset\n              });\n              offset += 1;\n            }\n            break;\n\n          case '#':\n            {\n              var comment = new Comment();\n              offset = comment.parse({\n                src: src\n              }, offset);\n              this.items.push(comment);\n            }\n            break;\n\n          case '?':\n          case ':':\n            {\n              var next = src[offset + 1];\n\n              if (next === '\\n' || next === '\\t' || next === ' ' || next === ',' || // in-flow : after JSON-like key does not need to be followed by whitespace\n              char === ':' && this.prevNodeIsJsonLike()) {\n                this.items.push({\n                  char: char,\n                  offset: offset\n                });\n                offset += 1;\n                break;\n              }\n            }\n          // fallthrough\n\n          default:\n            {\n              var node = parseNode({\n                atLineStart: false,\n                inCollection: false,\n                inFlow: true,\n                indent: -1,\n                lineStart: lineStart,\n                parent: this\n              }, offset);\n\n              if (!node) {\n                // at next document start\n                this.valueRange = new Range(start, offset);\n                return offset;\n              }\n\n              this.items.push(node);\n              offset = Node.normalizeOffset(src, node.range.end);\n            }\n        }\n\n        offset = Node.endOfWhiteSpace(src, offset);\n        char = src[offset];\n      }\n\n      this.valueRange = new Range(start, offset + 1);\n\n      if (char) {\n        this.items.push({\n          char: char,\n          offset: offset\n        });\n        offset = Node.endOfWhiteSpace(src, offset + 1);\n        offset = this.parseComment(offset);\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(FlowCollection.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      this.items.forEach(function (node) {\n        if (node instanceof Node) {\n          offset = node.setOrigRanges(cr, offset);\n        } else if (cr.length === 0) {\n          node.origOffset = node.offset;\n        } else {\n          var i = offset;\n\n          while (i < cr.length) {\n            if (cr[i] > node.offset) break;else ++i;\n          }\n\n          node.origOffset = node.offset + i;\n          offset = i;\n        }\n      });\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          items = this.items,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var nodes = items.filter(function (item) {\n        return item instanceof Node;\n      });\n      var str = '';\n      var prevEnd = range.start;\n      nodes.forEach(function (node) {\n        var prefix = src.slice(prevEnd, node.range.start);\n        prevEnd = node.range.end;\n        str += prefix + String(node);\n\n        if (str[str.length - 1] === '\\n' && src[prevEnd - 1] !== '\\n' && src[prevEnd] === '\\n') {\n          // Comment range does not include the terminal newline, but its\n          // stringified value does. Without this fix, newlines at comment ends\n          // get duplicated.\n          prevEnd += 1;\n        }\n      });\n      str += src.slice(prevEnd, range.end);\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }]);\n\n  return FlowCollection;\n}(Node);\n\nvar QuoteDouble = /*#__PURE__*/function (_Node) {\n  _inherits(QuoteDouble, _Node);\n\n  var _super = _createSuper(QuoteDouble);\n\n  function QuoteDouble() {\n    _classCallCheck(this, QuoteDouble);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(QuoteDouble, [{\n    key: \"strValue\",\n    get:\n    /**\n     * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n     */\n    function get() {\n      if (!this.valueRange || !this.context) return null;\n      var errors = [];\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          src = _this$context.src;\n      if (src[end - 1] !== '\"') errors.push(new YAMLSyntaxError(this, 'Missing closing \"quote')); // Using String#replace is too painful with escaped newlines preceded by\n      // escaped backslashes; also, this should be faster.\n\n      var str = '';\n\n      for (var i = start + 1; i < end - 1; ++i) {\n        var ch = src[i];\n\n        if (ch === '\\n') {\n          if (Node.atDocumentBoundary(src, i + 1)) errors.push(new YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n\n          var _Node$foldNewline = Node.foldNewline(src, i, indent),\n              fold = _Node$foldNewline.fold,\n              offset = _Node$foldNewline.offset,\n              error = _Node$foldNewline.error;\n\n          str += fold;\n          i = offset;\n          if (error) errors.push(new YAMLSemanticError(this, 'Multi-line double-quoted string needs to be sufficiently indented'));\n        } else if (ch === '\\\\') {\n          i += 1;\n\n          switch (src[i]) {\n            case '0':\n              str += '\\0';\n              break;\n            // null character\n\n            case 'a':\n              str += '\\x07';\n              break;\n            // bell character\n\n            case 'b':\n              str += '\\b';\n              break;\n            // backspace\n\n            case 'e':\n              str += '\\x1b';\n              break;\n            // escape character\n\n            case 'f':\n              str += '\\f';\n              break;\n            // form feed\n\n            case 'n':\n              str += '\\n';\n              break;\n            // line feed\n\n            case 'r':\n              str += '\\r';\n              break;\n            // carriage return\n\n            case 't':\n              str += '\\t';\n              break;\n            // horizontal tab\n\n            case 'v':\n              str += '\\v';\n              break;\n            // vertical tab\n\n            case 'N':\n              str += \"\\x85\";\n              break;\n            // Unicode next line\n\n            case '_':\n              str += \"\\xA0\";\n              break;\n            // Unicode non-breaking space\n\n            case 'L':\n              str += \"\\u2028\";\n              break;\n            // Unicode line separator\n\n            case 'P':\n              str += \"\\u2029\";\n              break;\n            // Unicode paragraph separator\n\n            case ' ':\n              str += ' ';\n              break;\n\n            case '\"':\n              str += '\"';\n              break;\n\n            case '/':\n              str += '/';\n              break;\n\n            case '\\\\':\n              str += '\\\\';\n              break;\n\n            case '\\t':\n              str += '\\t';\n              break;\n\n            case 'x':\n              str += this.parseCharCode(i + 1, 2, errors);\n              i += 2;\n              break;\n\n            case 'u':\n              str += this.parseCharCode(i + 1, 4, errors);\n              i += 4;\n              break;\n\n            case 'U':\n              str += this.parseCharCode(i + 1, 8, errors);\n              i += 8;\n              break;\n\n            case '\\n':\n              // skip escaped newlines, but still trim the following line\n              while (src[i + 1] === ' ' || src[i + 1] === '\\t') {\n                i += 1;\n              }\n\n              break;\n\n            default:\n              errors.push(new YAMLSyntaxError(this, \"Invalid escape sequence \".concat(src.substr(i - 1, 2))));\n              str += '\\\\' + src[i];\n          }\n        } else if (ch === ' ' || ch === '\\t') {\n          // trim trailing whitespace\n          var wsStart = i;\n          var next = src[i + 1];\n\n          while (next === ' ' || next === '\\t') {\n            i += 1;\n            next = src[i + 1];\n          }\n\n          if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n        } else {\n          str += ch;\n        }\n      }\n\n      return errors.length > 0 ? {\n        errors: errors,\n        str: str\n      } : str;\n    }\n  }, {\n    key: \"parseCharCode\",\n    value: function parseCharCode(offset, length, errors) {\n      var src = this.context.src;\n      var cc = src.substr(offset, length);\n      var ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n      var code = ok ? parseInt(cc, 16) : NaN;\n\n      if (isNaN(code)) {\n        errors.push(new YAMLSyntaxError(this, \"Invalid escape sequence \".concat(src.substr(offset - 2, length + 2))));\n        return src.substr(offset - 2, length + 2);\n      }\n\n      return String.fromCodePoint(code);\n    }\n    /**\n     * Parses a \"double quoted\" value from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = QuoteDouble.endOfQuote(src, start + 1);\n      this.valueRange = new Range(start, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      return offset;\n    }\n  }], [{\n    key: \"endOfQuote\",\n    value: function endOfQuote(src, offset) {\n      var ch = src[offset];\n\n      while (ch && ch !== '\"') {\n        offset += ch === '\\\\' ? 2 : 1;\n        ch = src[offset];\n      }\n\n      return offset + 1;\n    }\n  }]);\n\n  return QuoteDouble;\n}(Node);\n\nvar QuoteSingle = /*#__PURE__*/function (_Node) {\n  _inherits(QuoteSingle, _Node);\n\n  var _super = _createSuper(QuoteSingle);\n\n  function QuoteSingle() {\n    _classCallCheck(this, QuoteSingle);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(QuoteSingle, [{\n    key: \"strValue\",\n    get:\n    /**\n     * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n     */\n    function get() {\n      if (!this.valueRange || !this.context) return null;\n      var errors = [];\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          src = _this$context.src;\n      if (src[end - 1] !== \"'\") errors.push(new YAMLSyntaxError(this, \"Missing closing 'quote\"));\n      var str = '';\n\n      for (var i = start + 1; i < end - 1; ++i) {\n        var ch = src[i];\n\n        if (ch === '\\n') {\n          if (Node.atDocumentBoundary(src, i + 1)) errors.push(new YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n\n          var _Node$foldNewline = Node.foldNewline(src, i, indent),\n              fold = _Node$foldNewline.fold,\n              offset = _Node$foldNewline.offset,\n              error = _Node$foldNewline.error;\n\n          str += fold;\n          i = offset;\n          if (error) errors.push(new YAMLSemanticError(this, 'Multi-line single-quoted string needs to be sufficiently indented'));\n        } else if (ch === \"'\") {\n          str += ch;\n          i += 1;\n          if (src[i] !== \"'\") errors.push(new YAMLSyntaxError(this, 'Unescaped single quote? This should not happen.'));\n        } else if (ch === ' ' || ch === '\\t') {\n          // trim trailing whitespace\n          var wsStart = i;\n          var next = src[i + 1];\n\n          while (next === ' ' || next === '\\t') {\n            i += 1;\n            next = src[i + 1];\n          }\n\n          if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n        } else {\n          str += ch;\n        }\n      }\n\n      return errors.length > 0 ? {\n        errors: errors,\n        str: str\n      } : str;\n    }\n    /**\n     * Parses a 'single quoted' value from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = QuoteSingle.endOfQuote(src, start + 1);\n      this.valueRange = new Range(start, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      return offset;\n    }\n  }], [{\n    key: \"endOfQuote\",\n    value: function endOfQuote(src, offset) {\n      var ch = src[offset];\n\n      while (ch) {\n        if (ch === \"'\") {\n          if (src[offset + 1] !== \"'\") break;\n          ch = src[offset += 2];\n        } else {\n          ch = src[offset += 1];\n        }\n      }\n\n      return offset + 1;\n    }\n  }]);\n\n  return QuoteSingle;\n}(Node);\n\nfunction createNewNode(type, props) {\n  switch (type) {\n    case Type.ALIAS:\n      return new Alias(type, props);\n\n    case Type.BLOCK_FOLDED:\n    case Type.BLOCK_LITERAL:\n      return new BlockValue(type, props);\n\n    case Type.FLOW_MAP:\n    case Type.FLOW_SEQ:\n      return new FlowCollection(type, props);\n\n    case Type.MAP_KEY:\n    case Type.MAP_VALUE:\n    case Type.SEQ_ITEM:\n      return new CollectionItem(type, props);\n\n    case Type.COMMENT:\n    case Type.PLAIN:\n      return new PlainValue(type, props);\n\n    case Type.QUOTE_DOUBLE:\n      return new QuoteDouble(type, props);\n\n    case Type.QUOTE_SINGLE:\n      return new QuoteSingle(type, props);\n\n    /* istanbul ignore next */\n\n    default:\n      return null;\n    // should never happen\n  }\n}\n/**\n * @param {boolean} atLineStart - Node starts at beginning of line\n * @param {boolean} inFlow - true if currently in a flow context\n * @param {boolean} inCollection - true if currently in a collection context\n * @param {number} indent - Current level of indentation\n * @param {number} lineStart - Start of the current line\n * @param {Node} parent - The parent of the node\n * @param {string} src - Source of the YAML document\n */\n\n\nvar ParseContext = /*#__PURE__*/function () {\n  function ParseContext() {\n    var _this = this;\n\n    var orig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        atLineStart = _ref.atLineStart,\n        inCollection = _ref.inCollection,\n        inFlow = _ref.inFlow,\n        indent = _ref.indent,\n        lineStart = _ref.lineStart,\n        parent = _ref.parent;\n\n    _classCallCheck(this, ParseContext);\n\n    _defineProperty(this, \"parseNode\", function (overlay, start) {\n      if (Node.atDocumentBoundary(_this.src, start)) return null;\n      var context = new ParseContext(_this, overlay);\n\n      var _context$parseProps = context.parseProps(start),\n          props = _context$parseProps.props,\n          type = _context$parseProps.type,\n          valueStart = _context$parseProps.valueStart;\n\n      var node = createNewNode(type, props);\n      var offset = node.parse(context, valueStart);\n      node.range = new Range(start, offset);\n      /* istanbul ignore if */\n\n      if (offset <= start) {\n        // This should never happen, but if it does, let's make sure to at least\n        // step one character forward to avoid a busy loop.\n        node.error = new Error(\"Node#parse consumed no characters\");\n        node.error.parseEnd = offset;\n        node.error.source = node;\n        node.range.end = start + 1;\n      }\n\n      if (context.nodeStartsCollection(node)) {\n        if (!node.error && !context.atLineStart && context.parent.type === Type.DOCUMENT) {\n          node.error = new YAMLSyntaxError(node, 'Block collection must not have preceding content here (e.g. directives-end indicator)');\n        }\n\n        var collection = new Collection(node);\n        offset = collection.parse(new ParseContext(context), offset);\n        collection.range = new Range(start, offset);\n        return collection;\n      }\n\n      return node;\n    });\n\n    this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;\n    this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;\n    this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;\n    this.indent = indent != null ? indent : orig.indent;\n    this.lineStart = lineStart != null ? lineStart : orig.lineStart;\n    this.parent = parent != null ? parent : orig.parent || {};\n    this.root = orig.root;\n    this.src = orig.src;\n  }\n\n  _createClass(ParseContext, [{\n    key: \"nodeStartsCollection\",\n    value: function nodeStartsCollection(node) {\n      var inCollection = this.inCollection,\n          inFlow = this.inFlow,\n          src = this.src;\n      if (inCollection || inFlow) return false;\n      if (node instanceof CollectionItem) return true; // check for implicit key\n\n      var offset = node.range.end;\n      if (src[offset] === '\\n' || src[offset - 1] === '\\n') return false;\n      offset = Node.endOfWhiteSpace(src, offset);\n      return src[offset] === ':';\n    } // Anchor and tag are before type, which determines the node implementation\n    // class; hence this intermediate step.\n\n  }, {\n    key: \"parseProps\",\n    value: function parseProps(offset) {\n      var inFlow = this.inFlow,\n          parent = this.parent,\n          src = this.src;\n      var props = [];\n      var lineHasProps = false;\n      offset = this.atLineStart ? Node.endOfIndent(src, offset) : Node.endOfWhiteSpace(src, offset);\n      var ch = src[offset];\n\n      while (ch === Char.ANCHOR || ch === Char.COMMENT || ch === Char.TAG || ch === '\\n') {\n        if (ch === '\\n') {\n          var inEnd = offset;\n          var lineStart = void 0;\n\n          do {\n            lineStart = inEnd + 1;\n            inEnd = Node.endOfIndent(src, lineStart);\n          } while (src[inEnd] === '\\n');\n\n          var indentDiff = inEnd - (lineStart + this.indent);\n          var noIndicatorAsIndent = parent.type === Type.SEQ_ITEM && parent.context.atLineStart;\n          if (src[inEnd] !== '#' && !Node.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent)) break;\n          this.atLineStart = true;\n          this.lineStart = lineStart;\n          lineHasProps = false;\n          offset = inEnd;\n        } else if (ch === Char.COMMENT) {\n          var end = Node.endOfLine(src, offset + 1);\n          props.push(new Range(offset, end));\n          offset = end;\n        } else {\n          var _end = Node.endOfIdentifier(src, offset + 1);\n\n          if (ch === Char.TAG && src[_end] === ',' && /^[a-zA-Z0-9-]+\\.[a-zA-Z0-9-]+,\\d\\d\\d\\d(-\\d\\d){0,2}\\/\\S/.test(src.slice(offset + 1, _end + 13))) {\n            // Let's presume we're dealing with a YAML 1.0 domain tag here, rather\n            // than an empty but 'foo.bar' private-tagged node in a flow collection\n            // followed without whitespace by a plain string starting with a year\n            // or date divided by something.\n            _end = Node.endOfIdentifier(src, _end + 5);\n          }\n\n          props.push(new Range(offset, _end));\n          lineHasProps = true;\n          offset = Node.endOfWhiteSpace(src, _end);\n        }\n\n        ch = src[offset];\n      } // '- &a : b' has an anchor on an empty node\n\n\n      if (lineHasProps && ch === ':' && Node.atBlank(src, offset + 1, true)) offset -= 1;\n      var type = ParseContext.parseType(src, offset, inFlow);\n      return {\n        props: props,\n        type: type,\n        valueStart: offset\n      };\n    }\n    /**\n     * Parses a node from the source\n     * @param {ParseContext} overlay\n     * @param {number} start - Index of first non-whitespace character for the node\n     * @returns {?Node} - null if at a document boundary\n     */\n\n  }], [{\n    key: \"parseType\",\n    value: function parseType(src, offset, inFlow) {\n      switch (src[offset]) {\n        case '*':\n          return Type.ALIAS;\n\n        case '>':\n          return Type.BLOCK_FOLDED;\n\n        case '|':\n          return Type.BLOCK_LITERAL;\n\n        case '{':\n          return Type.FLOW_MAP;\n\n        case '[':\n          return Type.FLOW_SEQ;\n\n        case '?':\n          return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.MAP_KEY : Type.PLAIN;\n\n        case ':':\n          return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.MAP_VALUE : Type.PLAIN;\n\n        case '-':\n          return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.SEQ_ITEM : Type.PLAIN;\n\n        case '\"':\n          return Type.QUOTE_DOUBLE;\n\n        case \"'\":\n          return Type.QUOTE_SINGLE;\n\n        default:\n          return Type.PLAIN;\n      }\n    }\n  }]);\n\n  return ParseContext;\n}();\n\n// Published as 'yaml/parse-cst'\nfunction parse(src) {\n  var cr = [];\n\n  if (src.indexOf('\\r') !== -1) {\n    src = src.replace(/\\r\\n?/g, function (match, offset) {\n      if (match.length > 1) cr.push(offset);\n      return '\\n';\n    });\n  }\n\n  var documents = [];\n  var offset = 0;\n\n  do {\n    var doc = new Document();\n    var context = new ParseContext({\n      src: src\n    });\n    offset = doc.parse(context, offset);\n    documents.push(doc);\n  } while (offset < src.length);\n\n  documents.setOrigRanges = function () {\n    if (cr.length === 0) return false;\n\n    for (var i = 1; i < cr.length; ++i) {\n      cr[i] -= i;\n    }\n\n    var crOffset = 0;\n\n    for (var _i = 0; _i < documents.length; ++_i) {\n      crOffset = documents[_i].setOrigRanges(cr, crOffset);\n    }\n\n    cr.splice(0, cr.length);\n    return true;\n  };\n\n  documents.toString = function () {\n    return documents.join('...\\n');\n  };\n\n  return documents;\n}\n\nexport { parse };\n", "import { c as _classCallCheck, j as _inherits, k as _createSuper, b as _createClass, e as _defineProperty, p as _assertThisInitialized, a as _typeof, q as _toArray, T as Type, _ as _createForOfIteratorHelper, l as _get, m as _getPrototypeOf, o as YAMLReferenceError, r as _possibleConstructorReturn, h as _slicedToArray, g as YAMLSemanticError, n as defaultTags, f as YAMLWarning, C as Char, Y as YAMLSyntaxError, P as PlainValue } from './PlainValue-b8036b75.js';\n\nfunction addCommentBefore(str, indent, comment) {\n  if (!comment) return str;\n  var cc = comment.replace(/[\\s\\S]^/gm, \"$&\".concat(indent, \"#\"));\n  return \"#\".concat(cc, \"\\n\").concat(indent).concat(str);\n}\nfunction addComment(str, indent, comment) {\n  return !comment ? str : comment.indexOf('\\n') === -1 ? \"\".concat(str, \" #\").concat(comment) : \"\".concat(str, \"\\n\") + comment.replace(/^/gm, \"\".concat(indent || '', \"#\"));\n}\n\nvar Node = function Node() {\n  _classCallCheck(this, Node);\n};\n\nfunction toJSON(value, arg, ctx) {\n  if (Array.isArray(value)) return value.map(function (v, i) {\n    return toJSON(v, String(i), ctx);\n  });\n\n  if (value && typeof value.toJSON === 'function') {\n    var anchor = ctx && ctx.anchors && ctx.anchors.get(value);\n    if (anchor) ctx.onCreate = function (res) {\n      anchor.res = res;\n      delete ctx.onCreate;\n    };\n    var res = value.toJSON(arg, ctx);\n    if (anchor && ctx.onCreate) ctx.onCreate(res);\n    return res;\n  }\n\n  if ((!ctx || !ctx.keep) && typeof value === 'bigint') return Number(value);\n  return value;\n}\n\nvar Scalar = /*#__PURE__*/function (_Node) {\n  _inherits(Scalar, _Node);\n\n  var _super = _createSuper(Scalar);\n\n  function Scalar(value) {\n    var _this;\n\n    _classCallCheck(this, Scalar);\n\n    _this = _super.call(this);\n    _this.value = value;\n    return _this;\n  }\n\n  _createClass(Scalar, [{\n    key: \"toJSON\",\n    value: function toJSON$1(arg, ctx) {\n      return ctx && ctx.keep ? this.value : toJSON(this.value, arg, ctx);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return String(this.value);\n    }\n  }]);\n\n  return Scalar;\n}(Node);\n\nfunction collectionFromPath(schema, path, value) {\n  var v = value;\n\n  for (var i = path.length - 1; i >= 0; --i) {\n    var k = path[i];\n\n    if (Number.isInteger(k) && k >= 0) {\n      var a = [];\n      a[k] = v;\n      v = a;\n    } else {\n      var o = {};\n      Object.defineProperty(o, k, {\n        value: v,\n        writable: true,\n        enumerable: true,\n        configurable: true\n      });\n      v = o;\n    }\n  }\n\n  return schema.createNode(v, false);\n} // null, undefined, or an empty non-string iterable (e.g. [])\n\n\nvar isEmptyPath = function isEmptyPath(path) {\n  return path == null || _typeof(path) === 'object' && path[Symbol.iterator]().next().done;\n};\nvar Collection = /*#__PURE__*/function (_Node) {\n  _inherits(Collection, _Node);\n\n  var _super = _createSuper(Collection);\n\n  function Collection(schema) {\n    var _this;\n\n    _classCallCheck(this, Collection);\n\n    _this = _super.call(this);\n\n    _defineProperty(_assertThisInitialized(_this), \"items\", []);\n\n    _this.schema = schema;\n    return _this;\n  }\n\n  _createClass(Collection, [{\n    key: \"addIn\",\n    value: function addIn(path, value) {\n      if (isEmptyPath(path)) this.add(value);else {\n        var _path = _toArray(path),\n            key = _path[0],\n            rest = _path.slice(1);\n\n        var node = this.get(key, true);\n        if (node instanceof Collection) node.addIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(\"Expected YAML collection at \".concat(key, \". Remaining path: \").concat(rest));\n      }\n    }\n  }, {\n    key: \"deleteIn\",\n    value: function deleteIn(_ref) {\n      var _ref2 = _toArray(_ref),\n          key = _ref2[0],\n          rest = _ref2.slice(1);\n\n      if (rest.length === 0) return this.delete(key);\n      var node = this.get(key, true);\n      if (node instanceof Collection) return node.deleteIn(rest);else throw new Error(\"Expected YAML collection at \".concat(key, \". Remaining path: \").concat(rest));\n    }\n  }, {\n    key: \"getIn\",\n    value: function getIn(_ref3, keepScalar) {\n      var _ref4 = _toArray(_ref3),\n          key = _ref4[0],\n          rest = _ref4.slice(1);\n\n      var node = this.get(key, true);\n      if (rest.length === 0) return !keepScalar && node instanceof Scalar ? node.value : node;else return node instanceof Collection ? node.getIn(rest, keepScalar) : undefined;\n    }\n  }, {\n    key: \"hasAllNullValues\",\n    value: function hasAllNullValues() {\n      return this.items.every(function (node) {\n        if (!node || node.type !== 'PAIR') return false;\n        var n = node.value;\n        return n == null || n instanceof Scalar && n.value == null && !n.commentBefore && !n.comment && !n.tag;\n      });\n    }\n  }, {\n    key: \"hasIn\",\n    value: function hasIn(_ref5) {\n      var _ref6 = _toArray(_ref5),\n          key = _ref6[0],\n          rest = _ref6.slice(1);\n\n      if (rest.length === 0) return this.has(key);\n      var node = this.get(key, true);\n      return node instanceof Collection ? node.hasIn(rest) : false;\n    }\n  }, {\n    key: \"setIn\",\n    value: function setIn(_ref7, value) {\n      var _ref8 = _toArray(_ref7),\n          key = _ref8[0],\n          rest = _ref8.slice(1);\n\n      if (rest.length === 0) {\n        this.set(key, value);\n      } else {\n        var node = this.get(key, true);\n        if (node instanceof Collection) node.setIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(\"Expected YAML collection at \".concat(key, \". Remaining path: \").concat(rest));\n      }\n    } // overridden in implementations\n\n    /* istanbul ignore next */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return null;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(ctx, _ref9, onComment, onChompKeep) {\n      var _this2 = this;\n\n      var blockItem = _ref9.blockItem,\n          flowChars = _ref9.flowChars,\n          isMap = _ref9.isMap,\n          itemIndent = _ref9.itemIndent;\n      var _ctx = ctx,\n          indent = _ctx.indent,\n          indentStep = _ctx.indentStep,\n          stringify = _ctx.stringify;\n      var inFlow = this.type === Type.FLOW_MAP || this.type === Type.FLOW_SEQ || ctx.inFlow;\n      if (inFlow) itemIndent += indentStep;\n      var allNullValues = isMap && this.hasAllNullValues();\n      ctx = Object.assign({}, ctx, {\n        allNullValues: allNullValues,\n        indent: itemIndent,\n        inFlow: inFlow,\n        type: null\n      });\n      var chompKeep = false;\n      var hasItemWithNewLine = false;\n      var nodes = this.items.reduce(function (nodes, item, i) {\n        var comment;\n\n        if (item) {\n          if (!chompKeep && item.spaceBefore) nodes.push({\n            type: 'comment',\n            str: ''\n          });\n          if (item.commentBefore) item.commentBefore.match(/^.*$/gm).forEach(function (line) {\n            nodes.push({\n              type: 'comment',\n              str: \"#\".concat(line)\n            });\n          });\n          if (item.comment) comment = item.comment;\n          if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment))) hasItemWithNewLine = true;\n        }\n\n        chompKeep = false;\n        var str = stringify(item, ctx, function () {\n          return comment = null;\n        }, function () {\n          return chompKeep = true;\n        });\n        if (inFlow && !hasItemWithNewLine && str.includes('\\n')) hasItemWithNewLine = true;\n        if (inFlow && i < _this2.items.length - 1) str += ',';\n        str = addComment(str, itemIndent, comment);\n        if (chompKeep && (comment || inFlow)) chompKeep = false;\n        nodes.push({\n          type: 'item',\n          str: str\n        });\n        return nodes;\n      }, []);\n      var str;\n\n      if (nodes.length === 0) {\n        str = flowChars.start + flowChars.end;\n      } else if (inFlow) {\n        var start = flowChars.start,\n            end = flowChars.end;\n        var strings = nodes.map(function (n) {\n          return n.str;\n        });\n\n        if (hasItemWithNewLine || strings.reduce(function (sum, str) {\n          return sum + str.length + 2;\n        }, 2) > Collection.maxFlowStringSingleLineLength) {\n          str = start;\n\n          var _iterator = _createForOfIteratorHelper(strings),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var s = _step.value;\n              str += s ? \"\\n\".concat(indentStep).concat(indent).concat(s) : '\\n';\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n\n          str += \"\\n\".concat(indent).concat(end);\n        } else {\n          str = \"\".concat(start, \" \").concat(strings.join(' '), \" \").concat(end);\n        }\n      } else {\n        var _strings = nodes.map(blockItem);\n\n        str = _strings.shift();\n\n        var _iterator2 = _createForOfIteratorHelper(_strings),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _s = _step2.value;\n            str += _s ? \"\\n\".concat(indent).concat(_s) : '\\n';\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      if (this.comment) {\n        str += '\\n' + this.comment.replace(/^/gm, \"\".concat(indent, \"#\"));\n        if (onComment) onComment();\n      } else if (chompKeep && onChompKeep) onChompKeep();\n\n      return str;\n    }\n  }]);\n\n  return Collection;\n}(Node);\n\n_defineProperty(Collection, \"maxFlowStringSingleLineLength\", 60);\n\nfunction asItemIndex(key) {\n  var idx = key instanceof Scalar ? key.value : key;\n  if (idx && typeof idx === 'string') idx = Number(idx);\n  return Number.isInteger(idx) && idx >= 0 ? idx : null;\n}\n\nvar YAMLSeq = /*#__PURE__*/function (_Collection) {\n  _inherits(YAMLSeq, _Collection);\n\n  var _super = _createSuper(YAMLSeq);\n\n  function YAMLSeq() {\n    _classCallCheck(this, YAMLSeq);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(YAMLSeq, [{\n    key: \"add\",\n    value: function add(value) {\n      this.items.push(value);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      var idx = asItemIndex(key);\n      if (typeof idx !== 'number') return false;\n      var del = this.items.splice(idx, 1);\n      return del.length > 0;\n    }\n  }, {\n    key: \"get\",\n    value: function get(key, keepScalar) {\n      var idx = asItemIndex(key);\n      if (typeof idx !== 'number') return undefined;\n      var it = this.items[idx];\n      return !keepScalar && it instanceof Scalar ? it.value : it;\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      var idx = asItemIndex(key);\n      return typeof idx === 'number' && idx < this.items.length;\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      var idx = asItemIndex(key);\n      if (typeof idx !== 'number') throw new Error(\"Expected a valid index, not \".concat(key, \".\"));\n      this.items[idx] = value;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON$1(_, ctx) {\n      var seq = [];\n      if (ctx && ctx.onCreate) ctx.onCreate(seq);\n      var i = 0;\n\n      var _iterator = _createForOfIteratorHelper(this.items),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var item = _step.value;\n          seq.push(toJSON(item, String(i++), ctx));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return seq;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(ctx, onComment, onChompKeep) {\n      if (!ctx) return JSON.stringify(this);\n      return _get(_getPrototypeOf(YAMLSeq.prototype), \"toString\", this).call(this, ctx, {\n        blockItem: function blockItem(n) {\n          return n.type === 'comment' ? n.str : \"- \".concat(n.str);\n        },\n        flowChars: {\n          start: '[',\n          end: ']'\n        },\n        isMap: false,\n        itemIndent: (ctx.indent || '') + '  '\n      }, onComment, onChompKeep);\n    }\n  }]);\n\n  return YAMLSeq;\n}(Collection);\n\nvar stringifyKey = function stringifyKey(key, jsKey, ctx) {\n  if (jsKey === null) return '';\n  if (_typeof(jsKey) !== 'object') return String(jsKey);\n  if (key instanceof Node && ctx && ctx.doc) return key.toString({\n    anchors: Object.create(null),\n    doc: ctx.doc,\n    indent: '',\n    indentStep: ctx.indentStep,\n    inFlow: true,\n    inStringifyKey: true,\n    stringify: ctx.stringify\n  });\n  return JSON.stringify(jsKey);\n};\n\nvar Pair = /*#__PURE__*/function (_Node) {\n  _inherits(Pair, _Node);\n\n  var _super = _createSuper(Pair);\n\n  function Pair(key) {\n    var _this;\n\n    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    _classCallCheck(this, Pair);\n\n    _this = _super.call(this);\n    _this.key = key;\n    _this.value = value;\n    _this.type = Pair.Type.PAIR;\n    return _this;\n  }\n\n  _createClass(Pair, [{\n    key: \"commentBefore\",\n    get: function get() {\n      return this.key instanceof Node ? this.key.commentBefore : undefined;\n    },\n    set: function set(cb) {\n      if (this.key == null) this.key = new Scalar(null);\n      if (this.key instanceof Node) this.key.commentBefore = cb;else {\n        var msg = 'Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.';\n        throw new Error(msg);\n      }\n    }\n  }, {\n    key: \"addToJSMap\",\n    value: function addToJSMap(ctx, map) {\n      var key = toJSON(this.key, '', ctx);\n\n      if (map instanceof Map) {\n        var value = toJSON(this.value, key, ctx);\n        map.set(key, value);\n      } else if (map instanceof Set) {\n        map.add(key);\n      } else {\n        var stringKey = stringifyKey(this.key, key, ctx);\n\n        var _value = toJSON(this.value, stringKey, ctx);\n\n        if (stringKey in map) Object.defineProperty(map, stringKey, {\n          value: _value,\n          writable: true,\n          enumerable: true,\n          configurable: true\n        });else map[stringKey] = _value;\n      }\n\n      return map;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(_, ctx) {\n      var pair = ctx && ctx.mapAsMap ? new Map() : {};\n      return this.addToJSMap(ctx, pair);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(ctx, onComment, onChompKeep) {\n      if (!ctx || !ctx.doc) return JSON.stringify(this);\n      var _ctx$doc$options = ctx.doc.options,\n          indentSize = _ctx$doc$options.indent,\n          indentSeq = _ctx$doc$options.indentSeq,\n          simpleKeys = _ctx$doc$options.simpleKeys;\n      var key = this.key,\n          value = this.value;\n      var keyComment = key instanceof Node && key.comment;\n\n      if (simpleKeys) {\n        if (keyComment) {\n          throw new Error('With simple keys, key nodes cannot have comments');\n        }\n\n        if (key instanceof Collection) {\n          var msg = 'With simple keys, collection cannot be used as a key value';\n          throw new Error(msg);\n        }\n      }\n\n      var explicitKey = !simpleKeys && (!key || keyComment || (key instanceof Node ? key instanceof Collection || key.type === Type.BLOCK_FOLDED || key.type === Type.BLOCK_LITERAL : _typeof(key) === 'object'));\n      var _ctx = ctx,\n          doc = _ctx.doc,\n          indent = _ctx.indent,\n          indentStep = _ctx.indentStep,\n          stringify = _ctx.stringify;\n      ctx = Object.assign({}, ctx, {\n        implicitKey: !explicitKey,\n        indent: indent + indentStep\n      });\n      var chompKeep = false;\n      var str = stringify(key, ctx, function () {\n        return keyComment = null;\n      }, function () {\n        return chompKeep = true;\n      });\n      str = addComment(str, ctx.indent, keyComment);\n\n      if (!explicitKey && str.length > 1024) {\n        if (simpleKeys) throw new Error('With simple keys, single line scalar must not span more than 1024 characters');\n        explicitKey = true;\n      }\n\n      if (ctx.allNullValues && !simpleKeys) {\n        if (this.comment) {\n          str = addComment(str, ctx.indent, this.comment);\n          if (onComment) onComment();\n        } else if (chompKeep && !keyComment && onChompKeep) onChompKeep();\n\n        return ctx.inFlow && !explicitKey ? str : \"? \".concat(str);\n      }\n\n      str = explicitKey ? \"? \".concat(str, \"\\n\").concat(indent, \":\") : \"\".concat(str, \":\");\n\n      if (this.comment) {\n        // expected (but not strictly required) to be a single-line comment\n        str = addComment(str, ctx.indent, this.comment);\n        if (onComment) onComment();\n      }\n\n      var vcb = '';\n      var valueComment = null;\n\n      if (value instanceof Node) {\n        if (value.spaceBefore) vcb = '\\n';\n\n        if (value.commentBefore) {\n          var cs = value.commentBefore.replace(/^/gm, \"\".concat(ctx.indent, \"#\"));\n          vcb += \"\\n\".concat(cs);\n        }\n\n        valueComment = value.comment;\n      } else if (value && _typeof(value) === 'object') {\n        value = doc.schema.createNode(value, true);\n      }\n\n      ctx.implicitKey = false;\n      if (!explicitKey && !this.comment && value instanceof Scalar) ctx.indentAtStart = str.length + 1;\n      chompKeep = false;\n\n      if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value instanceof YAMLSeq && value.type !== Type.FLOW_SEQ && !value.tag && !doc.anchors.getName(value)) {\n        // If indentSeq === false, consider '- ' as part of indentation where possible\n        ctx.indent = ctx.indent.substr(2);\n      }\n\n      var valueStr = stringify(value, ctx, function () {\n        return valueComment = null;\n      }, function () {\n        return chompKeep = true;\n      });\n      var ws = ' ';\n\n      if (vcb || this.comment) {\n        ws = \"\".concat(vcb, \"\\n\").concat(ctx.indent);\n      } else if (!explicitKey && value instanceof Collection) {\n        var flow = valueStr[0] === '[' || valueStr[0] === '{';\n        if (!flow || valueStr.includes('\\n')) ws = \"\\n\".concat(ctx.indent);\n      } else if (valueStr[0] === '\\n') ws = '';\n\n      if (chompKeep && !valueComment && onChompKeep) onChompKeep();\n      return addComment(str + ws + valueStr, ctx.indent, valueComment);\n    }\n  }]);\n\n  return Pair;\n}(Node);\n\n_defineProperty(Pair, \"Type\", {\n  PAIR: 'PAIR',\n  MERGE_PAIR: 'MERGE_PAIR'\n});\n\nvar getAliasCount = function getAliasCount(node, anchors) {\n  if (node instanceof Alias) {\n    var anchor = anchors.get(node.source);\n    return anchor.count * anchor.aliasCount;\n  } else if (node instanceof Collection) {\n    var count = 0;\n\n    var _iterator = _createForOfIteratorHelper(node.items),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var item = _step.value;\n        var c = getAliasCount(item, anchors);\n        if (c > count) count = c;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return count;\n  } else if (node instanceof Pair) {\n    var kc = getAliasCount(node.key, anchors);\n    var vc = getAliasCount(node.value, anchors);\n    return Math.max(kc, vc);\n  }\n\n  return 1;\n};\n\nvar Alias = /*#__PURE__*/function (_Node) {\n  _inherits(Alias, _Node);\n\n  var _super = _createSuper(Alias);\n\n  function Alias(source) {\n    var _this;\n\n    _classCallCheck(this, Alias);\n\n    _this = _super.call(this);\n    _this.source = source;\n    _this.type = Type.ALIAS;\n    return _this;\n  }\n\n  _createClass(Alias, [{\n    key: \"tag\",\n    set: function set(t) {\n      throw new Error('Alias nodes cannot have tags');\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON$1(arg, ctx) {\n      if (!ctx) return toJSON(this.source, arg, ctx);\n      var anchors = ctx.anchors,\n          maxAliasCount = ctx.maxAliasCount;\n      var anchor = anchors.get(this.source);\n      /* istanbul ignore if */\n\n      if (!anchor || anchor.res === undefined) {\n        var msg = 'This should not happen: Alias anchor was not resolved?';\n        if (this.cstNode) throw new YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);\n      }\n\n      if (maxAliasCount >= 0) {\n        anchor.count += 1;\n        if (anchor.aliasCount === 0) anchor.aliasCount = getAliasCount(this.source, anchors);\n\n        if (anchor.count * anchor.aliasCount > maxAliasCount) {\n          var _msg = 'Excessive alias count indicates a resource exhaustion attack';\n          if (this.cstNode) throw new YAMLReferenceError(this.cstNode, _msg);else throw new ReferenceError(_msg);\n        }\n      }\n\n      return anchor.res;\n    } // Only called when stringifying an alias mapping key while constructing\n    // Object output.\n\n  }, {\n    key: \"toString\",\n    value: function toString(ctx) {\n      return Alias.stringify(this, ctx);\n    }\n  }], [{\n    key: \"stringify\",\n    value: function stringify(_ref, _ref2) {\n      var range = _ref.range,\n          source = _ref.source;\n      var anchors = _ref2.anchors,\n          doc = _ref2.doc,\n          implicitKey = _ref2.implicitKey,\n          inStringifyKey = _ref2.inStringifyKey;\n      var anchor = Object.keys(anchors).find(function (a) {\n        return anchors[a] === source;\n      });\n      if (!anchor && inStringifyKey) anchor = doc.anchors.getName(source) || doc.anchors.newName();\n      if (anchor) return \"*\".concat(anchor).concat(implicitKey ? ' ' : '');\n      var msg = doc.anchors.getName(source) ? 'Alias node must be after source node' : 'Source node not found for alias node';\n      throw new Error(\"\".concat(msg, \" [\").concat(range, \"]\"));\n    }\n  }]);\n\n  return Alias;\n}(Node);\n\n_defineProperty(Alias, \"default\", true);\n\nfunction findPair(items, key) {\n  var k = key instanceof Scalar ? key.value : key;\n\n  var _iterator = _createForOfIteratorHelper(items),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var it = _step.value;\n\n      if (it instanceof Pair) {\n        if (it.key === key || it.key === k) return it;\n        if (it.key && it.key.value === k) return it;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return undefined;\n}\nvar YAMLMap = /*#__PURE__*/function (_Collection) {\n  _inherits(YAMLMap, _Collection);\n\n  var _super = _createSuper(YAMLMap);\n\n  function YAMLMap() {\n    _classCallCheck(this, YAMLMap);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(YAMLMap, [{\n    key: \"add\",\n    value: function add(pair, overwrite) {\n      if (!pair) pair = new Pair(pair);else if (!(pair instanceof Pair)) pair = new Pair(pair.key || pair, pair.value);\n      var prev = findPair(this.items, pair.key);\n      var sortEntries = this.schema && this.schema.sortMapEntries;\n\n      if (prev) {\n        if (overwrite) prev.value = pair.value;else throw new Error(\"Key \".concat(pair.key, \" already set\"));\n      } else if (sortEntries) {\n        var i = this.items.findIndex(function (item) {\n          return sortEntries(pair, item) < 0;\n        });\n        if (i === -1) this.items.push(pair);else this.items.splice(i, 0, pair);\n      } else {\n        this.items.push(pair);\n      }\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      var it = findPair(this.items, key);\n      if (!it) return false;\n      var del = this.items.splice(this.items.indexOf(it), 1);\n      return del.length > 0;\n    }\n  }, {\n    key: \"get\",\n    value: function get(key, keepScalar) {\n      var it = findPair(this.items, key);\n      var node = it && it.value;\n      return !keepScalar && node instanceof Scalar ? node.value : node;\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      return !!findPair(this.items, key);\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      this.add(new Pair(key, value), true);\n    }\n    /**\n     * @param {*} arg ignored\n     * @param {*} ctx Conversion context, originally set in Document#toJSON()\n     * @param {Class} Type If set, forces the returned collection type\n     * @returns {*} Instance of Type, Map, or Object\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(_, ctx, Type) {\n      var map = Type ? new Type() : ctx && ctx.mapAsMap ? new Map() : {};\n      if (ctx && ctx.onCreate) ctx.onCreate(map);\n\n      var _iterator2 = _createForOfIteratorHelper(this.items),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var item = _step2.value;\n          item.addToJSMap(ctx, map);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return map;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(ctx, onComment, onChompKeep) {\n      if (!ctx) return JSON.stringify(this);\n\n      var _iterator3 = _createForOfIteratorHelper(this.items),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var item = _step3.value;\n          if (!(item instanceof Pair)) throw new Error(\"Map items must all be pairs; found \".concat(JSON.stringify(item), \" instead\"));\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return _get(_getPrototypeOf(YAMLMap.prototype), \"toString\", this).call(this, ctx, {\n        blockItem: function blockItem(n) {\n          return n.str;\n        },\n        flowChars: {\n          start: '{',\n          end: '}'\n        },\n        isMap: true,\n        itemIndent: ctx.indent || ''\n      }, onComment, onChompKeep);\n    }\n  }]);\n\n  return YAMLMap;\n}(Collection);\n\nvar MERGE_KEY = '<<';\nvar Merge = /*#__PURE__*/function (_Pair) {\n  _inherits(Merge, _Pair);\n\n  var _super = _createSuper(Merge);\n\n  function Merge(pair) {\n    var _this;\n\n    _classCallCheck(this, Merge);\n\n    if (pair instanceof Pair) {\n      var seq = pair.value;\n\n      if (!(seq instanceof YAMLSeq)) {\n        seq = new YAMLSeq();\n        seq.items.push(pair.value);\n        seq.range = pair.value.range;\n      }\n\n      _this = _super.call(this, pair.key, seq);\n      _this.range = pair.range;\n    } else {\n      _this = _super.call(this, new Scalar(MERGE_KEY), new YAMLSeq());\n    }\n\n    _this.type = Pair.Type.MERGE_PAIR;\n    return _possibleConstructorReturn(_this);\n  } // If the value associated with a merge key is a single mapping node, each of\n  // its key/value pairs is inserted into the current mapping, unless the key\n  // already exists in it. If the value associated with the merge key is a\n  // sequence, then this sequence is expected to contain mapping nodes and each\n  // of these nodes is merged in turn according to its order in the sequence.\n  // Keys in mapping nodes earlier in the sequence override keys specified in\n  // later mapping nodes. -- http://yaml.org/type/merge.html\n\n\n  _createClass(Merge, [{\n    key: \"addToJSMap\",\n    value: function addToJSMap(ctx, map) {\n      var _iterator = _createForOfIteratorHelper(this.value.items),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var source = _step.value.source;\n          if (!(source instanceof YAMLMap)) throw new Error('Merge sources must be maps');\n          var srcMap = source.toJSON(null, ctx, Map);\n\n          var _iterator2 = _createForOfIteratorHelper(srcMap),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _step2$value = _slicedToArray(_step2.value, 2),\n                  key = _step2$value[0],\n                  value = _step2$value[1];\n\n              if (map instanceof Map) {\n                if (!map.has(key)) map.set(key, value);\n              } else if (map instanceof Set) {\n                map.add(key);\n              } else if (!Object.prototype.hasOwnProperty.call(map, key)) {\n                Object.defineProperty(map, key, {\n                  value: value,\n                  writable: true,\n                  enumerable: true,\n                  configurable: true\n                });\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return map;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(ctx, onComment) {\n      var seq = this.value;\n      if (seq.items.length > 1) return _get(_getPrototypeOf(Merge.prototype), \"toString\", this).call(this, ctx, onComment);\n      this.value = seq.items[0];\n\n      var str = _get(_getPrototypeOf(Merge.prototype), \"toString\", this).call(this, ctx, onComment);\n\n      this.value = seq;\n      return str;\n    }\n  }]);\n\n  return Merge;\n}(Pair);\n\nvar binaryOptions = {\n  defaultType: Type.BLOCK_LITERAL,\n  lineWidth: 76\n};\nvar boolOptions = {\n  trueStr: 'true',\n  falseStr: 'false'\n};\nvar intOptions = {\n  asBigInt: false\n};\nvar nullOptions = {\n  nullStr: 'null'\n};\nvar strOptions = {\n  defaultType: Type.PLAIN,\n  doubleQuoted: {\n    jsonEncoding: false,\n    minMultiLineLength: 40\n  },\n  fold: {\n    lineWidth: 80,\n    minContentWidth: 20\n  }\n};\n\nfunction resolveScalar(str, tags, scalarFallback) {\n  var _iterator = _createForOfIteratorHelper(tags),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _step.value,\n          format = _step$value.format,\n          test = _step$value.test,\n          resolve = _step$value.resolve;\n\n      if (test) {\n        var match = str.match(test);\n\n        if (match) {\n          var res = resolve.apply(null, match);\n          if (!(res instanceof Scalar)) res = new Scalar(res);\n          if (format) res.format = format;\n          return res;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (scalarFallback) str = scalarFallback(str);\n  return new Scalar(str);\n}\n\nvar FOLD_FLOW = 'flow';\nvar FOLD_BLOCK = 'block';\nvar FOLD_QUOTED = 'quoted'; // presumes i+1 is at the start of a line\n// returns index of last newline in more-indented block\n\nvar consumeMoreIndentedLines = function consumeMoreIndentedLines(text, i) {\n  var ch = text[i + 1];\n\n  while (ch === ' ' || ch === '\\t') {\n    do {\n      ch = text[i += 1];\n    } while (ch && ch !== '\\n');\n\n    ch = text[i + 1];\n  }\n\n  return i;\n};\n/**\n * Tries to keep input at up to `lineWidth` characters, splitting only on spaces\n * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are\n * terminated with `\\n` and started with `indent`.\n *\n * @param {string} text\n * @param {string} indent\n * @param {string} [mode='flow'] `'block'` prevents more-indented lines\n *   from being folded; `'quoted'` allows for `\\` escapes, including escaped\n *   newlines\n * @param {Object} options\n * @param {number} [options.indentAtStart] Accounts for leading contents on\n *   the first line, defaulting to `indent.length`\n * @param {number} [options.lineWidth=80]\n * @param {number} [options.minContentWidth=20] Allow highly indented lines to\n *   stretch the line width or indent content from the start\n * @param {function} options.onFold Called once if the text is folded\n * @param {function} options.onFold Called once if any line of text exceeds\n *   lineWidth characters\n */\n\n\nfunction foldFlowLines(text, indent, mode, _ref) {\n  var indentAtStart = _ref.indentAtStart,\n      _ref$lineWidth = _ref.lineWidth,\n      lineWidth = _ref$lineWidth === void 0 ? 80 : _ref$lineWidth,\n      _ref$minContentWidth = _ref.minContentWidth,\n      minContentWidth = _ref$minContentWidth === void 0 ? 20 : _ref$minContentWidth,\n      onFold = _ref.onFold,\n      onOverflow = _ref.onOverflow;\n  if (!lineWidth || lineWidth < 0) return text;\n  var endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);\n  if (text.length <= endStep) return text;\n  var folds = [];\n  var escapedFolds = {};\n  var end = lineWidth - indent.length;\n\n  if (typeof indentAtStart === 'number') {\n    if (indentAtStart > lineWidth - Math.max(2, minContentWidth)) folds.push(0);else end = lineWidth - indentAtStart;\n  }\n\n  var split = undefined;\n  var prev = undefined;\n  var overflow = false;\n  var i = -1;\n  var escStart = -1;\n  var escEnd = -1;\n\n  if (mode === FOLD_BLOCK) {\n    i = consumeMoreIndentedLines(text, i);\n    if (i !== -1) end = i + endStep;\n  }\n\n  for (var ch; ch = text[i += 1];) {\n    if (mode === FOLD_QUOTED && ch === '\\\\') {\n      escStart = i;\n\n      switch (text[i + 1]) {\n        case 'x':\n          i += 3;\n          break;\n\n        case 'u':\n          i += 5;\n          break;\n\n        case 'U':\n          i += 9;\n          break;\n\n        default:\n          i += 1;\n      }\n\n      escEnd = i;\n    }\n\n    if (ch === '\\n') {\n      if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i);\n      end = i + endStep;\n      split = undefined;\n    } else {\n      if (ch === ' ' && prev && prev !== ' ' && prev !== '\\n' && prev !== '\\t') {\n        // space surrounded by non-space can be replaced with newline + indent\n        var next = text[i + 1];\n        if (next && next !== ' ' && next !== '\\n' && next !== '\\t') split = i;\n      }\n\n      if (i >= end) {\n        if (split) {\n          folds.push(split);\n          end = split + endStep;\n          split = undefined;\n        } else if (mode === FOLD_QUOTED) {\n          // white-space collected at end may stretch past lineWidth\n          while (prev === ' ' || prev === '\\t') {\n            prev = ch;\n            ch = text[i += 1];\n            overflow = true;\n          } // Account for newline escape, but don't break preceding escape\n\n\n          var j = i > escEnd + 1 ? i - 2 : escStart - 1; // Bail out if lineWidth & minContentWidth are shorter than an escape string\n\n          if (escapedFolds[j]) return text;\n          folds.push(j);\n          escapedFolds[j] = true;\n          end = j + endStep;\n          split = undefined;\n        } else {\n          overflow = true;\n        }\n      }\n    }\n\n    prev = ch;\n  }\n\n  if (overflow && onOverflow) onOverflow();\n  if (folds.length === 0) return text;\n  if (onFold) onFold();\n  var res = text.slice(0, folds[0]);\n\n  for (var _i = 0; _i < folds.length; ++_i) {\n    var fold = folds[_i];\n\n    var _end = folds[_i + 1] || text.length;\n\n    if (fold === 0) res = \"\\n\".concat(indent).concat(text.slice(0, _end));else {\n      if (mode === FOLD_QUOTED && escapedFolds[fold]) res += \"\".concat(text[fold], \"\\\\\");\n      res += \"\\n\".concat(indent).concat(text.slice(fold + 1, _end));\n    }\n  }\n\n  return res;\n}\n\nvar getFoldOptions = function getFoldOptions(_ref) {\n  var indentAtStart = _ref.indentAtStart;\n  return indentAtStart ? Object.assign({\n    indentAtStart: indentAtStart\n  }, strOptions.fold) : strOptions.fold;\n}; // Also checks for lines starting with %, as parsing the output as YAML 1.1 will\n// presume that's starting a new document.\n\n\nvar containsDocumentMarker = function containsDocumentMarker(str) {\n  return /^(%|---|\\.\\.\\.)/m.test(str);\n};\n\nfunction lineLengthOverLimit(str, lineWidth, indentLength) {\n  if (!lineWidth || lineWidth < 0) return false;\n  var limit = lineWidth - indentLength;\n  var strLen = str.length;\n  if (strLen <= limit) return false;\n\n  for (var i = 0, start = 0; i < strLen; ++i) {\n    if (str[i] === '\\n') {\n      if (i - start > limit) return true;\n      start = i + 1;\n      if (strLen - start <= limit) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction doubleQuotedString(value, ctx) {\n  var implicitKey = ctx.implicitKey;\n  var _strOptions$doubleQuo = strOptions.doubleQuoted,\n      jsonEncoding = _strOptions$doubleQuo.jsonEncoding,\n      minMultiLineLength = _strOptions$doubleQuo.minMultiLineLength;\n  var json = JSON.stringify(value);\n  if (jsonEncoding) return json;\n  var indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n  var str = '';\n  var start = 0;\n\n  for (var i = 0, ch = json[i]; ch; ch = json[++i]) {\n    if (ch === ' ' && json[i + 1] === '\\\\' && json[i + 2] === 'n') {\n      // space before newline needs to be escaped to not be folded\n      str += json.slice(start, i) + '\\\\ ';\n      i += 1;\n      start = i;\n      ch = '\\\\';\n    }\n\n    if (ch === '\\\\') switch (json[i + 1]) {\n      case 'u':\n        {\n          str += json.slice(start, i);\n          var code = json.substr(i + 2, 4);\n\n          switch (code) {\n            case '0000':\n              str += '\\\\0';\n              break;\n\n            case '0007':\n              str += '\\\\a';\n              break;\n\n            case '000b':\n              str += '\\\\v';\n              break;\n\n            case '001b':\n              str += '\\\\e';\n              break;\n\n            case '0085':\n              str += '\\\\N';\n              break;\n\n            case '00a0':\n              str += '\\\\_';\n              break;\n\n            case '2028':\n              str += '\\\\L';\n              break;\n\n            case '2029':\n              str += '\\\\P';\n              break;\n\n            default:\n              if (code.substr(0, 2) === '00') str += '\\\\x' + code.substr(2);else str += json.substr(i, 6);\n          }\n\n          i += 5;\n          start = i + 1;\n        }\n        break;\n\n      case 'n':\n        if (implicitKey || json[i + 2] === '\"' || json.length < minMultiLineLength) {\n          i += 1;\n        } else {\n          // folding will eat first newline\n          str += json.slice(start, i) + '\\n\\n';\n\n          while (json[i + 2] === '\\\\' && json[i + 3] === 'n' && json[i + 4] !== '\"') {\n            str += '\\n';\n            i += 2;\n          }\n\n          str += indent; // space after newline needs to be escaped to not be folded\n\n          if (json[i + 2] === ' ') str += '\\\\';\n          i += 1;\n          start = i + 1;\n        }\n\n        break;\n\n      default:\n        i += 1;\n    }\n  }\n\n  str = start ? str + json.slice(start) : json;\n  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));\n}\n\nfunction singleQuotedString(value, ctx) {\n  if (ctx.implicitKey) {\n    if (/\\n/.test(value)) return doubleQuotedString(value, ctx);\n  } else {\n    // single quoted string can't have leading or trailing whitespace around newline\n    if (/[ \\t]\\n|\\n[ \\t]/.test(value)) return doubleQuotedString(value, ctx);\n  }\n\n  var indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n  var res = \"'\" + value.replace(/'/g, \"''\").replace(/\\n+/g, \"$&\\n\".concat(indent)) + \"'\";\n  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));\n}\n\nfunction blockString(_ref2, ctx, onComment, onChompKeep) {\n  var comment = _ref2.comment,\n      type = _ref2.type,\n      value = _ref2.value;\n\n  // 1. Block can't end in whitespace unless the last line is non-empty.\n  // 2. Strings consisting of only whitespace are best rendered explicitly.\n  if (/\\n[\\t ]+$/.test(value) || /^\\s*$/.test(value)) {\n    return doubleQuotedString(value, ctx);\n  }\n\n  var indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');\n  var indentSize = indent ? '2' : '1'; // root is at -1\n\n  var literal = type === Type.BLOCK_FOLDED ? false : type === Type.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, strOptions.fold.lineWidth, indent.length);\n  var header = literal ? '|' : '>';\n  if (!value) return header + '\\n';\n  var wsStart = '';\n  var wsEnd = '';\n  value = value.replace(/[\\n\\t ]*$/, function (ws) {\n    var n = ws.indexOf('\\n');\n\n    if (n === -1) {\n      header += '-'; // strip\n    } else if (value === ws || n !== ws.length - 1) {\n      header += '+'; // keep\n\n      if (onChompKeep) onChompKeep();\n    }\n\n    wsEnd = ws.replace(/\\n$/, '');\n    return '';\n  }).replace(/^[\\n ]*/, function (ws) {\n    if (ws.indexOf(' ') !== -1) header += indentSize;\n    var m = ws.match(/ +$/);\n\n    if (m) {\n      wsStart = ws.slice(0, -m[0].length);\n      return m[0];\n    } else {\n      wsStart = ws;\n      return '';\n    }\n  });\n  if (wsEnd) wsEnd = wsEnd.replace(/\\n+(?!\\n|$)/g, \"$&\".concat(indent));\n  if (wsStart) wsStart = wsStart.replace(/\\n+/g, \"$&\".concat(indent));\n\n  if (comment) {\n    header += ' #' + comment.replace(/ ?[\\r\\n]+/g, ' ');\n    if (onComment) onComment();\n  }\n\n  if (!value) return \"\".concat(header).concat(indentSize, \"\\n\").concat(indent).concat(wsEnd);\n\n  if (literal) {\n    value = value.replace(/\\n+/g, \"$&\".concat(indent));\n    return \"\".concat(header, \"\\n\").concat(indent).concat(wsStart).concat(value).concat(wsEnd);\n  }\n\n  value = value.replace(/\\n+/g, '\\n$&').replace(/(?:^|\\n)([\\t ].*)(?:([\\n\\t ]*)\\n(?![\\n\\t ]))?/g, '$1$2') // more-indented lines aren't folded\n  //         ^ ind.line  ^ empty     ^ capture next empty lines only at end of indent\n  .replace(/\\n+/g, \"$&\".concat(indent));\n  var body = foldFlowLines(\"\".concat(wsStart).concat(value).concat(wsEnd), indent, FOLD_BLOCK, strOptions.fold);\n  return \"\".concat(header, \"\\n\").concat(indent).concat(body);\n}\n\nfunction plainString(item, ctx, onComment, onChompKeep) {\n  var comment = item.comment,\n      type = item.type,\n      value = item.value;\n  var actualString = ctx.actualString,\n      implicitKey = ctx.implicitKey,\n      indent = ctx.indent,\n      inFlow = ctx.inFlow;\n\n  if (implicitKey && /[\\n[\\]{},]/.test(value) || inFlow && /[[\\]{},]/.test(value)) {\n    return doubleQuotedString(value, ctx);\n  }\n\n  if (!value || /^[\\n\\t ,[\\]{}#&*!|>'\"%@`]|^[?-]$|^[?-][ \\t]|[\\n:][ \\t]|[ \\t]\\n|[\\n\\t ]#|[\\n\\t :]$/.test(value)) {\n    // not allowed:\n    // - empty string, '-' or '?'\n    // - start with an indicator character (except [?:-]) or /[?-] /\n    // - '\\n ', ': ' or ' \\n' anywhere\n    // - '#' not preceded by a non-space char\n    // - end with ' ' or ':'\n    return implicitKey || inFlow || value.indexOf('\\n') === -1 ? value.indexOf('\"') !== -1 && value.indexOf(\"'\") === -1 ? singleQuotedString(value, ctx) : doubleQuotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  if (!implicitKey && !inFlow && type !== Type.PLAIN && value.indexOf('\\n') !== -1) {\n    // Where allowed & type not set explicitly, prefer block style for multiline strings\n    return blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  if (indent === '' && containsDocumentMarker(value)) {\n    ctx.forceBlockIndent = true;\n    return blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  var str = value.replace(/\\n+/g, \"$&\\n\".concat(indent)); // Verify that output will be parsed as a string, as e.g. plain numbers and\n  // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),\n  // and others in v1.1.\n\n  if (actualString) {\n    var tags = ctx.doc.schema.tags;\n    var resolved = resolveScalar(str, tags, tags.scalarFallback).value;\n    if (typeof resolved !== 'string') return doubleQuotedString(value, ctx);\n  }\n\n  var body = implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));\n\n  if (comment && !inFlow && (body.indexOf('\\n') !== -1 || comment.indexOf('\\n') !== -1)) {\n    if (onComment) onComment();\n    return addCommentBefore(body, indent, comment);\n  }\n\n  return body;\n}\n\nfunction stringifyString(item, ctx, onComment, onChompKeep) {\n  var defaultType = strOptions.defaultType;\n  var implicitKey = ctx.implicitKey,\n      inFlow = ctx.inFlow;\n  var _item = item,\n      type = _item.type,\n      value = _item.value;\n\n  if (typeof value !== 'string') {\n    value = String(value);\n    item = Object.assign({}, item, {\n      value: value\n    });\n  }\n\n  var _stringify = function _stringify(_type) {\n    switch (_type) {\n      case Type.BLOCK_FOLDED:\n      case Type.BLOCK_LITERAL:\n        return blockString(item, ctx, onComment, onChompKeep);\n\n      case Type.QUOTE_DOUBLE:\n        return doubleQuotedString(value, ctx);\n\n      case Type.QUOTE_SINGLE:\n        return singleQuotedString(value, ctx);\n\n      case Type.PLAIN:\n        return plainString(item, ctx, onComment, onChompKeep);\n\n      default:\n        return null;\n    }\n  };\n\n  if (type !== Type.QUOTE_DOUBLE && /[\\x00-\\x08\\x0b-\\x1f\\x7f-\\x9f]/.test(value)) {\n    // force double quotes on control characters\n    type = Type.QUOTE_DOUBLE;\n  } else if ((implicitKey || inFlow) && (type === Type.BLOCK_FOLDED || type === Type.BLOCK_LITERAL)) {\n    // should not happen; blocks are not valid inside flow containers\n    type = Type.QUOTE_DOUBLE;\n  }\n\n  var res = _stringify(type);\n\n  if (res === null) {\n    res = _stringify(defaultType);\n    if (res === null) throw new Error(\"Unsupported default string type \".concat(defaultType));\n  }\n\n  return res;\n}\n\nfunction stringifyNumber(_ref) {\n  var format = _ref.format,\n      minFractionDigits = _ref.minFractionDigits,\n      tag = _ref.tag,\n      value = _ref.value;\n  if (typeof value === 'bigint') return String(value);\n  if (!isFinite(value)) return isNaN(value) ? '.nan' : value < 0 ? '-.inf' : '.inf';\n  var n = JSON.stringify(value);\n\n  if (!format && minFractionDigits && (!tag || tag === 'tag:yaml.org,2002:float') && /^\\d/.test(n)) {\n    var i = n.indexOf('.');\n\n    if (i < 0) {\n      i = n.length;\n      n += '.';\n    }\n\n    var d = minFractionDigits - (n.length - i - 1);\n\n    while (d-- > 0) {\n      n += '0';\n    }\n  }\n\n  return n;\n}\n\nfunction checkFlowCollectionEnd(errors, cst) {\n  var char, name;\n\n  switch (cst.type) {\n    case Type.FLOW_MAP:\n      char = '}';\n      name = 'flow map';\n      break;\n\n    case Type.FLOW_SEQ:\n      char = ']';\n      name = 'flow sequence';\n      break;\n\n    default:\n      errors.push(new YAMLSemanticError(cst, 'Not a flow collection!?'));\n      return;\n  }\n\n  var lastItem;\n\n  for (var i = cst.items.length - 1; i >= 0; --i) {\n    var item = cst.items[i];\n\n    if (!item || item.type !== Type.COMMENT) {\n      lastItem = item;\n      break;\n    }\n  }\n\n  if (lastItem && lastItem.char !== char) {\n    var msg = \"Expected \".concat(name, \" to end with \").concat(char);\n    var err;\n\n    if (typeof lastItem.offset === 'number') {\n      err = new YAMLSemanticError(cst, msg);\n      err.offset = lastItem.offset + 1;\n    } else {\n      err = new YAMLSemanticError(lastItem, msg);\n      if (lastItem.range && lastItem.range.end) err.offset = lastItem.range.end - lastItem.range.start;\n    }\n\n    errors.push(err);\n  }\n}\nfunction checkFlowCommentSpace(errors, comment) {\n  var prev = comment.context.src[comment.range.start - 1];\n\n  if (prev !== '\\n' && prev !== '\\t' && prev !== ' ') {\n    var msg = 'Comments must be separated from other tokens by white space characters';\n    errors.push(new YAMLSemanticError(comment, msg));\n  }\n}\nfunction getLongKeyError(source, key) {\n  var sk = String(key);\n  var k = sk.substr(0, 8) + '...' + sk.substr(-8);\n  return new YAMLSemanticError(source, \"The \\\"\".concat(k, \"\\\" key is too long\"));\n}\nfunction resolveComments(collection, comments) {\n  var _iterator = _createForOfIteratorHelper(comments),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _step.value,\n          afterKey = _step$value.afterKey,\n          before = _step$value.before,\n          comment = _step$value.comment;\n      var item = collection.items[before];\n\n      if (!item) {\n        if (comment !== undefined) {\n          if (collection.comment) collection.comment += '\\n' + comment;else collection.comment = comment;\n        }\n      } else {\n        if (afterKey && item.value) item = item.value;\n\n        if (comment === undefined) {\n          if (afterKey || !item.commentBefore) item.spaceBefore = true;\n        } else {\n          if (item.commentBefore) item.commentBefore += '\\n' + comment;else item.commentBefore = comment;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\n\n// on error, will return { str: string, errors: Error[] }\nfunction resolveString(doc, node) {\n  var res = node.strValue;\n  if (!res) return '';\n  if (typeof res === 'string') return res;\n  res.errors.forEach(function (error) {\n    if (!error.source) error.source = node;\n    doc.errors.push(error);\n  });\n  return res.str;\n}\n\nfunction resolveTagHandle(doc, node) {\n  var _node$tag = node.tag,\n      handle = _node$tag.handle,\n      suffix = _node$tag.suffix;\n  var prefix = doc.tagPrefixes.find(function (p) {\n    return p.handle === handle;\n  });\n\n  if (!prefix) {\n    var dtp = doc.getDefaults().tagPrefixes;\n    if (dtp) prefix = dtp.find(function (p) {\n      return p.handle === handle;\n    });\n    if (!prefix) throw new YAMLSemanticError(node, \"The \".concat(handle, \" tag handle is non-default and was not declared.\"));\n  }\n\n  if (!suffix) throw new YAMLSemanticError(node, \"The \".concat(handle, \" tag has no suffix.\"));\n\n  if (handle === '!' && (doc.version || doc.options.version) === '1.0') {\n    if (suffix[0] === '^') {\n      doc.warnings.push(new YAMLWarning(node, 'YAML 1.0 ^ tag expansion is not supported'));\n      return suffix;\n    }\n\n    if (/[:/]/.test(suffix)) {\n      // word/foo -> tag:word.yaml.org,2002:foo\n      var vocab = suffix.match(/^([a-z0-9-]+)\\/(.*)/i);\n      return vocab ? \"tag:\".concat(vocab[1], \".yaml.org,2002:\").concat(vocab[2]) : \"tag:\".concat(suffix);\n    }\n  }\n\n  return prefix.prefix + decodeURIComponent(suffix);\n}\n\nfunction resolveTagName(doc, node) {\n  var tag = node.tag,\n      type = node.type;\n  var nonSpecific = false;\n\n  if (tag) {\n    var handle = tag.handle,\n        suffix = tag.suffix,\n        verbatim = tag.verbatim;\n\n    if (verbatim) {\n      if (verbatim !== '!' && verbatim !== '!!') return verbatim;\n      var msg = \"Verbatim tags aren't resolved, so \".concat(verbatim, \" is invalid.\");\n      doc.errors.push(new YAMLSemanticError(node, msg));\n    } else if (handle === '!' && !suffix) {\n      nonSpecific = true;\n    } else {\n      try {\n        return resolveTagHandle(doc, node);\n      } catch (error) {\n        doc.errors.push(error);\n      }\n    }\n  }\n\n  switch (type) {\n    case Type.BLOCK_FOLDED:\n    case Type.BLOCK_LITERAL:\n    case Type.QUOTE_DOUBLE:\n    case Type.QUOTE_SINGLE:\n      return defaultTags.STR;\n\n    case Type.FLOW_MAP:\n    case Type.MAP:\n      return defaultTags.MAP;\n\n    case Type.FLOW_SEQ:\n    case Type.SEQ:\n      return defaultTags.SEQ;\n\n    case Type.PLAIN:\n      return nonSpecific ? defaultTags.STR : null;\n\n    default:\n      return null;\n  }\n}\n\nfunction resolveByTagName(doc, node, tagName) {\n  var tags = doc.schema.tags;\n  var matchWithTest = [];\n\n  var _iterator = _createForOfIteratorHelper(tags),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var tag = _step.value;\n\n      if (tag.tag === tagName) {\n        if (tag.test) matchWithTest.push(tag);else {\n          var res = tag.resolve(doc, node);\n          return res instanceof Collection ? res : new Scalar(res);\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var str = resolveString(doc, node);\n  if (typeof str === 'string' && matchWithTest.length > 0) return resolveScalar(str, matchWithTest, tags.scalarFallback);\n  return null;\n}\n\nfunction getFallbackTagName(_ref) {\n  var type = _ref.type;\n\n  switch (type) {\n    case Type.FLOW_MAP:\n    case Type.MAP:\n      return defaultTags.MAP;\n\n    case Type.FLOW_SEQ:\n    case Type.SEQ:\n      return defaultTags.SEQ;\n\n    default:\n      return defaultTags.STR;\n  }\n}\n\nfunction resolveTag(doc, node, tagName) {\n  try {\n    var res = resolveByTagName(doc, node, tagName);\n\n    if (res) {\n      if (tagName && node.tag) res.tag = tagName;\n      return res;\n    }\n  } catch (error) {\n    /* istanbul ignore if */\n    if (!error.source) error.source = node;\n    doc.errors.push(error);\n    return null;\n  }\n\n  try {\n    var fallback = getFallbackTagName(node);\n    if (!fallback) throw new Error(\"The tag \".concat(tagName, \" is unavailable\"));\n    var msg = \"The tag \".concat(tagName, \" is unavailable, falling back to \").concat(fallback);\n    doc.warnings.push(new YAMLWarning(node, msg));\n\n    var _res = resolveByTagName(doc, node, fallback);\n\n    _res.tag = tagName;\n    return _res;\n  } catch (error) {\n    var refError = new YAMLReferenceError(node, error.message);\n    refError.stack = error.stack;\n    doc.errors.push(refError);\n    return null;\n  }\n}\n\nvar isCollectionItem = function isCollectionItem(node) {\n  if (!node) return false;\n  var type = node.type;\n  return type === Type.MAP_KEY || type === Type.MAP_VALUE || type === Type.SEQ_ITEM;\n};\n\nfunction resolveNodeProps(errors, node) {\n  var comments = {\n    before: [],\n    after: []\n  };\n  var hasAnchor = false;\n  var hasTag = false;\n  var props = isCollectionItem(node.context.parent) ? node.context.parent.props.concat(node.props) : node.props;\n\n  var _iterator = _createForOfIteratorHelper(props),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _step.value,\n          start = _step$value.start,\n          end = _step$value.end;\n\n      switch (node.context.src[start]) {\n        case Char.COMMENT:\n          {\n            if (!node.commentHasRequiredWhitespace(start)) {\n              var msg = 'Comments must be separated from other tokens by white space characters';\n              errors.push(new YAMLSemanticError(node, msg));\n            }\n\n            var header = node.header,\n                valueRange = node.valueRange;\n            var cc = valueRange && (start > valueRange.start || header && start > header.start) ? comments.after : comments.before;\n            cc.push(node.context.src.slice(start + 1, end));\n            break;\n          }\n        // Actual anchor & tag resolution is handled by schema, here we just complain\n\n        case Char.ANCHOR:\n          if (hasAnchor) {\n            var _msg = 'A node can have at most one anchor';\n            errors.push(new YAMLSemanticError(node, _msg));\n          }\n\n          hasAnchor = true;\n          break;\n\n        case Char.TAG:\n          if (hasTag) {\n            var _msg2 = 'A node can have at most one tag';\n            errors.push(new YAMLSemanticError(node, _msg2));\n          }\n\n          hasTag = true;\n          break;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return {\n    comments: comments,\n    hasAnchor: hasAnchor,\n    hasTag: hasTag\n  };\n}\n\nfunction resolveNodeValue(doc, node) {\n  var anchors = doc.anchors,\n      errors = doc.errors,\n      schema = doc.schema;\n\n  if (node.type === Type.ALIAS) {\n    var name = node.rawValue;\n    var src = anchors.getNode(name);\n\n    if (!src) {\n      var msg = \"Aliased anchor not found: \".concat(name);\n      errors.push(new YAMLReferenceError(node, msg));\n      return null;\n    } // Lazy resolution for circular references\n\n\n    var res = new Alias(src);\n\n    anchors._cstAliases.push(res);\n\n    return res;\n  }\n\n  var tagName = resolveTagName(doc, node);\n  if (tagName) return resolveTag(doc, node, tagName);\n\n  if (node.type !== Type.PLAIN) {\n    var _msg3 = \"Failed to resolve \".concat(node.type, \" node here\");\n\n    errors.push(new YAMLSyntaxError(node, _msg3));\n    return null;\n  }\n\n  try {\n    var str = resolveString(doc, node);\n    return resolveScalar(str, schema.tags, schema.tags.scalarFallback);\n  } catch (error) {\n    if (!error.source) error.source = node;\n    errors.push(error);\n    return null;\n  }\n} // sets node.resolved on success\n\n\nfunction resolveNode(doc, node) {\n  if (!node) return null;\n  if (node.error) doc.errors.push(node.error);\n\n  var _resolveNodeProps = resolveNodeProps(doc.errors, node),\n      comments = _resolveNodeProps.comments,\n      hasAnchor = _resolveNodeProps.hasAnchor,\n      hasTag = _resolveNodeProps.hasTag;\n\n  if (hasAnchor) {\n    var anchors = doc.anchors;\n    var name = node.anchor;\n    var prev = anchors.getNode(name); // At this point, aliases for any preceding node with the same anchor\n    // name have already been resolved, so it may safely be renamed.\n\n    if (prev) anchors.map[anchors.newName(name)] = prev; // During parsing, we need to store the CST node in anchors.map as\n    // anchors need to be available during resolution to allow for\n    // circular references.\n\n    anchors.map[name] = node;\n  }\n\n  if (node.type === Type.ALIAS && (hasAnchor || hasTag)) {\n    var msg = 'An alias node must not specify any properties';\n    doc.errors.push(new YAMLSemanticError(node, msg));\n  }\n\n  var res = resolveNodeValue(doc, node);\n\n  if (res) {\n    res.range = [node.range.start, node.range.end];\n    if (doc.options.keepCstNodes) res.cstNode = node;\n    if (doc.options.keepNodeTypes) res.type = node.type;\n    var cb = comments.before.join('\\n');\n\n    if (cb) {\n      res.commentBefore = res.commentBefore ? \"\".concat(res.commentBefore, \"\\n\").concat(cb) : cb;\n    }\n\n    var ca = comments.after.join('\\n');\n    if (ca) res.comment = res.comment ? \"\".concat(res.comment, \"\\n\").concat(ca) : ca;\n  }\n\n  return node.resolved = res;\n}\n\nfunction resolveMap(doc, cst) {\n  if (cst.type !== Type.MAP && cst.type !== Type.FLOW_MAP) {\n    var msg = \"A \".concat(cst.type, \" node cannot be resolved as a mapping\");\n    doc.errors.push(new YAMLSyntaxError(cst, msg));\n    return null;\n  }\n\n  var _ref = cst.type === Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst),\n      comments = _ref.comments,\n      items = _ref.items;\n\n  var map = new YAMLMap();\n  map.items = items;\n  resolveComments(map, comments);\n  var hasCollectionKey = false;\n\n  for (var i = 0; i < items.length; ++i) {\n    var iKey = items[i].key;\n    if (iKey instanceof Collection) hasCollectionKey = true;\n\n    if (doc.schema.merge && iKey && iKey.value === MERGE_KEY) {\n      items[i] = new Merge(items[i]);\n      var sources = items[i].value.items;\n      var error = null;\n      sources.some(function (node) {\n        if (node instanceof Alias) {\n          // During parsing, alias sources are CST nodes; to account for\n          // circular references their resolved values can't be used here.\n          var type = node.source.type;\n          if (type === Type.MAP || type === Type.FLOW_MAP) return false;\n          return error = 'Merge nodes aliases can only point to maps';\n        }\n\n        return error = 'Merge nodes can only have Alias nodes as values';\n      });\n      if (error) doc.errors.push(new YAMLSemanticError(cst, error));\n    } else {\n      for (var j = i + 1; j < items.length; ++j) {\n        var jKey = items[j].key;\n\n        if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, 'value') && iKey.value === jKey.value) {\n          var _msg = \"Map keys must be unique; \\\"\".concat(iKey, \"\\\" is repeated\");\n\n          doc.errors.push(new YAMLSemanticError(cst, _msg));\n          break;\n        }\n      }\n    }\n  }\n\n  if (hasCollectionKey && !doc.options.mapAsMap) {\n    var warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';\n    doc.warnings.push(new YAMLWarning(cst, warn));\n  }\n\n  cst.resolved = map;\n  return map;\n}\n\nvar valueHasPairComment = function valueHasPairComment(_ref2) {\n  var _ref2$context = _ref2.context,\n      lineStart = _ref2$context.lineStart,\n      node = _ref2$context.node,\n      src = _ref2$context.src,\n      props = _ref2.props;\n  if (props.length === 0) return false;\n  var start = props[0].start;\n  if (node && start > node.valueRange.start) return false;\n  if (src[start] !== Char.COMMENT) return false;\n\n  for (var i = lineStart; i < start; ++i) {\n    if (src[i] === '\\n') return false;\n  }\n\n  return true;\n};\n\nfunction resolvePairComment(item, pair) {\n  if (!valueHasPairComment(item)) return;\n  var comment = item.getPropValue(0, Char.COMMENT, true);\n  var found = false;\n  var cb = pair.value.commentBefore;\n\n  if (cb && cb.startsWith(comment)) {\n    pair.value.commentBefore = cb.substr(comment.length + 1);\n    found = true;\n  } else {\n    var cc = pair.value.comment;\n\n    if (!item.node && cc && cc.startsWith(comment)) {\n      pair.value.comment = cc.substr(comment.length + 1);\n      found = true;\n    }\n  }\n\n  if (found) pair.comment = comment;\n}\n\nfunction resolveBlockMapItems(doc, cst) {\n  var comments = [];\n  var items = [];\n  var key = undefined;\n  var keyStart = null;\n\n  for (var i = 0; i < cst.items.length; ++i) {\n    var item = cst.items[i];\n\n    switch (item.type) {\n      case Type.BLANK_LINE:\n        comments.push({\n          afterKey: !!key,\n          before: items.length\n        });\n        break;\n\n      case Type.COMMENT:\n        comments.push({\n          afterKey: !!key,\n          before: items.length,\n          comment: item.comment\n        });\n        break;\n\n      case Type.MAP_KEY:\n        if (key !== undefined) items.push(new Pair(key));\n        if (item.error) doc.errors.push(item.error);\n        key = resolveNode(doc, item.node);\n        keyStart = null;\n        break;\n\n      case Type.MAP_VALUE:\n        {\n          if (key === undefined) key = null;\n          if (item.error) doc.errors.push(item.error);\n\n          if (!item.context.atLineStart && item.node && item.node.type === Type.MAP && !item.node.context.atLineStart) {\n            var msg = 'Nested mappings are not allowed in compact mappings';\n            doc.errors.push(new YAMLSemanticError(item.node, msg));\n          }\n\n          var valueNode = item.node;\n\n          if (!valueNode && item.props.length > 0) {\n            // Comments on an empty mapping value need to be preserved, so we\n            // need to construct a minimal empty node here to use instead of the\n            // missing `item.node`. -- eemeli/yaml#19\n            valueNode = new PlainValue(Type.PLAIN, []);\n            valueNode.context = {\n              parent: item,\n              src: item.context.src\n            };\n            var pos = item.range.start + 1;\n            valueNode.range = {\n              start: pos,\n              end: pos\n            };\n            valueNode.valueRange = {\n              start: pos,\n              end: pos\n            };\n\n            if (typeof item.range.origStart === 'number') {\n              var origPos = item.range.origStart + 1;\n              valueNode.range.origStart = valueNode.range.origEnd = origPos;\n              valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;\n            }\n          }\n\n          var pair = new Pair(key, resolveNode(doc, valueNode));\n          resolvePairComment(item, pair);\n          items.push(pair);\n\n          if (key && typeof keyStart === 'number') {\n            if (item.range.start > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));\n          }\n\n          key = undefined;\n          keyStart = null;\n        }\n        break;\n\n      default:\n        if (key !== undefined) items.push(new Pair(key));\n        key = resolveNode(doc, item);\n        keyStart = item.range.start;\n        if (item.error) doc.errors.push(item.error);\n\n        next: for (var j = i + 1;; ++j) {\n          var nextItem = cst.items[j];\n\n          switch (nextItem && nextItem.type) {\n            case Type.BLANK_LINE:\n            case Type.COMMENT:\n              continue next;\n\n            case Type.MAP_VALUE:\n              break next;\n\n            default:\n              {\n                var _msg2 = 'Implicit map keys need to be followed by map values';\n                doc.errors.push(new YAMLSemanticError(item, _msg2));\n                break next;\n              }\n          }\n        }\n\n        if (item.valueRangeContainsNewline) {\n          var _msg3 = 'Implicit map keys need to be on a single line';\n          doc.errors.push(new YAMLSemanticError(item, _msg3));\n        }\n\n    }\n  }\n\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments: comments,\n    items: items\n  };\n}\n\nfunction resolveFlowMapItems(doc, cst) {\n  var comments = [];\n  var items = [];\n  var key = undefined;\n  var explicitKey = false;\n  var next = '{';\n\n  for (var i = 0; i < cst.items.length; ++i) {\n    var item = cst.items[i];\n\n    if (typeof item.char === 'string') {\n      var char = item.char,\n          offset = item.offset;\n\n      if (char === '?' && key === undefined && !explicitKey) {\n        explicitKey = true;\n        next = ':';\n        continue;\n      }\n\n      if (char === ':') {\n        if (key === undefined) key = null;\n\n        if (next === ':') {\n          next = ',';\n          continue;\n        }\n      } else {\n        if (explicitKey) {\n          if (key === undefined && char !== ',') key = null;\n          explicitKey = false;\n        }\n\n        if (key !== undefined) {\n          items.push(new Pair(key));\n          key = undefined;\n\n          if (char === ',') {\n            next = ':';\n            continue;\n          }\n        }\n      }\n\n      if (char === '}') {\n        if (i === cst.items.length - 1) continue;\n      } else if (char === next) {\n        next = ':';\n        continue;\n      }\n\n      var msg = \"Flow map contains an unexpected \".concat(char);\n      var err = new YAMLSyntaxError(cst, msg);\n      err.offset = offset;\n      doc.errors.push(err);\n    } else if (item.type === Type.BLANK_LINE) {\n      comments.push({\n        afterKey: !!key,\n        before: items.length\n      });\n    } else if (item.type === Type.COMMENT) {\n      checkFlowCommentSpace(doc.errors, item);\n      comments.push({\n        afterKey: !!key,\n        before: items.length,\n        comment: item.comment\n      });\n    } else if (key === undefined) {\n      if (next === ',') doc.errors.push(new YAMLSemanticError(item, 'Separator , missing in flow map'));\n      key = resolveNode(doc, item);\n    } else {\n      if (next !== ',') doc.errors.push(new YAMLSemanticError(item, 'Indicator : missing in flow map entry'));\n      items.push(new Pair(key, resolveNode(doc, item)));\n      key = undefined;\n      explicitKey = false;\n    }\n  }\n\n  checkFlowCollectionEnd(doc.errors, cst);\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments: comments,\n    items: items\n  };\n}\n\nfunction resolveSeq(doc, cst) {\n  if (cst.type !== Type.SEQ && cst.type !== Type.FLOW_SEQ) {\n    var msg = \"A \".concat(cst.type, \" node cannot be resolved as a sequence\");\n    doc.errors.push(new YAMLSyntaxError(cst, msg));\n    return null;\n  }\n\n  var _ref = cst.type === Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst),\n      comments = _ref.comments,\n      items = _ref.items;\n\n  var seq = new YAMLSeq();\n  seq.items = items;\n  resolveComments(seq, comments);\n\n  if (!doc.options.mapAsMap && items.some(function (it) {\n    return it instanceof Pair && it.key instanceof Collection;\n  })) {\n    var warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';\n    doc.warnings.push(new YAMLWarning(cst, warn));\n  }\n\n  cst.resolved = seq;\n  return seq;\n}\n\nfunction resolveBlockSeqItems(doc, cst) {\n  var comments = [];\n  var items = [];\n\n  for (var i = 0; i < cst.items.length; ++i) {\n    var item = cst.items[i];\n\n    switch (item.type) {\n      case Type.BLANK_LINE:\n        comments.push({\n          before: items.length\n        });\n        break;\n\n      case Type.COMMENT:\n        comments.push({\n          comment: item.comment,\n          before: items.length\n        });\n        break;\n\n      case Type.SEQ_ITEM:\n        if (item.error) doc.errors.push(item.error);\n        items.push(resolveNode(doc, item.node));\n\n        if (item.hasProps) {\n          var msg = 'Sequence items cannot have tags or anchors before the - indicator';\n          doc.errors.push(new YAMLSemanticError(item, msg));\n        }\n\n        break;\n\n      default:\n        if (item.error) doc.errors.push(item.error);\n        doc.errors.push(new YAMLSyntaxError(item, \"Unexpected \".concat(item.type, \" node in sequence\")));\n    }\n  }\n\n  return {\n    comments: comments,\n    items: items\n  };\n}\n\nfunction resolveFlowSeqItems(doc, cst) {\n  var comments = [];\n  var items = [];\n  var explicitKey = false;\n  var key = undefined;\n  var keyStart = null;\n  var next = '[';\n  var prevItem = null;\n\n  for (var i = 0; i < cst.items.length; ++i) {\n    var item = cst.items[i];\n\n    if (typeof item.char === 'string') {\n      var char = item.char,\n          offset = item.offset;\n\n      if (char !== ':' && (explicitKey || key !== undefined)) {\n        if (explicitKey && key === undefined) key = next ? items.pop() : null;\n        items.push(new Pair(key));\n        explicitKey = false;\n        key = undefined;\n        keyStart = null;\n      }\n\n      if (char === next) {\n        next = null;\n      } else if (!next && char === '?') {\n        explicitKey = true;\n      } else if (next !== '[' && char === ':' && key === undefined) {\n        if (next === ',') {\n          key = items.pop();\n\n          if (key instanceof Pair) {\n            var msg = 'Chaining flow sequence pairs is invalid';\n            var err = new YAMLSemanticError(cst, msg);\n            err.offset = offset;\n            doc.errors.push(err);\n          }\n\n          if (!explicitKey && typeof keyStart === 'number') {\n            var keyEnd = item.range ? item.range.start : item.offset;\n            if (keyEnd > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));\n            var src = prevItem.context.src;\n\n            for (var _i = keyStart; _i < keyEnd; ++_i) {\n              if (src[_i] === '\\n') {\n                var _msg = 'Implicit keys of flow sequence pairs need to be on a single line';\n                doc.errors.push(new YAMLSemanticError(prevItem, _msg));\n                break;\n              }\n            }\n          }\n        } else {\n          key = null;\n        }\n\n        keyStart = null;\n        explicitKey = false;\n        next = null;\n      } else if (next === '[' || char !== ']' || i < cst.items.length - 1) {\n        var _msg2 = \"Flow sequence contains an unexpected \".concat(char);\n\n        var _err = new YAMLSyntaxError(cst, _msg2);\n\n        _err.offset = offset;\n        doc.errors.push(_err);\n      }\n    } else if (item.type === Type.BLANK_LINE) {\n      comments.push({\n        before: items.length\n      });\n    } else if (item.type === Type.COMMENT) {\n      checkFlowCommentSpace(doc.errors, item);\n      comments.push({\n        comment: item.comment,\n        before: items.length\n      });\n    } else {\n      if (next) {\n        var _msg3 = \"Expected a \".concat(next, \" in flow sequence\");\n\n        doc.errors.push(new YAMLSemanticError(item, _msg3));\n      }\n\n      var value = resolveNode(doc, item);\n\n      if (key === undefined) {\n        items.push(value);\n        prevItem = item;\n      } else {\n        items.push(new Pair(key, value));\n        key = undefined;\n      }\n\n      keyStart = item.range.start;\n      next = ',';\n    }\n  }\n\n  checkFlowCollectionEnd(doc.errors, cst);\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments: comments,\n    items: items\n  };\n}\n\nexport { Alias as A, Collection as C, Merge as M, Node as N, Pair as P, Scalar as S, YAMLSeq as Y, boolOptions as a, binaryOptions as b, stringifyString as c, YAMLMap as d, isEmptyPath as e, addComment as f, resolveMap as g, resolveSeq as h, intOptions as i, resolveString as j, stringifyNumber as k, findPair as l, nullOptions as n, resolveNode as r, strOptions as s, toJSON as t };\n", "import { o as YAMLReferenceError, T as Type, g as YAMLSemanticError, _ as _createForOfIteratorHelper, e as _defineProperty, j as _inherits, k as _createSuper, c as _classCallCheck, p as _assertThisInitialized, b as _createClass, a as _typeof, l as _get, m as _getPrototypeOf } from './PlainValue-b8036b75.js';\nimport { j as resolveString, b as binaryOptions, c as stringifyString, h as resolveSeq, P as Pair, d as YAMLMap, Y as YAMLSeq, t as toJSON, S as Scalar, l as findPair, g as resolveMap, k as stringifyNumber } from './resolveSeq-492ab440.js';\n\n/* global atob, btoa, Buffer */\nvar binary = {\n  identify: function identify(value) {\n    return value instanceof Uint8Array;\n  },\n  // Buffer inherits from Uint8Array\n  default: false,\n  tag: 'tag:yaml.org,2002:binary',\n\n  /**\n   * Returns a Buffer in node and an Uint8Array in browsers\n   *\n   * To use the resulting buffer as an image, you'll want to do something like:\n   *\n   *   const blob = new Blob([buffer], { type: 'image/jpeg' })\n   *   document.querySelector('#photo').src = URL.createObjectURL(blob)\n   */\n  resolve: function resolve(doc, node) {\n    var src = resolveString(doc, node);\n\n    if (typeof Buffer === 'function') {\n      return Buffer.from(src, 'base64');\n    } else if (typeof atob === 'function') {\n      // On IE 11, atob() can't handle newlines\n      var str = atob(src.replace(/[\\n\\r]/g, ''));\n      var buffer = new Uint8Array(str.length);\n\n      for (var i = 0; i < str.length; ++i) {\n        buffer[i] = str.charCodeAt(i);\n      }\n\n      return buffer;\n    } else {\n      var msg = 'This environment does not support reading binary tags; either Buffer or atob is required';\n      doc.errors.push(new YAMLReferenceError(node, msg));\n      return null;\n    }\n  },\n  options: binaryOptions,\n  stringify: function stringify(_ref, ctx, onComment, onChompKeep) {\n    var comment = _ref.comment,\n        type = _ref.type,\n        value = _ref.value;\n    var src;\n\n    if (typeof Buffer === 'function') {\n      src = value instanceof Buffer ? value.toString('base64') : Buffer.from(value.buffer).toString('base64');\n    } else if (typeof btoa === 'function') {\n      var s = '';\n\n      for (var i = 0; i < value.length; ++i) {\n        s += String.fromCharCode(value[i]);\n      }\n\n      src = btoa(s);\n    } else {\n      throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');\n    }\n\n    if (!type) type = binaryOptions.defaultType;\n\n    if (type === Type.QUOTE_DOUBLE) {\n      value = src;\n    } else {\n      var lineWidth = binaryOptions.lineWidth;\n      var n = Math.ceil(src.length / lineWidth);\n      var lines = new Array(n);\n\n      for (var _i = 0, o = 0; _i < n; ++_i, o += lineWidth) {\n        lines[_i] = src.substr(o, lineWidth);\n      }\n\n      value = lines.join(type === Type.BLOCK_LITERAL ? '\\n' : ' ');\n    }\n\n    return stringifyString({\n      comment: comment,\n      type: type,\n      value: value\n    }, ctx, onComment, onChompKeep);\n  }\n};\n\nfunction parsePairs(doc, cst) {\n  var seq = resolveSeq(doc, cst);\n\n  for (var i = 0; i < seq.items.length; ++i) {\n    var item = seq.items[i];\n    if (item instanceof Pair) continue;else if (item instanceof YAMLMap) {\n      if (item.items.length > 1) {\n        var msg = 'Each pair must have its own sequence indicator';\n        throw new YAMLSemanticError(cst, msg);\n      }\n\n      var pair = item.items[0] || new Pair();\n      if (item.commentBefore) pair.commentBefore = pair.commentBefore ? \"\".concat(item.commentBefore, \"\\n\").concat(pair.commentBefore) : item.commentBefore;\n      if (item.comment) pair.comment = pair.comment ? \"\".concat(item.comment, \"\\n\").concat(pair.comment) : item.comment;\n      item = pair;\n    }\n    seq.items[i] = item instanceof Pair ? item : new Pair(item);\n  }\n\n  return seq;\n}\nfunction createPairs(schema, iterable, ctx) {\n  var pairs = new YAMLSeq(schema);\n  pairs.tag = 'tag:yaml.org,2002:pairs';\n\n  var _iterator = _createForOfIteratorHelper(iterable),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var it = _step.value;\n      var key = void 0,\n          value = void 0;\n\n      if (Array.isArray(it)) {\n        if (it.length === 2) {\n          key = it[0];\n          value = it[1];\n        } else throw new TypeError(\"Expected [key, value] tuple: \".concat(it));\n      } else if (it && it instanceof Object) {\n        var keys = Object.keys(it);\n\n        if (keys.length === 1) {\n          key = keys[0];\n          value = it[key];\n        } else throw new TypeError(\"Expected { key: value } tuple: \".concat(it));\n      } else {\n        key = it;\n      }\n\n      var pair = schema.createPair(key, value, ctx);\n      pairs.items.push(pair);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return pairs;\n}\nvar pairs = {\n  default: false,\n  tag: 'tag:yaml.org,2002:pairs',\n  resolve: parsePairs,\n  createNode: createPairs\n};\n\nvar YAMLOMap = /*#__PURE__*/function (_YAMLSeq) {\n  _inherits(YAMLOMap, _YAMLSeq);\n\n  var _super = _createSuper(YAMLOMap);\n\n  function YAMLOMap() {\n    var _this;\n\n    _classCallCheck(this, YAMLOMap);\n\n    _this = _super.call(this);\n\n    _defineProperty(_assertThisInitialized(_this), \"add\", YAMLMap.prototype.add.bind(_assertThisInitialized(_this)));\n\n    _defineProperty(_assertThisInitialized(_this), \"delete\", YAMLMap.prototype.delete.bind(_assertThisInitialized(_this)));\n\n    _defineProperty(_assertThisInitialized(_this), \"get\", YAMLMap.prototype.get.bind(_assertThisInitialized(_this)));\n\n    _defineProperty(_assertThisInitialized(_this), \"has\", YAMLMap.prototype.has.bind(_assertThisInitialized(_this)));\n\n    _defineProperty(_assertThisInitialized(_this), \"set\", YAMLMap.prototype.set.bind(_assertThisInitialized(_this)));\n\n    _this.tag = YAMLOMap.tag;\n    return _this;\n  }\n\n  _createClass(YAMLOMap, [{\n    key: \"toJSON\",\n    value: function toJSON$1(_, ctx) {\n      var map = new Map();\n      if (ctx && ctx.onCreate) ctx.onCreate(map);\n\n      var _iterator = _createForOfIteratorHelper(this.items),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var pair = _step.value;\n          var key = void 0,\n              value = void 0;\n\n          if (pair instanceof Pair) {\n            key = toJSON(pair.key, '', ctx);\n            value = toJSON(pair.value, key, ctx);\n          } else {\n            key = toJSON(pair, '', ctx);\n          }\n\n          if (map.has(key)) throw new Error('Ordered maps must not include duplicate keys');\n          map.set(key, value);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return map;\n    }\n  }]);\n\n  return YAMLOMap;\n}(YAMLSeq);\n\n_defineProperty(YAMLOMap, \"tag\", 'tag:yaml.org,2002:omap');\n\nfunction parseOMap(doc, cst) {\n  var pairs = parsePairs(doc, cst);\n  var seenKeys = [];\n\n  var _iterator2 = _createForOfIteratorHelper(pairs.items),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var key = _step2.value.key;\n\n      if (key instanceof Scalar) {\n        if (seenKeys.includes(key.value)) {\n          var msg = 'Ordered maps must not include duplicate keys';\n          throw new YAMLSemanticError(cst, msg);\n        } else {\n          seenKeys.push(key.value);\n        }\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return Object.assign(new YAMLOMap(), pairs);\n}\n\nfunction createOMap(schema, iterable, ctx) {\n  var pairs = createPairs(schema, iterable, ctx);\n  var omap = new YAMLOMap();\n  omap.items = pairs.items;\n  return omap;\n}\n\nvar omap = {\n  identify: function identify(value) {\n    return value instanceof Map;\n  },\n  nodeClass: YAMLOMap,\n  default: false,\n  tag: 'tag:yaml.org,2002:omap',\n  resolve: parseOMap,\n  createNode: createOMap\n};\n\nvar YAMLSet = /*#__PURE__*/function (_YAMLMap) {\n  _inherits(YAMLSet, _YAMLMap);\n\n  var _super = _createSuper(YAMLSet);\n\n  function YAMLSet() {\n    var _this;\n\n    _classCallCheck(this, YAMLSet);\n\n    _this = _super.call(this);\n    _this.tag = YAMLSet.tag;\n    return _this;\n  }\n\n  _createClass(YAMLSet, [{\n    key: \"add\",\n    value: function add(key) {\n      var pair = key instanceof Pair ? key : new Pair(key);\n      var prev = findPair(this.items, pair.key);\n      if (!prev) this.items.push(pair);\n    }\n  }, {\n    key: \"get\",\n    value: function get(key, keepPair) {\n      var pair = findPair(this.items, key);\n      return !keepPair && pair instanceof Pair ? pair.key instanceof Scalar ? pair.key.value : pair.key : pair;\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      if (typeof value !== 'boolean') throw new Error(\"Expected boolean value for set(key, value) in a YAML set, not \".concat(_typeof(value)));\n      var prev = findPair(this.items, key);\n\n      if (prev && !value) {\n        this.items.splice(this.items.indexOf(prev), 1);\n      } else if (!prev && value) {\n        this.items.push(new Pair(key));\n      }\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(_, ctx) {\n      return _get(_getPrototypeOf(YAMLSet.prototype), \"toJSON\", this).call(this, _, ctx, Set);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(ctx, onComment, onChompKeep) {\n      if (!ctx) return JSON.stringify(this);\n      if (this.hasAllNullValues()) return _get(_getPrototypeOf(YAMLSet.prototype), \"toString\", this).call(this, ctx, onComment, onChompKeep);else throw new Error('Set items must all have null values');\n    }\n  }]);\n\n  return YAMLSet;\n}(YAMLMap);\n\n_defineProperty(YAMLSet, \"tag\", 'tag:yaml.org,2002:set');\n\nfunction parseSet(doc, cst) {\n  var map = resolveMap(doc, cst);\n  if (!map.hasAllNullValues()) throw new YAMLSemanticError(cst, 'Set items must all have null values');\n  return Object.assign(new YAMLSet(), map);\n}\n\nfunction createSet(schema, iterable, ctx) {\n  var set = new YAMLSet();\n\n  var _iterator = _createForOfIteratorHelper(iterable),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var value = _step.value;\n      set.items.push(schema.createPair(value, null, ctx));\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return set;\n}\n\nvar set = {\n  identify: function identify(value) {\n    return value instanceof Set;\n  },\n  nodeClass: YAMLSet,\n  default: false,\n  tag: 'tag:yaml.org,2002:set',\n  resolve: parseSet,\n  createNode: createSet\n};\n\nvar parseSexagesimal = function parseSexagesimal(sign, parts) {\n  var n = parts.split(':').reduce(function (n, p) {\n    return n * 60 + Number(p);\n  }, 0);\n  return sign === '-' ? -n : n;\n}; // hhhh:mm:ss.sss\n\n\nvar stringifySexagesimal = function stringifySexagesimal(_ref) {\n  var value = _ref.value;\n  if (isNaN(value) || !isFinite(value)) return stringifyNumber(value);\n  var sign = '';\n\n  if (value < 0) {\n    sign = '-';\n    value = Math.abs(value);\n  }\n\n  var parts = [value % 60]; // seconds, including ms\n\n  if (value < 60) {\n    parts.unshift(0); // at least one : is required\n  } else {\n    value = Math.round((value - parts[0]) / 60);\n    parts.unshift(value % 60); // minutes\n\n    if (value >= 60) {\n      value = Math.round((value - parts[0]) / 60);\n      parts.unshift(value); // hours\n    }\n  }\n\n  return sign + parts.map(function (n) {\n    return n < 10 ? '0' + String(n) : String(n);\n  }).join(':').replace(/000000\\d*$/, '') // % 60 may introduce error\n  ;\n};\n\nvar intTime = {\n  identify: function identify(value) {\n    return typeof value === 'number';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'TIME',\n  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,\n  resolve: function resolve(str, sign, parts) {\n    return parseSexagesimal(sign, parts.replace(/_/g, ''));\n  },\n  stringify: stringifySexagesimal\n};\nvar floatTime = {\n  identify: function identify(value) {\n    return typeof value === 'number';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  format: 'TIME',\n  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*)$/,\n  resolve: function resolve(str, sign, parts) {\n    return parseSexagesimal(sign, parts.replace(/_/g, ''));\n  },\n  stringify: stringifySexagesimal\n};\nvar timestamp = {\n  identify: function identify(value) {\n    return value instanceof Date;\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:timestamp',\n  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part\n  // may be omitted altogether, resulting in a date format. In such a case, the time part is\n  // assumed to be 00:00:00Z (start of day, UTC).\n  test: RegExp('^(?:' + '([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd\n  '(?:(?:t|T|[ \\\\t]+)' + // t | T | whitespace\n  '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?\n  '(?:[ \\\\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30\n  ')?' + ')$'),\n  resolve: function resolve(str, year, month, day, hour, minute, second, millisec, tz) {\n    if (millisec) millisec = (millisec + '00').substr(1, 3);\n    var date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec || 0);\n\n    if (tz && tz !== 'Z') {\n      var d = parseSexagesimal(tz[0], tz.slice(1));\n      if (Math.abs(d) < 30) d *= 60;\n      date -= 60000 * d;\n    }\n\n    return new Date(date);\n  },\n  stringify: function stringify(_ref2) {\n    var value = _ref2.value;\n    return value.toISOString().replace(/((T00:00)?:00)?\\.000Z$/, '');\n  }\n};\n\n/* global console, process, YAML_SILENCE_DEPRECATION_WARNINGS, YAML_SILENCE_WARNINGS */\nfunction shouldWarn(deprecation) {\n  var env = typeof process !== 'undefined' && process.env || {};\n\n  if (deprecation) {\n    if (typeof YAML_SILENCE_DEPRECATION_WARNINGS !== 'undefined') return !YAML_SILENCE_DEPRECATION_WARNINGS;\n    return !env.YAML_SILENCE_DEPRECATION_WARNINGS;\n  }\n\n  if (typeof YAML_SILENCE_WARNINGS !== 'undefined') return !YAML_SILENCE_WARNINGS;\n  return !env.YAML_SILENCE_WARNINGS;\n}\n\nfunction warn(warning, type) {\n  if (shouldWarn(false)) {\n    var emit = typeof process !== 'undefined' && process.emitWarning; // This will throw in Jest if `warning` is an Error instance due to\n    // https://github.com/facebook/jest/issues/2549\n\n    if (emit) emit(warning, type);else {\n      // eslint-disable-next-line no-console\n      console.warn(type ? \"\".concat(type, \": \").concat(warning) : warning);\n    }\n  }\n}\nfunction warnFileDeprecation(filename) {\n  if (shouldWarn(true)) {\n    var path = filename.replace(/.*yaml[/\\\\]/i, '').replace(/\\.js$/, '').replace(/\\\\/g, '/');\n    warn(\"The endpoint 'yaml/\".concat(path, \"' will be removed in a future release.\"), 'DeprecationWarning');\n  }\n}\nvar warned = {};\nfunction warnOptionDeprecation(name, alternative) {\n  if (!warned[name] && shouldWarn(true)) {\n    warned[name] = true;\n    var msg = \"The option '\".concat(name, \"' will be removed in a future release\");\n    msg += alternative ? \", use '\".concat(alternative, \"' instead.\") : '.';\n    warn(msg, 'DeprecationWarning');\n  }\n}\n\nexport { warnOptionDeprecation as a, binary as b, warnFileDeprecation as c, floatTime as f, intTime as i, omap as o, pairs as p, set as s, timestamp as t, warn as w };\n", "import { _ as _createForOfIteratorHelper, h as _slicedToArray, a as _typeof, b as _createClass, e as _defineProperty, c as _classCallCheck, d as defaultTagPrefix, n as defaultTags } from './PlainValue-b8036b75.js';\nimport { d as YAMLMap, g as resolveMap, Y as YAMLSeq, h as resolveSeq, j as resolveString, c as stringifyString, s as strOptions, S as Scalar, n as nullOptions, a as boolOptions, i as intOptions, k as stringifyNumber, N as Node, A as Alias, P as Pair } from './resolveSeq-492ab440.js';\nimport { b as binary, o as omap, p as pairs, s as set, i as intTime, f as floatTime, t as timestamp, a as warnOptionDeprecation } from './warnings-df54cb69.js';\n\nfunction createMap(schema, obj, ctx) {\n  var map = new YAMLMap(schema);\n\n  if (obj instanceof Map) {\n    var _iterator = _createForOfIteratorHelper(obj),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _step$value = _slicedToArray(_step.value, 2),\n            key = _step$value[0],\n            value = _step$value[1];\n\n        map.items.push(schema.createPair(key, value, ctx));\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  } else if (obj && _typeof(obj) === 'object') {\n    for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {\n      var _key = _Object$keys[_i];\n      map.items.push(schema.createPair(_key, obj[_key], ctx));\n    }\n  }\n\n  if (typeof schema.sortMapEntries === 'function') {\n    map.items.sort(schema.sortMapEntries);\n  }\n\n  return map;\n}\n\nvar map = {\n  createNode: createMap,\n  default: true,\n  nodeClass: YAMLMap,\n  tag: 'tag:yaml.org,2002:map',\n  resolve: resolveMap\n};\n\nfunction createSeq(schema, obj, ctx) {\n  var seq = new YAMLSeq(schema);\n\n  if (obj && obj[Symbol.iterator]) {\n    var _iterator = _createForOfIteratorHelper(obj),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var it = _step.value;\n        var v = schema.createNode(it, ctx.wrapScalars, null, ctx);\n        seq.items.push(v);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  return seq;\n}\n\nvar seq = {\n  createNode: createSeq,\n  default: true,\n  nodeClass: YAMLSeq,\n  tag: 'tag:yaml.org,2002:seq',\n  resolve: resolveSeq\n};\n\nvar string = {\n  identify: function identify(value) {\n    return typeof value === 'string';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:str',\n  resolve: resolveString,\n  stringify: function stringify(item, ctx, onComment, onChompKeep) {\n    ctx = Object.assign({\n      actualString: true\n    }, ctx);\n    return stringifyString(item, ctx, onComment, onChompKeep);\n  },\n  options: strOptions\n};\n\nvar failsafe = [map, seq, string];\n\n/* global BigInt */\n\nvar intIdentify$2 = function intIdentify(value) {\n  return typeof value === 'bigint' || Number.isInteger(value);\n};\n\nvar intResolve$1 = function intResolve(src, part, radix) {\n  return intOptions.asBigInt ? BigInt(src) : parseInt(part, radix);\n};\n\nfunction intStringify$1(node, radix, prefix) {\n  var value = node.value;\n  if (intIdentify$2(value) && value >= 0) return prefix + value.toString(radix);\n  return stringifyNumber(node);\n}\n\nvar nullObj = {\n  identify: function identify(value) {\n    return value == null;\n  },\n  createNode: function createNode(schema, value, ctx) {\n    return ctx.wrapScalars ? new Scalar(null) : null;\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:null',\n  test: /^(?:~|[Nn]ull|NULL)?$/,\n  resolve: function resolve() {\n    return null;\n  },\n  options: nullOptions,\n  stringify: function stringify() {\n    return nullOptions.nullStr;\n  }\n};\nvar boolObj = {\n  identify: function identify(value) {\n    return typeof value === 'boolean';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,\n  resolve: function resolve(str) {\n    return str[0] === 't' || str[0] === 'T';\n  },\n  options: boolOptions,\n  stringify: function stringify(_ref) {\n    var value = _ref.value;\n    return value ? boolOptions.trueStr : boolOptions.falseStr;\n  }\n};\nvar octObj = {\n  identify: function identify(value) {\n    return intIdentify$2(value) && value >= 0;\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'OCT',\n  test: /^0o([0-7]+)$/,\n  resolve: function resolve(str, oct) {\n    return intResolve$1(str, oct, 8);\n  },\n  options: intOptions,\n  stringify: function stringify(node) {\n    return intStringify$1(node, 8, '0o');\n  }\n};\nvar intObj = {\n  identify: intIdentify$2,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  test: /^[-+]?[0-9]+$/,\n  resolve: function resolve(str) {\n    return intResolve$1(str, str, 10);\n  },\n  options: intOptions,\n  stringify: stringifyNumber\n};\nvar hexObj = {\n  identify: function identify(value) {\n    return intIdentify$2(value) && value >= 0;\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'HEX',\n  test: /^0x([0-9a-fA-F]+)$/,\n  resolve: function resolve(str, hex) {\n    return intResolve$1(str, hex, 16);\n  },\n  options: intOptions,\n  stringify: function stringify(node) {\n    return intStringify$1(node, 16, '0x');\n  }\n};\nvar nanObj = {\n  identify: function identify(value) {\n    return typeof value === 'number';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^(?:[-+]?\\.inf|(\\.nan))$/i,\n  resolve: function resolve(str, nan) {\n    return nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n  },\n  stringify: stringifyNumber\n};\nvar expObj = {\n  identify: function identify(value) {\n    return typeof value === 'number';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  format: 'EXP',\n  test: /^[-+]?(?:\\.[0-9]+|[0-9]+(?:\\.[0-9]*)?)[eE][-+]?[0-9]+$/,\n  resolve: function resolve(str) {\n    return parseFloat(str);\n  },\n  stringify: function stringify(_ref2) {\n    var value = _ref2.value;\n    return Number(value).toExponential();\n  }\n};\nvar floatObj = {\n  identify: function identify(value) {\n    return typeof value === 'number';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^[-+]?(?:\\.([0-9]+)|[0-9]+\\.([0-9]*))$/,\n  resolve: function resolve(str, frac1, frac2) {\n    var frac = frac1 || frac2;\n    var node = new Scalar(parseFloat(str));\n    if (frac && frac[frac.length - 1] === '0') node.minFractionDigits = frac.length;\n    return node;\n  },\n  stringify: stringifyNumber\n};\nvar core = failsafe.concat([nullObj, boolObj, octObj, intObj, hexObj, nanObj, expObj, floatObj]);\n\n/* global BigInt */\n\nvar intIdentify$1 = function intIdentify(value) {\n  return typeof value === 'bigint' || Number.isInteger(value);\n};\n\nvar stringifyJSON = function stringifyJSON(_ref) {\n  var value = _ref.value;\n  return JSON.stringify(value);\n};\n\nvar json = [map, seq, {\n  identify: function identify(value) {\n    return typeof value === 'string';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:str',\n  resolve: resolveString,\n  stringify: stringifyJSON\n}, {\n  identify: function identify(value) {\n    return value == null;\n  },\n  createNode: function createNode(schema, value, ctx) {\n    return ctx.wrapScalars ? new Scalar(null) : null;\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:null',\n  test: /^null$/,\n  resolve: function resolve() {\n    return null;\n  },\n  stringify: stringifyJSON\n}, {\n  identify: function identify(value) {\n    return typeof value === 'boolean';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^true|false$/,\n  resolve: function resolve(str) {\n    return str === 'true';\n  },\n  stringify: stringifyJSON\n}, {\n  identify: intIdentify$1,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  test: /^-?(?:0|[1-9][0-9]*)$/,\n  resolve: function resolve(str) {\n    return intOptions.asBigInt ? BigInt(str) : parseInt(str, 10);\n  },\n  stringify: function stringify(_ref2) {\n    var value = _ref2.value;\n    return intIdentify$1(value) ? value.toString() : JSON.stringify(value);\n  }\n}, {\n  identify: function identify(value) {\n    return typeof value === 'number';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^-?(?:0|[1-9][0-9]*)(?:\\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,\n  resolve: function resolve(str) {\n    return parseFloat(str);\n  },\n  stringify: stringifyJSON\n}];\n\njson.scalarFallback = function (str) {\n  throw new SyntaxError(\"Unresolved plain scalar \".concat(JSON.stringify(str)));\n};\n\n/* global BigInt */\n\nvar boolStringify = function boolStringify(_ref) {\n  var value = _ref.value;\n  return value ? boolOptions.trueStr : boolOptions.falseStr;\n};\n\nvar intIdentify = function intIdentify(value) {\n  return typeof value === 'bigint' || Number.isInteger(value);\n};\n\nfunction intResolve(sign, src, radix) {\n  var str = src.replace(/_/g, '');\n\n  if (intOptions.asBigInt) {\n    switch (radix) {\n      case 2:\n        str = \"0b\".concat(str);\n        break;\n\n      case 8:\n        str = \"0o\".concat(str);\n        break;\n\n      case 16:\n        str = \"0x\".concat(str);\n        break;\n    }\n\n    var _n = BigInt(str);\n\n    return sign === '-' ? BigInt(-1) * _n : _n;\n  }\n\n  var n = parseInt(str, radix);\n  return sign === '-' ? -1 * n : n;\n}\n\nfunction intStringify(node, radix, prefix) {\n  var value = node.value;\n\n  if (intIdentify(value)) {\n    var str = value.toString(radix);\n    return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;\n  }\n\n  return stringifyNumber(node);\n}\n\nvar yaml11 = failsafe.concat([{\n  identify: function identify(value) {\n    return value == null;\n  },\n  createNode: function createNode(schema, value, ctx) {\n    return ctx.wrapScalars ? new Scalar(null) : null;\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:null',\n  test: /^(?:~|[Nn]ull|NULL)?$/,\n  resolve: function resolve() {\n    return null;\n  },\n  options: nullOptions,\n  stringify: function stringify() {\n    return nullOptions.nullStr;\n  }\n}, {\n  identify: function identify(value) {\n    return typeof value === 'boolean';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,\n  resolve: function resolve() {\n    return true;\n  },\n  options: boolOptions,\n  stringify: boolStringify\n}, {\n  identify: function identify(value) {\n    return typeof value === 'boolean';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,\n  resolve: function resolve() {\n    return false;\n  },\n  options: boolOptions,\n  stringify: boolStringify\n}, {\n  identify: intIdentify,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'BIN',\n  test: /^([-+]?)0b([0-1_]+)$/,\n  resolve: function resolve(str, sign, bin) {\n    return intResolve(sign, bin, 2);\n  },\n  stringify: function stringify(node) {\n    return intStringify(node, 2, '0b');\n  }\n}, {\n  identify: intIdentify,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'OCT',\n  test: /^([-+]?)0([0-7_]+)$/,\n  resolve: function resolve(str, sign, oct) {\n    return intResolve(sign, oct, 8);\n  },\n  stringify: function stringify(node) {\n    return intStringify(node, 8, '0');\n  }\n}, {\n  identify: intIdentify,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  test: /^([-+]?)([0-9][0-9_]*)$/,\n  resolve: function resolve(str, sign, abs) {\n    return intResolve(sign, abs, 10);\n  },\n  stringify: stringifyNumber\n}, {\n  identify: intIdentify,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'HEX',\n  test: /^([-+]?)0x([0-9a-fA-F_]+)$/,\n  resolve: function resolve(str, sign, hex) {\n    return intResolve(sign, hex, 16);\n  },\n  stringify: function stringify(node) {\n    return intStringify(node, 16, '0x');\n  }\n}, {\n  identify: function identify(value) {\n    return typeof value === 'number';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^(?:[-+]?\\.inf|(\\.nan))$/i,\n  resolve: function resolve(str, nan) {\n    return nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n  },\n  stringify: stringifyNumber\n}, {\n  identify: function identify(value) {\n    return typeof value === 'number';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  format: 'EXP',\n  test: /^[-+]?([0-9][0-9_]*)?(\\.[0-9_]*)?[eE][-+]?[0-9]+$/,\n  resolve: function resolve(str) {\n    return parseFloat(str.replace(/_/g, ''));\n  },\n  stringify: function stringify(_ref2) {\n    var value = _ref2.value;\n    return Number(value).toExponential();\n  }\n}, {\n  identify: function identify(value) {\n    return typeof value === 'number';\n  },\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^[-+]?(?:[0-9][0-9_]*)?\\.([0-9_]*)$/,\n  resolve: function resolve(str, frac) {\n    var node = new Scalar(parseFloat(str.replace(/_/g, '')));\n\n    if (frac) {\n      var f = frac.replace(/_/g, '');\n      if (f[f.length - 1] === '0') node.minFractionDigits = f.length;\n    }\n\n    return node;\n  },\n  stringify: stringifyNumber\n}], binary, omap, pairs, set, intTime, floatTime, timestamp);\n\nvar schemas = {\n  core: core,\n  failsafe: failsafe,\n  json: json,\n  yaml11: yaml11\n};\nvar tags = {\n  binary: binary,\n  bool: boolObj,\n  float: floatObj,\n  floatExp: expObj,\n  floatNaN: nanObj,\n  floatTime: floatTime,\n  int: intObj,\n  intHex: hexObj,\n  intOct: octObj,\n  intTime: intTime,\n  map: map,\n  null: nullObj,\n  omap: omap,\n  pairs: pairs,\n  seq: seq,\n  set: set,\n  timestamp: timestamp\n};\n\nfunction findTagObject(value, tagName, tags) {\n  if (tagName) {\n    var match = tags.filter(function (t) {\n      return t.tag === tagName;\n    });\n    var tagObj = match.find(function (t) {\n      return !t.format;\n    }) || match[0];\n    if (!tagObj) throw new Error(\"Tag \".concat(tagName, \" not found\"));\n    return tagObj;\n  } // TODO: deprecate/remove class check\n\n\n  return tags.find(function (t) {\n    return (t.identify && t.identify(value) || t.class && value instanceof t.class) && !t.format;\n  });\n}\n\nfunction createNode(value, tagName, ctx) {\n  if (value instanceof Node) return value;\n  var defaultPrefix = ctx.defaultPrefix,\n      onTagObj = ctx.onTagObj,\n      prevObjects = ctx.prevObjects,\n      schema = ctx.schema,\n      wrapScalars = ctx.wrapScalars;\n  if (tagName && tagName.startsWith('!!')) tagName = defaultPrefix + tagName.slice(2);\n  var tagObj = findTagObject(value, tagName, schema.tags);\n\n  if (!tagObj) {\n    if (typeof value.toJSON === 'function') value = value.toJSON();\n    if (!value || _typeof(value) !== 'object') return wrapScalars ? new Scalar(value) : value;\n    tagObj = value instanceof Map ? map : value[Symbol.iterator] ? seq : map;\n  }\n\n  if (onTagObj) {\n    onTagObj(tagObj);\n    delete ctx.onTagObj;\n  } // Detect duplicate references to the same object & use Alias nodes for all\n  // after first. The `obj` wrapper allows for circular references to resolve.\n\n\n  var obj = {\n    value: undefined,\n    node: undefined\n  };\n\n  if (value && _typeof(value) === 'object' && prevObjects) {\n    var prev = prevObjects.get(value);\n\n    if (prev) {\n      var alias = new Alias(prev); // leaves source dirty; must be cleaned by caller\n\n      ctx.aliasNodes.push(alias); // defined along with prevObjects\n\n      return alias;\n    }\n\n    obj.value = value;\n    prevObjects.set(value, obj);\n  }\n\n  obj.node = tagObj.createNode ? tagObj.createNode(ctx.schema, value, ctx) : wrapScalars ? new Scalar(value) : value;\n  if (tagName && obj.node instanceof Node) obj.node.tag = tagName;\n  return obj.node;\n}\n\nfunction getSchemaTags(schemas, knownTags, customTags, schemaId) {\n  var tags = schemas[schemaId.replace(/\\W/g, '')]; // 'yaml-1.1' -> 'yaml11'\n\n  if (!tags) {\n    var keys = Object.keys(schemas).map(function (key) {\n      return JSON.stringify(key);\n    }).join(', ');\n    throw new Error(\"Unknown schema \\\"\".concat(schemaId, \"\\\"; use one of \").concat(keys));\n  }\n\n  if (Array.isArray(customTags)) {\n    var _iterator = _createForOfIteratorHelper(customTags),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var tag = _step.value;\n        tags = tags.concat(tag);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  } else if (typeof customTags === 'function') {\n    tags = customTags(tags.slice());\n  }\n\n  for (var i = 0; i < tags.length; ++i) {\n    var _tag = tags[i];\n\n    if (typeof _tag === 'string') {\n      var tagObj = knownTags[_tag];\n\n      if (!tagObj) {\n        var _keys = Object.keys(knownTags).map(function (key) {\n          return JSON.stringify(key);\n        }).join(', ');\n\n        throw new Error(\"Unknown custom tag \\\"\".concat(_tag, \"\\\"; use one of \").concat(_keys));\n      }\n\n      tags[i] = tagObj;\n    }\n  }\n\n  return tags;\n}\n\nvar sortMapEntriesByKey = function sortMapEntriesByKey(a, b) {\n  return a.key < b.key ? -1 : a.key > b.key ? 1 : 0;\n};\n\nvar Schema = /*#__PURE__*/function () {\n  // TODO: remove in v2\n  // TODO: remove in v2\n  function Schema(_ref) {\n    var customTags = _ref.customTags,\n        merge = _ref.merge,\n        schema = _ref.schema,\n        sortMapEntries = _ref.sortMapEntries,\n        deprecatedCustomTags = _ref.tags;\n\n    _classCallCheck(this, Schema);\n\n    this.merge = !!merge;\n    this.name = schema;\n    this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;\n    if (!customTags && deprecatedCustomTags) warnOptionDeprecation('tags', 'customTags');\n    this.tags = getSchemaTags(schemas, tags, customTags || deprecatedCustomTags, schema);\n  }\n\n  _createClass(Schema, [{\n    key: \"createNode\",\n    value: function createNode$1(value, wrapScalars, tagName, ctx) {\n      var baseCtx = {\n        defaultPrefix: Schema.defaultPrefix,\n        schema: this,\n        wrapScalars: wrapScalars\n      };\n      var createCtx = ctx ? Object.assign(ctx, baseCtx) : baseCtx;\n      return createNode(value, tagName, createCtx);\n    }\n  }, {\n    key: \"createPair\",\n    value: function createPair(key, value, ctx) {\n      if (!ctx) ctx = {\n        wrapScalars: true\n      };\n      var k = this.createNode(key, ctx.wrapScalars, null, ctx);\n      var v = this.createNode(value, ctx.wrapScalars, null, ctx);\n      return new Pair(k, v);\n    }\n  }]);\n\n  return Schema;\n}();\n\n_defineProperty(Schema, \"defaultPrefix\", defaultTagPrefix);\n\n_defineProperty(Schema, \"defaultTags\", defaultTags);\n\nexport { Schema as S };\n", "import { d as defaultTagPrefix, _ as _createForOfIteratorHelper, a as _typeof, b as _createClass, c as _classCallCheck, e as _defineProperty, Y as YAMLSyntaxError, T as Type, f as YAMLWarning, g as YAMLSemanticError, h as _slicedToArray, i as YAMLError, j as _inherits, k as _createSuper } from './PlainValue-b8036b75.js';\nimport { parse as parse$1 } from './parse-cst.js';\nimport { b as binaryOptions, a as boolOptions, i as intOptions, n as nullOptions, s as strOptions, N as Node, P as Pair, S as Scalar, c as stringifyString, A as Alias, Y as YAMLSeq, d as YAMLMap, M as Merge, C as Collection, r as resolveNode, e as isEmptyPath, t as toJSON, f as addComment } from './resolveSeq-492ab440.js';\nimport { S as Schema } from './Schema-e94716c8.js';\nimport { w as warn } from './warnings-df54cb69.js';\n\nvar defaultOptions = {\n  anchorPrefix: 'a',\n  customTags: null,\n  indent: 2,\n  indentSeq: true,\n  keepCstNodes: false,\n  keepNodeTypes: true,\n  keepBlobsInJSON: true,\n  mapAsMap: false,\n  maxAliasCount: 100,\n  prettyErrors: false,\n  // TODO Set true in v2\n  simpleKeys: false,\n  version: '1.2'\n};\nvar scalarOptions = {\n  get binary() {\n    return binaryOptions;\n  },\n\n  set binary(opt) {\n    Object.assign(binaryOptions, opt);\n  },\n\n  get bool() {\n    return boolOptions;\n  },\n\n  set bool(opt) {\n    Object.assign(boolOptions, opt);\n  },\n\n  get int() {\n    return intOptions;\n  },\n\n  set int(opt) {\n    Object.assign(intOptions, opt);\n  },\n\n  get null() {\n    return nullOptions;\n  },\n\n  set null(opt) {\n    Object.assign(nullOptions, opt);\n  },\n\n  get str() {\n    return strOptions;\n  },\n\n  set str(opt) {\n    Object.assign(strOptions, opt);\n  }\n\n};\nvar documentOptions = {\n  '1.0': {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: defaultTagPrefix\n    }, {\n      handle: '!!',\n      prefix: 'tag:private.yaml.org,2002:'\n    }]\n  },\n  1.1: {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: defaultTagPrefix\n    }]\n  },\n  1.2: {\n    schema: 'core',\n    merge: false,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: defaultTagPrefix\n    }]\n  }\n};\n\nfunction stringifyTag(doc, tag) {\n  if ((doc.version || doc.options.version) === '1.0') {\n    var priv = tag.match(/^tag:private\\.yaml\\.org,2002:([^:/]+)$/);\n    if (priv) return '!' + priv[1];\n    var vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\\.yaml\\.org,2002:(.*)/);\n    return vocab ? \"!\".concat(vocab[1], \"/\").concat(vocab[2]) : \"!\".concat(tag.replace(/^tag:/, ''));\n  }\n\n  var p = doc.tagPrefixes.find(function (p) {\n    return tag.indexOf(p.prefix) === 0;\n  });\n\n  if (!p) {\n    var dtp = doc.getDefaults().tagPrefixes;\n    p = dtp && dtp.find(function (p) {\n      return tag.indexOf(p.prefix) === 0;\n    });\n  }\n\n  if (!p) return tag[0] === '!' ? tag : \"!<\".concat(tag, \">\");\n  var suffix = tag.substr(p.prefix.length).replace(/[!,[\\]{}]/g, function (ch) {\n    return {\n      '!': '%21',\n      ',': '%2C',\n      '[': '%5B',\n      ']': '%5D',\n      '{': '%7B',\n      '}': '%7D'\n    }[ch];\n  });\n  return p.handle + suffix;\n}\n\nfunction getTagObject(tags, item) {\n  if (item instanceof Alias) return Alias;\n\n  if (item.tag) {\n    var match = tags.filter(function (t) {\n      return t.tag === item.tag;\n    });\n    if (match.length > 0) return match.find(function (t) {\n      return t.format === item.format;\n    }) || match[0];\n  }\n\n  var tagObj, obj;\n\n  if (item instanceof Scalar) {\n    obj = item.value; // TODO: deprecate/remove class check\n\n    var _match = tags.filter(function (t) {\n      return t.identify && t.identify(obj) || t.class && obj instanceof t.class;\n    });\n\n    tagObj = _match.find(function (t) {\n      return t.format === item.format;\n    }) || _match.find(function (t) {\n      return !t.format;\n    });\n  } else {\n    obj = item;\n    tagObj = tags.find(function (t) {\n      return t.nodeClass && obj instanceof t.nodeClass;\n    });\n  }\n\n  if (!tagObj) {\n    var name = obj && obj.constructor ? obj.constructor.name : _typeof(obj);\n    throw new Error(\"Tag not resolved for \".concat(name, \" value\"));\n  }\n\n  return tagObj;\n} // needs to be called before value stringifier to allow for circular anchor refs\n\n\nfunction stringifyProps(node, tagObj, _ref) {\n  var anchors = _ref.anchors,\n      doc = _ref.doc;\n  var props = [];\n  var anchor = doc.anchors.getName(node);\n\n  if (anchor) {\n    anchors[anchor] = node;\n    props.push(\"&\".concat(anchor));\n  }\n\n  if (node.tag) {\n    props.push(stringifyTag(doc, node.tag));\n  } else if (!tagObj.default) {\n    props.push(stringifyTag(doc, tagObj.tag));\n  }\n\n  return props.join(' ');\n}\n\nfunction stringify$1(item, ctx, onComment, onChompKeep) {\n  var _ctx$doc = ctx.doc,\n      anchors = _ctx$doc.anchors,\n      schema = _ctx$doc.schema;\n  var tagObj;\n\n  if (!(item instanceof Node)) {\n    var createCtx = {\n      aliasNodes: [],\n      onTagObj: function onTagObj(o) {\n        return tagObj = o;\n      },\n      prevObjects: new Map()\n    };\n    item = schema.createNode(item, true, null, createCtx);\n\n    var _iterator = _createForOfIteratorHelper(createCtx.aliasNodes),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var alias = _step.value;\n        alias.source = alias.source.node;\n        var name = anchors.getName(alias.source);\n\n        if (!name) {\n          name = anchors.newName();\n          anchors.map[name] = alias.source;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  if (item instanceof Pair) return item.toString(ctx, onComment, onChompKeep);\n  if (!tagObj) tagObj = getTagObject(schema.tags, item);\n  var props = stringifyProps(item, tagObj, ctx);\n  if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;\n  var str = typeof tagObj.stringify === 'function' ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof Scalar ? stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);\n  if (!props) return str;\n  return item instanceof Scalar || str[0] === '{' || str[0] === '[' ? \"\".concat(props, \" \").concat(str) : \"\".concat(props, \"\\n\").concat(ctx.indent).concat(str);\n}\n\nvar Anchors = /*#__PURE__*/function () {\n  function Anchors(prefix) {\n    _classCallCheck(this, Anchors);\n\n    _defineProperty(this, \"map\", Object.create(null));\n\n    this.prefix = prefix;\n  }\n\n  _createClass(Anchors, [{\n    key: \"createAlias\",\n    value: function createAlias(node, name) {\n      this.setAnchor(node, name);\n      return new Alias(node);\n    }\n  }, {\n    key: \"createMergePair\",\n    value: function createMergePair() {\n      var _this = this;\n\n      var merge = new Merge();\n\n      for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n        sources[_key] = arguments[_key];\n      }\n\n      merge.value.items = sources.map(function (s) {\n        if (s instanceof Alias) {\n          if (s.source instanceof YAMLMap) return s;\n        } else if (s instanceof YAMLMap) {\n          return _this.createAlias(s);\n        }\n\n        throw new Error('Merge sources must be Map nodes or their Aliases');\n      });\n      return merge;\n    }\n  }, {\n    key: \"getName\",\n    value: function getName(node) {\n      var map = this.map;\n      return Object.keys(map).find(function (a) {\n        return map[a] === node;\n      });\n    }\n  }, {\n    key: \"getNames\",\n    value: function getNames() {\n      return Object.keys(this.map);\n    }\n  }, {\n    key: \"getNode\",\n    value: function getNode(name) {\n      return this.map[name];\n    }\n  }, {\n    key: \"newName\",\n    value: function newName(prefix) {\n      if (!prefix) prefix = this.prefix;\n      var names = Object.keys(this.map);\n\n      for (var i = 1; true; ++i) {\n        var name = \"\".concat(prefix).concat(i);\n        if (!names.includes(name)) return name;\n      }\n    } // During parsing, map & aliases contain CST nodes\n\n  }, {\n    key: \"resolveNodes\",\n    value: function resolveNodes() {\n      var map = this.map,\n          _cstAliases = this._cstAliases;\n      Object.keys(map).forEach(function (a) {\n        map[a] = map[a].resolved;\n      });\n\n      _cstAliases.forEach(function (a) {\n        a.source = a.source.resolved;\n      });\n\n      delete this._cstAliases;\n    }\n  }, {\n    key: \"setAnchor\",\n    value: function setAnchor(node, name) {\n      if (node != null && !Anchors.validAnchorNode(node)) {\n        throw new Error('Anchors may only be set for Scalar, Seq and Map nodes');\n      }\n\n      if (name && /[\\x00-\\x19\\s,[\\]{}]/.test(name)) {\n        throw new Error('Anchor names must not contain whitespace or control characters');\n      }\n\n      var map = this.map;\n      var prev = node && Object.keys(map).find(function (a) {\n        return map[a] === node;\n      });\n\n      if (prev) {\n        if (!name) {\n          return prev;\n        } else if (prev !== name) {\n          delete map[prev];\n          map[name] = node;\n        }\n      } else {\n        if (!name) {\n          if (!node) return null;\n          name = this.newName();\n        }\n\n        map[name] = node;\n      }\n\n      return name;\n    }\n  }], [{\n    key: \"validAnchorNode\",\n    value: function validAnchorNode(node) {\n      return node instanceof Scalar || node instanceof YAMLSeq || node instanceof YAMLMap;\n    }\n  }]);\n\n  return Anchors;\n}();\n\nvar visit = function visit(node, tags) {\n  if (node && _typeof(node) === 'object') {\n    var tag = node.tag;\n\n    if (node instanceof Collection) {\n      if (tag) tags[tag] = true;\n      node.items.forEach(function (n) {\n        return visit(n, tags);\n      });\n    } else if (node instanceof Pair) {\n      visit(node.key, tags);\n      visit(node.value, tags);\n    } else if (node instanceof Scalar) {\n      if (tag) tags[tag] = true;\n    }\n  }\n\n  return tags;\n};\n\nvar listTagNames = function listTagNames(node) {\n  return Object.keys(visit(node, {}));\n};\n\nfunction parseContents(doc, contents) {\n  var comments = {\n    before: [],\n    after: []\n  };\n  var body = undefined;\n  var spaceBefore = false;\n\n  var _iterator = _createForOfIteratorHelper(contents),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var node = _step.value;\n\n      if (node.valueRange) {\n        if (body !== undefined) {\n          var msg = 'Document contains trailing content not separated by a ... or --- line';\n          doc.errors.push(new YAMLSyntaxError(node, msg));\n          break;\n        }\n\n        var res = resolveNode(doc, node);\n\n        if (spaceBefore) {\n          res.spaceBefore = true;\n          spaceBefore = false;\n        }\n\n        body = res;\n      } else if (node.comment !== null) {\n        var cc = body === undefined ? comments.before : comments.after;\n        cc.push(node.comment);\n      } else if (node.type === Type.BLANK_LINE) {\n        spaceBefore = true;\n\n        if (body === undefined && comments.before.length > 0 && !doc.commentBefore) {\n          // space-separated comments at start are parsed as document comments\n          doc.commentBefore = comments.before.join('\\n');\n          comments.before = [];\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  doc.contents = body || null;\n\n  if (!body) {\n    doc.comment = comments.before.concat(comments.after).join('\\n') || null;\n  } else {\n    var cb = comments.before.join('\\n');\n\n    if (cb) {\n      var cbNode = body instanceof Collection && body.items[0] ? body.items[0] : body;\n      cbNode.commentBefore = cbNode.commentBefore ? \"\".concat(cb, \"\\n\").concat(cbNode.commentBefore) : cb;\n    }\n\n    doc.comment = comments.after.join('\\n') || null;\n  }\n}\n\nfunction resolveTagDirective(_ref, directive) {\n  var tagPrefixes = _ref.tagPrefixes;\n\n  var _directive$parameters = _slicedToArray(directive.parameters, 2),\n      handle = _directive$parameters[0],\n      prefix = _directive$parameters[1];\n\n  if (!handle || !prefix) {\n    var msg = 'Insufficient parameters given for %TAG directive';\n    throw new YAMLSemanticError(directive, msg);\n  }\n\n  if (tagPrefixes.some(function (p) {\n    return p.handle === handle;\n  })) {\n    var _msg = 'The %TAG directive must only be given at most once per handle in the same document.';\n    throw new YAMLSemanticError(directive, _msg);\n  }\n\n  return {\n    handle: handle,\n    prefix: prefix\n  };\n}\n\nfunction resolveYamlDirective(doc, directive) {\n  var _directive$parameters2 = _slicedToArray(directive.parameters, 1),\n      version = _directive$parameters2[0];\n\n  if (directive.name === 'YAML:1.0') version = '1.0';\n\n  if (!version) {\n    var msg = 'Insufficient parameters given for %YAML directive';\n    throw new YAMLSemanticError(directive, msg);\n  }\n\n  if (!documentOptions[version]) {\n    var v0 = doc.version || doc.options.version;\n\n    var _msg2 = \"Document will be parsed as YAML \".concat(v0, \" rather than YAML \").concat(version);\n\n    doc.warnings.push(new YAMLWarning(directive, _msg2));\n  }\n\n  return version;\n}\n\nfunction parseDirectives(doc, directives, prevDoc) {\n  var directiveComments = [];\n  var hasDirectives = false;\n\n  var _iterator = _createForOfIteratorHelper(directives),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var directive = _step.value;\n      var comment = directive.comment,\n          name = directive.name;\n\n      switch (name) {\n        case 'TAG':\n          try {\n            doc.tagPrefixes.push(resolveTagDirective(doc, directive));\n          } catch (error) {\n            doc.errors.push(error);\n          }\n\n          hasDirectives = true;\n          break;\n\n        case 'YAML':\n        case 'YAML:1.0':\n          if (doc.version) {\n            var msg = 'The %YAML directive must only be given at most once per document.';\n            doc.errors.push(new YAMLSemanticError(directive, msg));\n          }\n\n          try {\n            doc.version = resolveYamlDirective(doc, directive);\n          } catch (error) {\n            doc.errors.push(error);\n          }\n\n          hasDirectives = true;\n          break;\n\n        default:\n          if (name) {\n            var _msg3 = \"YAML only supports %TAG and %YAML directives, and not %\".concat(name);\n\n            doc.warnings.push(new YAMLWarning(directive, _msg3));\n          }\n\n      }\n\n      if (comment) directiveComments.push(comment);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (prevDoc && !hasDirectives && '1.1' === (doc.version || prevDoc.version || doc.options.version)) {\n    var copyTagPrefix = function copyTagPrefix(_ref2) {\n      var handle = _ref2.handle,\n          prefix = _ref2.prefix;\n      return {\n        handle: handle,\n        prefix: prefix\n      };\n    };\n\n    doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);\n    doc.version = prevDoc.version;\n  }\n\n  doc.commentBefore = directiveComments.join('\\n') || null;\n}\n\nfunction assertCollection(contents) {\n  if (contents instanceof Collection) return true;\n  throw new Error('Expected a YAML collection as document contents');\n}\n\nvar Document$1 = /*#__PURE__*/function () {\n  function Document(options) {\n    _classCallCheck(this, Document);\n\n    this.anchors = new Anchors(options.anchorPrefix);\n    this.commentBefore = null;\n    this.comment = null;\n    this.contents = null;\n    this.directivesEndMarker = null;\n    this.errors = [];\n    this.options = options;\n    this.schema = null;\n    this.tagPrefixes = [];\n    this.version = null;\n    this.warnings = [];\n  }\n\n  _createClass(Document, [{\n    key: \"add\",\n    value: function add(value) {\n      assertCollection(this.contents);\n      return this.contents.add(value);\n    }\n  }, {\n    key: \"addIn\",\n    value: function addIn(path, value) {\n      assertCollection(this.contents);\n      this.contents.addIn(path, value);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      assertCollection(this.contents);\n      return this.contents.delete(key);\n    }\n  }, {\n    key: \"deleteIn\",\n    value: function deleteIn(path) {\n      if (isEmptyPath(path)) {\n        if (this.contents == null) return false;\n        this.contents = null;\n        return true;\n      }\n\n      assertCollection(this.contents);\n      return this.contents.deleteIn(path);\n    }\n  }, {\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Document.defaults[this.version] || Document.defaults[this.options.version] || {};\n    }\n  }, {\n    key: \"get\",\n    value: function get(key, keepScalar) {\n      return this.contents instanceof Collection ? this.contents.get(key, keepScalar) : undefined;\n    }\n  }, {\n    key: \"getIn\",\n    value: function getIn(path, keepScalar) {\n      if (isEmptyPath(path)) return !keepScalar && this.contents instanceof Scalar ? this.contents.value : this.contents;\n      return this.contents instanceof Collection ? this.contents.getIn(path, keepScalar) : undefined;\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      return this.contents instanceof Collection ? this.contents.has(key) : false;\n    }\n  }, {\n    key: \"hasIn\",\n    value: function hasIn(path) {\n      if (isEmptyPath(path)) return this.contents !== undefined;\n      return this.contents instanceof Collection ? this.contents.hasIn(path) : false;\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      assertCollection(this.contents);\n      this.contents.set(key, value);\n    }\n  }, {\n    key: \"setIn\",\n    value: function setIn(path, value) {\n      if (isEmptyPath(path)) this.contents = value;else {\n        assertCollection(this.contents);\n        this.contents.setIn(path, value);\n      }\n    }\n  }, {\n    key: \"setSchema\",\n    value: function setSchema(id, customTags) {\n      if (!id && !customTags && this.schema) return;\n      if (typeof id === 'number') id = id.toFixed(1);\n\n      if (id === '1.0' || id === '1.1' || id === '1.2') {\n        if (this.version) this.version = id;else this.options.version = id;\n        delete this.options.schema;\n      } else if (id && typeof id === 'string') {\n        this.options.schema = id;\n      }\n\n      if (Array.isArray(customTags)) this.options.customTags = customTags;\n      var opt = Object.assign({}, this.getDefaults(), this.options);\n      this.schema = new Schema(opt);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(node, prevDoc) {\n      if (this.options.keepCstNodes) this.cstNode = node;\n      if (this.options.keepNodeTypes) this.type = 'DOCUMENT';\n      var _node$directives = node.directives,\n          directives = _node$directives === void 0 ? [] : _node$directives,\n          _node$contents = node.contents,\n          contents = _node$contents === void 0 ? [] : _node$contents,\n          directivesEndMarker = node.directivesEndMarker,\n          error = node.error,\n          valueRange = node.valueRange;\n\n      if (error) {\n        if (!error.source) error.source = this;\n        this.errors.push(error);\n      }\n\n      parseDirectives(this, directives, prevDoc);\n      if (directivesEndMarker) this.directivesEndMarker = true;\n      this.range = valueRange ? [valueRange.start, valueRange.end] : null;\n      this.setSchema();\n      this.anchors._cstAliases = [];\n      parseContents(this, contents);\n      this.anchors.resolveNodes();\n\n      if (this.options.prettyErrors) {\n        var _iterator = _createForOfIteratorHelper(this.errors),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _error = _step.value;\n            if (_error instanceof YAMLError) _error.makePretty();\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        var _iterator2 = _createForOfIteratorHelper(this.warnings),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var warn = _step2.value;\n            if (warn instanceof YAMLError) warn.makePretty();\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"listNonDefaultTags\",\n    value: function listNonDefaultTags() {\n      return listTagNames(this.contents).filter(function (t) {\n        return t.indexOf(Schema.defaultPrefix) !== 0;\n      });\n    }\n  }, {\n    key: \"setTagPrefix\",\n    value: function setTagPrefix(handle, prefix) {\n      if (handle[0] !== '!' || handle[handle.length - 1] !== '!') throw new Error('Handle must start and end with !');\n\n      if (prefix) {\n        var prev = this.tagPrefixes.find(function (p) {\n          return p.handle === handle;\n        });\n        if (prev) prev.prefix = prefix;else this.tagPrefixes.push({\n          handle: handle,\n          prefix: prefix\n        });\n      } else {\n        this.tagPrefixes = this.tagPrefixes.filter(function (p) {\n          return p.handle !== handle;\n        });\n      }\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON$1(arg, onAnchor) {\n      var _this = this;\n\n      var _this$options = this.options,\n          keepBlobsInJSON = _this$options.keepBlobsInJSON,\n          mapAsMap = _this$options.mapAsMap,\n          maxAliasCount = _this$options.maxAliasCount;\n      var keep = keepBlobsInJSON && (typeof arg !== 'string' || !(this.contents instanceof Scalar));\n      var ctx = {\n        doc: this,\n        indentStep: '  ',\n        keep: keep,\n        mapAsMap: keep && !!mapAsMap,\n        maxAliasCount: maxAliasCount,\n        stringify: stringify$1 // Requiring directly in Pair would create circular dependencies\n\n      };\n      var anchorNames = Object.keys(this.anchors.map);\n      if (anchorNames.length > 0) ctx.anchors = new Map(anchorNames.map(function (name) {\n        return [_this.anchors.map[name], {\n          alias: [],\n          aliasCount: 0,\n          count: 1\n        }];\n      }));\n\n      var res = toJSON(this.contents, arg, ctx);\n\n      if (typeof onAnchor === 'function' && ctx.anchors) {\n        var _iterator3 = _createForOfIteratorHelper(ctx.anchors.values()),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _step3$value = _step3.value,\n                count = _step3$value.count,\n                _res = _step3$value.res;\n            onAnchor(_res, count);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n\n      return res;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (this.errors.length > 0) throw new Error('Document with errors cannot be stringified');\n      var indentSize = this.options.indent;\n\n      if (!Number.isInteger(indentSize) || indentSize <= 0) {\n        var s = JSON.stringify(indentSize);\n        throw new Error(\"\\\"indent\\\" option must be a positive integer, not \".concat(s));\n      }\n\n      this.setSchema();\n      var lines = [];\n      var hasDirectives = false;\n\n      if (this.version) {\n        var vd = '%YAML 1.2';\n\n        if (this.schema.name === 'yaml-1.1') {\n          if (this.version === '1.0') vd = '%YAML:1.0';else if (this.version === '1.1') vd = '%YAML 1.1';\n        }\n\n        lines.push(vd);\n        hasDirectives = true;\n      }\n\n      var tagNames = this.listNonDefaultTags();\n      this.tagPrefixes.forEach(function (_ref) {\n        var handle = _ref.handle,\n            prefix = _ref.prefix;\n\n        if (tagNames.some(function (t) {\n          return t.indexOf(prefix) === 0;\n        })) {\n          lines.push(\"%TAG \".concat(handle, \" \").concat(prefix));\n          hasDirectives = true;\n        }\n      });\n      if (hasDirectives || this.directivesEndMarker) lines.push('---');\n\n      if (this.commentBefore) {\n        if (hasDirectives || !this.directivesEndMarker) lines.unshift('');\n        lines.unshift(this.commentBefore.replace(/^/gm, '#'));\n      }\n\n      var ctx = {\n        anchors: Object.create(null),\n        doc: this,\n        indent: '',\n        indentStep: ' '.repeat(indentSize),\n        stringify: stringify$1 // Requiring directly in nodes would create circular dependencies\n\n      };\n      var chompKeep = false;\n      var contentComment = null;\n\n      if (this.contents) {\n        if (this.contents instanceof Node) {\n          if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker)) lines.push('');\n          if (this.contents.commentBefore) lines.push(this.contents.commentBefore.replace(/^/gm, '#')); // top-level block scalars need to be indented if followed by a comment\n\n          ctx.forceBlockIndent = !!this.comment;\n          contentComment = this.contents.comment;\n        }\n\n        var onChompKeep = contentComment ? null : function () {\n          return chompKeep = true;\n        };\n        var body = stringify$1(this.contents, ctx, function () {\n          return contentComment = null;\n        }, onChompKeep);\n        lines.push(addComment(body, '', contentComment));\n      } else if (this.contents !== undefined) {\n        lines.push(stringify$1(this.contents, ctx));\n      }\n\n      if (this.comment) {\n        if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '') lines.push('');\n        lines.push(this.comment.replace(/^/gm, '#'));\n      }\n\n      return lines.join('\\n') + '\\n';\n    }\n  }]);\n\n  return Document;\n}();\n\n_defineProperty(Document$1, \"defaults\", documentOptions);\n\nfunction createNode(value) {\n  var wrapScalars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var tag = arguments.length > 2 ? arguments[2] : undefined;\n\n  if (tag === undefined && typeof wrapScalars === 'string') {\n    tag = wrapScalars;\n    wrapScalars = true;\n  }\n\n  var options = Object.assign({}, Document$1.defaults[defaultOptions.version], defaultOptions);\n  var schema = new Schema(options);\n  return schema.createNode(value, wrapScalars, tag);\n}\n\nvar Document = /*#__PURE__*/function (_YAMLDocument) {\n  _inherits(Document, _YAMLDocument);\n\n  var _super = _createSuper(Document);\n\n  function Document(options) {\n    _classCallCheck(this, Document);\n\n    return _super.call(this, Object.assign({}, defaultOptions, options));\n  }\n\n  return Document;\n}(Document$1);\n\nfunction parseAllDocuments(src, options) {\n  var stream = [];\n  var prev;\n\n  var _iterator = _createForOfIteratorHelper(parse$1(src)),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var cstDoc = _step.value;\n      var doc = new Document(options);\n      doc.parse(cstDoc, prev);\n      stream.push(doc);\n      prev = doc;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return stream;\n}\n\nfunction parseDocument(src, options) {\n  var cst = parse$1(src);\n  var doc = new Document(options).parse(cst[0]);\n\n  if (cst.length > 1) {\n    var errMsg = 'Source contains multiple documents; please use YAML.parseAllDocuments()';\n    doc.errors.unshift(new YAMLSemanticError(cst[1], errMsg));\n  }\n\n  return doc;\n}\n\nfunction parse(src, options) {\n  var doc = parseDocument(src, options);\n  doc.warnings.forEach(function (warning) {\n    return warn(warning);\n  });\n  if (doc.errors.length > 0) throw doc.errors[0];\n  return doc.toJSON();\n}\n\nfunction stringify(value, options) {\n  var doc = new Document(options);\n  doc.contents = value;\n  return String(doc);\n}\n\nvar YAML = {\n  createNode: createNode,\n  defaultOptions: defaultOptions,\n  Document: Document,\n  parse: parse,\n  parseAllDocuments: parseAllDocuments,\n  parseCST: parse$1,\n  parseDocument: parseDocument,\n  scalarOptions: scalarOptions,\n  stringify: stringify\n};\n\nexport { YAML };\n", "module.exports = require('./dist').YAML\n", "/* eslint-disable @typescript-eslint/no-require-imports */\n\nimport parseJsonType from 'parse-json';\nimport yamlType from 'yaml';\nimport importFreshType from 'import-fresh';\nimport { LoaderSync } from './index';\nimport { LoadersSync } from './types';\n\nlet importFresh: typeof importFreshType;\nconst loadJs: LoaderSync = function loadJs(filepath) {\n  if (importFresh === undefined) {\n    importFresh = require('import-fresh');\n  }\n\n  const result = importFresh(filepath);\n  return result;\n};\n\nlet parseJson: typeof parseJsonType;\nconst loadJson: LoaderSync = function loadJson(filepath, content) {\n  if (parseJson === undefined) {\n    parseJson = require('parse-json');\n  }\n\n  try {\n    const result = parseJson(content);\n    return result;\n  } catch (error) {\n    error.message = `JSON Error in ${filepath}:\\n${error.message}`;\n    throw error;\n  }\n};\n\nlet yaml: typeof yamlType;\nconst loadYaml: LoaderSync = function loadYaml(filepath, content) {\n  if (yaml === undefined) {\n    yaml = require('yaml');\n  }\n\n  try {\n    const result = yaml.parse(content, { prettyErrors: true });\n    return result;\n  } catch (error) {\n    error.message = `YAML Error in ${filepath}:\\n${error.message}`;\n    throw error;\n  }\n};\n\nconst loaders: LoadersSync = { loadJs, loadJson, loadYaml };\n\nexport { loaders };\n", "// Resolves property names or property paths defined with period-delimited\n// strings or arrays of strings. Property names that are found on the source\n// object are used directly (even if they include a period).\n// Nested property names that include periods, within a path, are only\n// understood in array paths.\nfunction getPropertyByPath(\n  source: { [key: string]: unknown },\n  path: string | Array<string>,\n): unknown {\n  if (\n    typeof path === 'string' &&\n    Object.prototype.hasOwnProperty.call(source, path)\n  ) {\n    return source[path];\n  }\n\n  const parsedPath = typeof path === 'string' ? path.split('.') : path;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return parsedPath.reduce((previous: any, key): unknown => {\n    if (previous === undefined) {\n      return previous;\n    }\n    return previous[key];\n  }, source);\n}\n\nexport { getPropertyByPath };\n", "import path from 'path';\nimport { loaders } from './loaders';\nimport { getPropertyByPath } from './getPropertyByPath';\nimport {\n  CosmiconfigResult,\n  ExplorerOptions,\n  ExplorerOptionsSync,\n  Cache,\n  LoadedFileContent,\n} from './types';\nimport { Loader } from './index';\n\nclass ExplorerBase<T extends ExplorerOptions | ExplorerOptionsSync> {\n  protected readonly loadCache?: Cache;\n  protected readonly searchCache?: Cache;\n  protected readonly config: T;\n\n  public constructor(options: T) {\n    if (options.cache === true) {\n      this.loadCache = new Map();\n      this.searchCache = new Map();\n    }\n\n    this.config = options;\n    this.validateConfig();\n  }\n\n  public clearLoadCache(): void {\n    if (this.loadCache) {\n      this.loadCache.clear();\n    }\n  }\n\n  public clearSearchCache(): void {\n    if (this.searchCache) {\n      this.searchCache.clear();\n    }\n  }\n\n  public clearCaches(): void {\n    this.clearLoadCache();\n    this.clearSearchCache();\n  }\n\n  private validateConfig(): void {\n    const config = this.config;\n\n    config.searchPlaces.forEach((place): void => {\n      const loaderKey = path.extname(place) || 'noExt';\n      const loader = config.loaders[loaderKey];\n      if (!loader) {\n        throw new Error(\n          `No loader specified for ${getExtensionDescription(\n            place,\n          )}, so searchPlaces item \"${place}\" is invalid`,\n        );\n      }\n\n      if (typeof loader !== 'function') {\n        throw new Error(\n          `loader for ${getExtensionDescription(\n            place,\n          )} is not a function (type provided: \"${typeof loader}\"), so searchPlaces item \"${place}\" is invalid`,\n        );\n      }\n    });\n  }\n\n  protected shouldSearchStopWithResult(result: CosmiconfigResult): boolean {\n    if (result === null) return false;\n    if (result.isEmpty && this.config.ignoreEmptySearchPlaces) return false;\n    return true;\n  }\n\n  protected nextDirectoryToSearch(\n    currentDir: string,\n    currentResult: CosmiconfigResult,\n  ): string | null {\n    if (this.shouldSearchStopWithResult(currentResult)) {\n      return null;\n    }\n    const nextDir = nextDirUp(currentDir);\n    if (nextDir === currentDir || currentDir === this.config.stopDir) {\n      return null;\n    }\n    return nextDir;\n  }\n\n  private loadPackageProp(filepath: string, content: string): unknown {\n    const parsedContent = loaders.loadJson(filepath, content);\n    const packagePropValue = getPropertyByPath(\n      parsedContent,\n      this.config.packageProp,\n    );\n    return packagePropValue || null;\n  }\n\n  protected getLoaderEntryForFile(filepath: string): Loader {\n    if (path.basename(filepath) === 'package.json') {\n      const loader = this.loadPackageProp.bind(this);\n      return loader;\n    }\n\n    const loaderKey = path.extname(filepath) || 'noExt';\n\n    const loader = this.config.loaders[loaderKey];\n\n    if (!loader) {\n      throw new Error(\n        `No loader specified for ${getExtensionDescription(filepath)}`,\n      );\n    }\n\n    return loader;\n  }\n\n  protected loadedContentToCosmiconfigResult(\n    filepath: string,\n    loadedContent: LoadedFileContent,\n  ): CosmiconfigResult {\n    if (loadedContent === null) {\n      return null;\n    }\n    if (loadedContent === undefined) {\n      return { filepath, config: undefined, isEmpty: true };\n    }\n    return { config: loadedContent, filepath };\n  }\n\n  protected validateFilePath(filepath: string): void {\n    if (!filepath) {\n      throw new Error('load must pass a non-empty string');\n    }\n  }\n}\n\nfunction nextDirUp(dir: string): string {\n  return path.dirname(dir);\n}\n\nfunction getExtensionDescription(filepath: string): string {\n  const ext = path.extname(filepath);\n  return ext ? `extension \"${ext}\"` : 'files without extensions';\n}\n\nexport { ExplorerBase, getExtensionDescription };\n", "import fs from 'fs';\n\nasync function fsReadFileAsync(\n  pathname: string,\n  encoding: BufferEncoding,\n): Promise<string> {\n  return new Promise((resolve, reject): void => {\n    fs.readFile(pathname, encoding, (error, contents): void => {\n      if (error) {\n        reject(error);\n        return;\n      }\n\n      resolve(contents);\n    });\n  });\n}\n\ninterface Options {\n  throwNotFound?: boolean;\n}\n\nasync function readFile(\n  filepath: string,\n  options: Options = {},\n): Promise<string | null> {\n  const throwNotFound = options.throwNotFound === true;\n\n  try {\n    const content = await fsReadFileAsync(filepath, 'utf8');\n\n    return content;\n  } catch (error) {\n    if (\n      throwNotFound === false &&\n      (error.code === 'ENOENT' || error.code === 'EISDIR')\n    ) {\n      return null;\n    }\n\n    throw error;\n  }\n}\n\nfunction readFileSync(filepath: string, options: Options = {}): string | null {\n  const throwNotFound = options.throwNotFound === true;\n\n  try {\n    const content = fs.readFileSync(filepath, 'utf8');\n\n    return content;\n  } catch (error) {\n    if (\n      throwNotFound === false &&\n      (error.code === 'ENOENT' || error.code === 'EISDIR')\n    ) {\n      return null;\n    }\n\n    throw error;\n  }\n}\n\nexport { readFile, readFileSync };\n", "import { Cache, CosmiconfigResult } from './types';\n\nasync function cacheWrapper(\n  cache: Cache,\n  key: string,\n  fn: () => Promise<CosmiconfigResult>,\n): Promise<CosmiconfigResult> {\n  const cached = cache.get(key);\n  if (cached !== undefined) {\n    return cached;\n  }\n\n  const result = await fn();\n  cache.set(key, result);\n  return result;\n}\n\nfunction cacheWrapperSync(\n  cache: Cache,\n  key: string,\n  fn: () => CosmiconfigResult,\n): CosmiconfigResult {\n  const cached = cache.get(key);\n  if (cached !== undefined) {\n    return cached;\n  }\n\n  const result = fn();\n  cache.set(key, result);\n  return result;\n}\n\nexport { cacheWrapper, cacheWrapperSync };\n", "'use strict';\nconst {promisify} = require('util');\nconst fs = require('fs');\n\nasync function isType(fsStatType, statsMethodName, filePath) {\n\tif (typeof filePath !== 'string') {\n\t\tthrow new TypeError(`Expected a string, got ${typeof filePath}`);\n\t}\n\n\ttry {\n\t\tconst stats = await promisify(fs[fsStatType])(filePath);\n\t\treturn stats[statsMethodName]();\n\t} catch (error) {\n\t\tif (error.code === 'ENOENT') {\n\t\t\treturn false;\n\t\t}\n\n\t\tthrow error;\n\t}\n}\n\nfunction isTypeSync(fsStatType, statsMethodName, filePath) {\n\tif (typeof filePath !== 'string') {\n\t\tthrow new TypeError(`Expected a string, got ${typeof filePath}`);\n\t}\n\n\ttry {\n\t\treturn fs[fsStatType](filePath)[statsMethodName]();\n\t} catch (error) {\n\t\tif (error.code === 'ENOENT') {\n\t\t\treturn false;\n\t\t}\n\n\t\tthrow error;\n\t}\n}\n\nexports.isFile = isType.bind(null, 'stat', 'isFile');\nexports.isDirectory = isType.bind(null, 'stat', 'isDirectory');\nexports.isSymlink = isType.bind(null, 'lstat', 'isSymbolicLink');\nexports.isFileSync = isTypeSync.bind(null, 'statSync', 'isFile');\nexports.isDirectorySync = isTypeSync.bind(null, 'statSync', 'isDirectory');\nexports.isSymlinkSync = isTypeSync.bind(null, 'lstatSync', 'isSymbolicLink');\n", "import path from 'path';\nimport { isDirectory, isDirectorySync } from 'path-type';\n\nasync function getDirectory(filepath: string): Promise<string> {\n  const filePathIsDirectory = await isDirectory(filepath);\n\n  if (filePathIsDirectory === true) {\n    return filepath;\n  }\n\n  const directory = path.dirname(filepath);\n\n  return directory;\n}\n\nfunction getDirectorySync(filepath: string): string {\n  const filePathIsDirectory = isDirectorySync(filepath);\n\n  if (filePathIsDirectory === true) {\n    return filepath;\n  }\n\n  const directory = path.dirname(filepath);\n\n  return directory;\n}\n\nexport { getDirectory, getDirectorySync };\n", "import path from 'path';\nimport { ExplorerBase } from './ExplorerBase';\nimport { readFile } from './readFile';\nimport { cacheWrapper } from './cacheWrapper';\nimport { getDirectory } from './getDirectory';\nimport { CosmiconfigResult, ExplorerOptions, LoadedFileContent } from './types';\n\nclass Explorer extends ExplorerBase<ExplorerOptions> {\n  public constructor(options: ExplorerOptions) {\n    super(options);\n  }\n\n  public async search(\n    searchFrom: string = process.cwd(),\n  ): Promise<CosmiconfigResult> {\n    const startDirectory = await getDirectory(searchFrom);\n    const result = await this.searchFromDirectory(startDirectory);\n\n    return result;\n  }\n\n  private async searchFromDirectory(dir: string): Promise<CosmiconfigResult> {\n    const absoluteDir = path.resolve(process.cwd(), dir);\n\n    const run = async (): Promise<CosmiconfigResult> => {\n      const result = await this.searchDirectory(absoluteDir);\n      const nextDir = this.nextDirectoryToSearch(absoluteDir, result);\n\n      if (nextDir) {\n        return this.searchFromDirectory(nextDir);\n      }\n\n      const transformResult = await this.config.transform(result);\n\n      return transformResult;\n    };\n\n    if (this.searchCache) {\n      return cacheWrapper(this.searchCache, absoluteDir, run);\n    }\n\n    return run();\n  }\n\n  private async searchDirectory(dir: string): Promise<CosmiconfigResult> {\n    for await (const place of this.config.searchPlaces) {\n      const placeResult = await this.loadSearchPlace(dir, place);\n\n      if (this.shouldSearchStopWithResult(placeResult) === true) {\n        return placeResult;\n      }\n    }\n\n    // config not found\n    return null;\n  }\n\n  private async loadSearchPlace(\n    dir: string,\n    place: string,\n  ): Promise<CosmiconfigResult> {\n    const filepath = path.join(dir, place);\n    const fileContents = await readFile(filepath);\n\n    const result = await this.createCosmiconfigResult(filepath, fileContents);\n\n    return result;\n  }\n\n  private async loadFileContent(\n    filepath: string,\n    content: string | null,\n  ): Promise<LoadedFileContent> {\n    if (content === null) {\n      return null;\n    }\n    if (content.trim() === '') {\n      return undefined;\n    }\n    const loader = this.getLoaderEntryForFile(filepath);\n    const loaderResult = await loader(filepath, content);\n    return loaderResult;\n  }\n\n  private async createCosmiconfigResult(\n    filepath: string,\n    content: string | null,\n  ): Promise<CosmiconfigResult> {\n    const fileContent = await this.loadFileContent(filepath, content);\n    const result = this.loadedContentToCosmiconfigResult(filepath, fileContent);\n\n    return result;\n  }\n\n  public async load(filepath: string): Promise<CosmiconfigResult> {\n    this.validateFilePath(filepath);\n    const absoluteFilePath = path.resolve(process.cwd(), filepath);\n\n    const runLoad = async (): Promise<CosmiconfigResult> => {\n      const fileContents = await readFile(absoluteFilePath, {\n        throwNotFound: true,\n      });\n\n      const result = await this.createCosmiconfigResult(\n        absoluteFilePath,\n        fileContents,\n      );\n\n      const transformResult = await this.config.transform(result);\n\n      return transformResult;\n    };\n\n    if (this.loadCache) {\n      return cacheWrapper(this.loadCache, absoluteFilePath, runLoad);\n    }\n\n    return runLoad();\n  }\n}\n\nexport { Explorer };\n", "import path from 'path';\nimport { ExplorerBase } from './ExplorerBase';\nimport { readFileSync } from './readFile';\nimport { cacheWrapperSync } from './cacheWrapper';\nimport { getDirectorySync } from './getDirectory';\nimport {\n  CosmiconfigResult,\n  ExplorerOptionsSync,\n  LoadedFileContent,\n} from './types';\n\nclass ExplorerSync extends ExplorerBase<ExplorerOptionsSync> {\n  public constructor(options: ExplorerOptionsSync) {\n    super(options);\n  }\n\n  public searchSync(searchFrom: string = process.cwd()): CosmiconfigResult {\n    const startDirectory = getDirectorySync(searchFrom);\n    const result = this.searchFromDirectorySync(startDirectory);\n\n    return result;\n  }\n\n  private searchFromDirectorySync(dir: string): CosmiconfigResult {\n    const absoluteDir = path.resolve(process.cwd(), dir);\n\n    const run = (): CosmiconfigResult => {\n      const result = this.searchDirectorySync(absoluteDir);\n      const nextDir = this.nextDirectoryToSearch(absoluteDir, result);\n\n      if (nextDir) {\n        return this.searchFromDirectorySync(nextDir);\n      }\n\n      const transformResult = this.config.transform(result);\n\n      return transformResult;\n    };\n\n    if (this.searchCache) {\n      return cacheWrapperSync(this.searchCache, absoluteDir, run);\n    }\n\n    return run();\n  }\n\n  private searchDirectorySync(dir: string): CosmiconfigResult {\n    for (const place of this.config.searchPlaces) {\n      const placeResult = this.loadSearchPlaceSync(dir, place);\n\n      if (this.shouldSearchStopWithResult(placeResult) === true) {\n        return placeResult;\n      }\n    }\n\n    // config not found\n    return null;\n  }\n\n  private loadSearchPlaceSync(dir: string, place: string): CosmiconfigResult {\n    const filepath = path.join(dir, place);\n    const content = readFileSync(filepath);\n\n    const result = this.createCosmiconfigResultSync(filepath, content);\n\n    return result;\n  }\n\n  private loadFileContentSync(\n    filepath: string,\n    content: string | null,\n  ): LoadedFileContent {\n    if (content === null) {\n      return null;\n    }\n    if (content.trim() === '') {\n      return undefined;\n    }\n    const loader = this.getLoaderEntryForFile(filepath);\n    const loaderResult = loader(filepath, content);\n\n    return loaderResult;\n  }\n\n  private createCosmiconfigResultSync(\n    filepath: string,\n    content: string | null,\n  ): CosmiconfigResult {\n    const fileContent = this.loadFileContentSync(filepath, content);\n    const result = this.loadedContentToCosmiconfigResult(filepath, fileContent);\n\n    return result;\n  }\n\n  public loadSync(filepath: string): CosmiconfigResult {\n    this.validateFilePath(filepath);\n    const absoluteFilePath = path.resolve(process.cwd(), filepath);\n\n    const runLoadSync = (): CosmiconfigResult => {\n      const content = readFileSync(absoluteFilePath, { throwNotFound: true });\n      const cosmiconfigResult = this.createCosmiconfigResultSync(\n        absoluteFilePath,\n        content,\n      );\n\n      const transformResult = this.config.transform(cosmiconfigResult);\n\n      return transformResult;\n    };\n\n    if (this.loadCache) {\n      return cacheWrapperSync(this.loadCache, absoluteFilePath, runLoadSync);\n    }\n\n    return runLoadSync();\n  }\n}\n\nexport { ExplorerSync };\n", "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n//# sourceMappingURL=types.js.map", "/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\nimport os from 'os';\nimport { Explorer } from './Explorer';\nimport { ExplorerSync } from './ExplorerSync';\nimport { loaders } from './loaders';\nimport {\n  Config,\n  CosmiconfigResult,\n  ExplorerOptions,\n  ExplorerOptionsSync,\n  Loaders,\n  LoadersSync,\n} from './types';\n\ntype LoaderResult = Config | null;\nexport type Loader =\n  | ((filepath: string, content: string) => Promise<LoaderResult>)\n  | LoaderSync;\nexport type LoaderSync = (filepath: string, content: string) => LoaderResult;\n\nexport type Transform =\n  | ((CosmiconfigResult: CosmiconfigResult) => Promise<CosmiconfigResult>)\n  | TransformSync;\n\nexport type TransformSync = (\n  CosmiconfigResult: CosmiconfigResult,\n) => CosmiconfigResult;\n\ninterface OptionsBase {\n  packageProp?: string | Array<string>;\n  searchPlaces?: Array<string>;\n  ignoreEmptySearchPlaces?: boolean;\n  stopDir?: string;\n  cache?: boolean;\n}\n\nexport interface Options extends OptionsBase {\n  loaders?: Loaders;\n  transform?: Transform;\n}\n\nexport interface OptionsSync extends OptionsBase {\n  loaders?: LoadersSync;\n  transform?: TransformSync;\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\nfunction cosmiconfig(moduleName: string, options: Options = {}) {\n  const normalizedOptions: ExplorerOptions = normalizeOptions(\n    moduleName,\n    options,\n  );\n\n  const explorer = new Explorer(normalizedOptions);\n\n  return {\n    search: explorer.search.bind(explorer),\n    load: explorer.load.bind(explorer),\n    clearLoadCache: explorer.clearLoadCache.bind(explorer),\n    clearSearchCache: explorer.clearSearchCache.bind(explorer),\n    clearCaches: explorer.clearCaches.bind(explorer),\n  } as const;\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\nfunction cosmiconfigSync(moduleName: string, options: OptionsSync = {}) {\n  const normalizedOptions: ExplorerOptionsSync = normalizeOptions(\n    moduleName,\n    options,\n  );\n\n  const explorerSync = new ExplorerSync(normalizedOptions);\n\n  return {\n    search: explorerSync.searchSync.bind(explorerSync),\n    load: explorerSync.loadSync.bind(explorerSync),\n    clearLoadCache: explorerSync.clearLoadCache.bind(explorerSync),\n    clearSearchCache: explorerSync.clearSearchCache.bind(explorerSync),\n    clearCaches: explorerSync.clearCaches.bind(explorerSync),\n  } as const;\n}\n\n// do not allow mutation of default loaders. Make sure it is set inside options\nconst defaultLoaders = Object.freeze({\n  '.cjs': loaders.loadJs,\n  '.js': loaders.loadJs,\n  '.json': loaders.loadJson,\n  '.yaml': loaders.loadYaml,\n  '.yml': loaders.loadYaml,\n  noExt: loaders.loadYaml,\n} as const);\n\nconst identity: TransformSync = function identity(x) {\n  return x;\n};\n\nfunction normalizeOptions(\n  moduleName: string,\n  options: OptionsSync,\n): ExplorerOptionsSync;\nfunction normalizeOptions(\n  moduleName: string,\n  options: Options,\n): ExplorerOptions;\nfunction normalizeOptions(\n  moduleName: string,\n  options: Options | OptionsSync,\n): ExplorerOptions | ExplorerOptionsSync {\n  const defaults: ExplorerOptions | ExplorerOptionsSync = {\n    packageProp: moduleName,\n    searchPlaces: [\n      'package.json',\n      `.${moduleName}rc`,\n      `.${moduleName}rc.json`,\n      `.${moduleName}rc.yaml`,\n      `.${moduleName}rc.yml`,\n      `.${moduleName}rc.js`,\n      `.${moduleName}rc.cjs`,\n      `.config/${moduleName}rc`,\n      `.config/${moduleName}rc.json`,\n      `.config/${moduleName}rc.yaml`,\n      `.config/${moduleName}rc.yml`,\n      `.config/${moduleName}rc.js`,\n      `.config/${moduleName}rc.cjs`,\n      `${moduleName}.config.js`,\n      `${moduleName}.config.cjs`,\n    ],\n    ignoreEmptySearchPlaces: true,\n    stopDir: os.homedir(),\n    cache: true,\n    transform: identity,\n    loaders: defaultLoaders,\n  };\n\n  const normalizedOptions: ExplorerOptions | ExplorerOptionsSync = {\n    ...defaults,\n    ...options,\n    loaders: {\n      ...defaults.loaders,\n      ...options.loaders,\n    },\n  };\n\n  return normalizedOptions;\n}\n\nexport { cosmiconfig, cosmiconfigSync, defaultLoaders };\n", "\"use strict\";\n\nconst p = require('path');\n\nconst resolve = require('resolve'); // const printAST = require('ast-pretty-print')\n\n\nconst macrosRegex = /[./]macro(\\.c?js)?$/;\n\nconst testMacrosRegex = v => macrosRegex.test(v); // https://stackoverflow.com/a/32749533/971592\n\n\nclass MacroError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'MacroError';\n    /* istanbul ignore else */\n\n    if (typeof Error.captureStackTrace === 'function') {\n      Error.captureStackTrace(this, this.constructor);\n    } else if (!this.stack) {\n      this.stack = new Error(message).stack;\n    }\n  }\n\n}\n\nlet _configExplorer = null;\n\nfunction getConfigExplorer() {\n  return _configExplorer = _configExplorer || // Lazy load cosmiconfig since it is a relatively large bundle\n  require('cosmiconfig').cosmiconfigSync('babel-plugin-macros', {\n    searchPlaces: ['package.json', '.babel-plugin-macrosrc', '.babel-plugin-macrosrc.json', '.babel-plugin-macrosrc.yaml', '.babel-plugin-macrosrc.yml', '.babel-plugin-macrosrc.js', 'babel-plugin-macros.config.js'],\n    packageProp: 'babelMacros'\n  });\n}\n\nfunction createMacro(macro, options = {}) {\n  if (options.configName === 'options') {\n    throw new Error(`You cannot use the configName \"options\". It is reserved for babel-plugin-macros.`);\n  }\n\n  macroWrapper.isBabelMacro = true;\n  macroWrapper.options = options;\n  return macroWrapper;\n\n  function macroWrapper(args) {\n    const {\n      source,\n      isBabelMacrosCall\n    } = args;\n\n    if (!isBabelMacrosCall) {\n      throw new MacroError(`The macro you imported from \"${source}\" is being executed outside the context of compilation with babel-plugin-macros. ` + `This indicates that you don't have the babel plugin \"babel-plugin-macros\" configured correctly. ` + `Please see the documentation for how to configure babel-plugin-macros properly: ` + 'https://github.com/kentcdodds/babel-plugin-macros/blob/master/other/docs/user.md');\n    }\n\n    return macro(args);\n  }\n}\n\nfunction nodeResolvePath(source, basedir) {\n  return resolve.sync(source, {\n    basedir,\n    extensions: ['.js', '.ts', '.tsx', '.mjs', '.cjs', '.jsx'],\n    // This is here to support the package being globally installed\n    // read more: https://github.com/kentcdodds/babel-plugin-macros/pull/138\n    paths: [p.resolve(__dirname, '../../')]\n  });\n}\n\nfunction macrosPlugin(babel, // istanbul doesn't like the default of an object for the plugin options\n// but I think older versions of babel didn't always pass options\n// istanbul ignore next\n{\n  require: _require = require,\n  resolvePath = nodeResolvePath,\n  isMacrosName = testMacrosRegex,\n  ...options\n} = {}) {\n  function interopRequire(path) {\n    // eslint-disable-next-line import/no-dynamic-require\n    const o = _require(path);\n\n    return o && o.__esModule && o.default ? o.default : o;\n  }\n\n  return {\n    name: 'macros',\n    visitor: {\n      Program(progPath, state) {\n        progPath.traverse({\n          ImportDeclaration(path) {\n            const isMacros = looksLike(path, {\n              node: {\n                source: {\n                  value: v => isMacrosName(v)\n                }\n              }\n            });\n\n            if (!isMacros) {\n              return;\n            }\n\n            const imports = path.node.specifiers.map(s => ({\n              localName: s.local.name,\n              importedName: s.type === 'ImportDefaultSpecifier' ? 'default' : s.imported.name\n            }));\n            const source = path.node.source.value;\n            const result = applyMacros({\n              path,\n              imports,\n              source,\n              state,\n              babel,\n              interopRequire,\n              resolvePath,\n              options\n            });\n\n            if (!result || !result.keepImports) {\n              path.remove();\n            }\n          },\n\n          VariableDeclaration(path) {\n            const isMacros = child => looksLike(child, {\n              node: {\n                init: {\n                  callee: {\n                    type: 'Identifier',\n                    name: 'require'\n                  },\n                  arguments: args => args.length === 1 && isMacrosName(args[0].value)\n                }\n              }\n            });\n\n            path.get('declarations').filter(isMacros).forEach(child => {\n              const imports = child.node.id.name ? [{\n                localName: child.node.id.name,\n                importedName: 'default'\n              }] : child.node.id.properties.map(property => ({\n                localName: property.value.name,\n                importedName: property.key.name\n              }));\n              const call = child.get('init');\n              const source = call.node.arguments[0].value;\n              const result = applyMacros({\n                path: call,\n                imports,\n                source,\n                state,\n                babel,\n                interopRequire,\n                resolvePath,\n                options\n              });\n\n              if (!result || !result.keepImports) {\n                child.remove();\n              }\n            });\n          }\n\n        });\n      }\n\n    }\n  };\n} // eslint-disable-next-line complexity\n\n\nfunction applyMacros({\n  path,\n  imports,\n  source,\n  state,\n  babel,\n  interopRequire,\n  resolvePath,\n  options\n}) {\n  /* istanbul ignore next (pretty much only useful for astexplorer I think) */\n  const {\n    file: {\n      opts: {\n        filename = ''\n      }\n    }\n  } = state;\n  let hasReferences = false;\n  const referencePathsByImportName = imports.reduce((byName, {\n    importedName,\n    localName\n  }) => {\n    const binding = path.scope.getBinding(localName);\n    byName[importedName] = binding.referencePaths;\n    hasReferences = hasReferences || Boolean(byName[importedName].length);\n    return byName;\n  }, {});\n  const isRelative = source.indexOf('.') === 0;\n  const requirePath = resolvePath(source, p.dirname(getFullFilename(filename)));\n  const macro = interopRequire(requirePath);\n\n  if (!macro.isBabelMacro) {\n    throw new Error(`The macro imported from \"${source}\" must be wrapped in \"createMacro\" ` + `which you can get from \"babel-plugin-macros\". ` + `Please refer to the documentation to see how to do this properly: https://github.com/kentcdodds/babel-plugin-macros/blob/master/other/docs/author.md#writing-a-macro`);\n  }\n\n  const config = getConfig(macro, filename, source, options);\n  let result;\n\n  try {\n    /**\n     * Other plugins that run before babel-plugin-macros might use path.replace, where a path is\n     * put into its own replacement. Apparently babel does not update the scope after such\n     * an operation. As a remedy, the whole scope is traversed again with an empty \"Identifier\"\n     * visitor - this makes the problem go away.\n     *\n     * See: https://github.com/kentcdodds/import-all.macro/issues/7\n     */\n    state.file.scope.path.traverse({\n      Identifier() {}\n\n    });\n    result = macro({\n      references: referencePathsByImportName,\n      source,\n      state,\n      babel,\n      config,\n      isBabelMacrosCall: true\n    });\n  } catch (error) {\n    if (error.name === 'MacroError') {\n      throw error;\n    }\n\n    error.message = `${source}: ${error.message}`;\n\n    if (!isRelative) {\n      error.message = `${error.message} Learn more: https://www.npmjs.com/package/${source.replace( // remove everything after package name\n      // @org/package/macro -> @org/package\n      // package/macro      -> package\n      /^((?:@[^/]+\\/)?[^/]+).*/, '$1')}`;\n    }\n\n    throw error;\n  }\n\n  return result;\n}\n\nfunction getConfigFromFile(configName, filename) {\n  try {\n    const loaded = getConfigExplorer().search(filename);\n\n    if (loaded) {\n      return {\n        options: loaded.config[configName],\n        path: loaded.filepath\n      };\n    }\n  } catch (e) {\n    return {\n      error: e\n    };\n  }\n\n  return {};\n}\n\nfunction getConfigFromOptions(configName, options) {\n  if (options.hasOwnProperty(configName)) {\n    if (options[configName] && typeof options[configName] !== 'object') {\n      // eslint-disable-next-line no-console\n      console.error(`The macro plugin options' ${configName} property was not an object or null.`);\n    } else {\n      return {\n        options: options[configName]\n      };\n    }\n  }\n\n  return {};\n}\n\nfunction getConfig(macro, filename, source, options) {\n  const {\n    configName\n  } = macro.options;\n\n  if (configName) {\n    const fileConfig = getConfigFromFile(configName, filename);\n    const optionsConfig = getConfigFromOptions(configName, options);\n\n    if (optionsConfig.options === undefined && fileConfig.options === undefined && fileConfig.error !== undefined) {\n      // eslint-disable-next-line no-console\n      console.error(`There was an error trying to load the config \"${configName}\" ` + `for the macro imported from \"${source}. ` + `Please see the error thrown for more information.`);\n      throw fileConfig.error;\n    }\n\n    if (fileConfig.options !== undefined && optionsConfig.options !== undefined && typeof fileConfig.options !== 'object') {\n      throw new Error(`${fileConfig.path} specified a ${configName} config of type ` + `${typeof optionsConfig.options}, but the the macros plugin's ` + `options.${configName} did contain an object. Both configs must ` + `contain objects for their options to be mergeable.`);\n    }\n\n    return { ...optionsConfig.options,\n      ...fileConfig.options\n    };\n  }\n\n  return undefined;\n}\n/*\n istanbul ignore next\n because this is hard to test\n and not worth it...\n */\n\n\nfunction getFullFilename(filename) {\n  if (p.isAbsolute(filename)) {\n    return filename;\n  }\n\n  return p.join(process.cwd(), filename);\n}\n\nfunction looksLike(a, b) {\n  return a && b && Object.keys(b).every(bKey => {\n    const bVal = b[bKey];\n    const aVal = a[bKey];\n\n    if (typeof bVal === 'function') {\n      return bVal(aVal);\n    }\n\n    return isPrimitive(bVal) ? bVal === aVal : looksLike(aVal, bVal);\n  });\n}\n\nfunction isPrimitive(val) {\n  // eslint-disable-next-line\n  return val == null || /^[sbn]/.test(typeof val);\n}\n\nmodule.exports = macrosPlugin;\nObject.assign(module.exports, {\n  createMacro,\n  MacroError\n});", "import _createForOfIteratorHelperLoose from '@babel/runtime/helpers/esm/createForOfIteratorHelperLoose';\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\nimport nodePath from 'path';\nimport { SourceMapGenerator } from 'source-map';\nimport convert from 'convert-source-map';\nimport findRoot from 'find-root';\nimport memoize from '@emotion/memoize';\nimport hashString from '@emotion/hash';\nimport escapeRegexp from 'escape-string-regexp';\nimport { serializeStyles } from '@emotion/serialize';\nimport { compile } from 'stylis';\nimport { addDefault, addNamed } from '@babel/helper-module-imports';\nimport { createMacro } from 'babel-plugin-macros';\n\n/*\ntype LabelFormatOptions = {\n  name: string,\n  path: string\n}\n*/\n\nvar invalidClassNameCharacters = /[!\"#$%&'()*+,./:;<=>?@[\\]^`|}~{]/g;\n\nvar sanitizeLabelPart = function sanitizeLabelPart(labelPart\n/*: string */\n) {\n  return labelPart.trim().replace(invalidClassNameCharacters, '-');\n};\n\nfunction getLabel(identifierName\n/* ?: string */\n, labelFormat\n/* ?: string | (LabelFormatOptions => string) */\n, filename\n/*: string */\n) {\n  if (!identifierName) return null;\n  var sanitizedName = sanitizeLabelPart(identifierName);\n\n  if (!labelFormat) {\n    return sanitizedName;\n  }\n\n  if (typeof labelFormat === 'function') {\n    return labelFormat({\n      name: sanitizedName,\n      path: filename\n    });\n  }\n\n  var parsedPath = nodePath.parse(filename);\n  var localDirname = nodePath.basename(parsedPath.dir);\n  var localFilename = parsedPath.name;\n\n  if (localFilename === 'index') {\n    localFilename = localDirname;\n  }\n\n  return labelFormat.replace(/\\[local\\]/gi, sanitizedName).replace(/\\[filename\\]/gi, sanitizeLabelPart(localFilename)).replace(/\\[dirname\\]/gi, sanitizeLabelPart(localDirname));\n}\n\nfunction getLabelFromPath(path, state, t) {\n  return getLabel(getIdentifierName(path, t), state.opts.labelFormat, state.file.opts.filename);\n}\n\nvar getObjPropertyLikeName = function getObjPropertyLikeName(path, t) {\n  if (!t.isObjectProperty(path) && !t.isObjectMethod(path) || path.node.computed) {\n    return null;\n  }\n\n  if (t.isIdentifier(path.node.key)) {\n    return path.node.key.name;\n  }\n\n  if (t.isStringLiteral(path.node.key)) {\n    return path.node.key.value.replace(/\\s+/g, '-');\n  }\n\n  return null;\n};\n\nfunction getDeclaratorName(path, t) {\n  var parent = path.findParent(function (p) {\n    return p.isVariableDeclarator() || p.isAssignmentExpression() || p.isFunctionDeclaration() || p.isFunctionExpression() || p.isArrowFunctionExpression() || p.isObjectProperty() || p.isObjectMethod();\n  });\n\n  if (!parent) {\n    return '';\n  } // we probably have a css call assigned to a variable\n  // so we'll just return the variable name\n\n\n  if (parent.isVariableDeclarator()) {\n    if (t.isIdentifier(parent.node.id)) {\n      return parent.node.id.name;\n    }\n\n    return '';\n  }\n\n  if (parent.isAssignmentExpression()) {\n    var left = parent.node.left;\n\n    if (t.isIdentifier(left)) {\n      return left.name;\n    }\n\n    if (t.isMemberExpression(left)) {\n      var memberExpression = left;\n      var name = '';\n\n      while (true) {\n        if (!t.isIdentifier(memberExpression.property)) {\n          return '';\n        }\n\n        name = \"\" + memberExpression.property.name + (name ? \"-\" + name : '');\n\n        if (t.isIdentifier(memberExpression.object)) {\n          return memberExpression.object.name + \"-\" + name;\n        }\n\n        if (!t.isMemberExpression(memberExpression.object)) {\n          return '';\n        }\n\n        memberExpression = memberExpression.object;\n      }\n    }\n\n    return '';\n  } // we probably have an inline css prop usage\n\n\n  if (parent.isFunctionDeclaration()) {\n    return parent.node.id.name || '';\n  }\n\n  if (parent.isFunctionExpression()) {\n    if (parent.node.id) {\n      return parent.node.id.name || '';\n    }\n\n    return getDeclaratorName(parent, t);\n  }\n\n  if (parent.isArrowFunctionExpression()) {\n    return getDeclaratorName(parent, t);\n  } // we could also have an object property\n\n\n  var objPropertyLikeName = getObjPropertyLikeName(parent, t);\n\n  if (objPropertyLikeName) {\n    return objPropertyLikeName;\n  }\n\n  var variableDeclarator = parent.findParent(function (p) {\n    return p.isVariableDeclarator();\n  });\n\n  if (!variableDeclarator || !variableDeclarator.get('id').isIdentifier()) {\n    return '';\n  }\n\n  return variableDeclarator.node.id.name;\n}\n\nfunction getIdentifierName(path, t) {\n  var objPropertyLikeName = getObjPropertyLikeName(path.parentPath, t);\n\n  if (objPropertyLikeName) {\n    return objPropertyLikeName;\n  }\n\n  var classOrClassPropertyParent = path.findParent(function (p) {\n    return t.isClassProperty(p) || t.isClass(p);\n  });\n\n  if (classOrClassPropertyParent) {\n    if (t.isClassProperty(classOrClassPropertyParent) && classOrClassPropertyParent.node.computed === false && t.isIdentifier(classOrClassPropertyParent.node.key)) {\n      return classOrClassPropertyParent.node.key.name;\n    }\n\n    if (t.isClass(classOrClassPropertyParent) && classOrClassPropertyParent.node.id) {\n      return t.isIdentifier(classOrClassPropertyParent.node.id) ? classOrClassPropertyParent.node.id.name : '';\n    }\n  }\n\n  var declaratorName = getDeclaratorName(path, t); // if the name starts with _ it was probably generated by babel so we should ignore it\n\n  if (declaratorName.charAt(0) === '_') {\n    return '';\n  }\n\n  return declaratorName;\n}\n\nfunction getGeneratorOpts(file) {\n  return file.opts.generatorOpts ? file.opts.generatorOpts : file.opts;\n}\n\nfunction makeSourceMapGenerator(file) {\n  var generatorOpts = getGeneratorOpts(file);\n  var filename = generatorOpts.sourceFileName;\n  var generator = new SourceMapGenerator({\n    file: filename,\n    sourceRoot: generatorOpts.sourceRoot\n  });\n  generator.setSourceContent(filename, file.code);\n  return generator;\n}\nfunction getSourceMap(offset\n/*: {\nline: number,\ncolumn: number\n} */\n, state)\n/*: string */\n{\n  var generator = makeSourceMapGenerator(state.file);\n  var generatorOpts = getGeneratorOpts(state.file);\n\n  if (generatorOpts.sourceFileName && generatorOpts.sourceFileName !== 'unknown') {\n    generator.addMapping({\n      generated: {\n        line: 1,\n        column: 0\n      },\n      source: generatorOpts.sourceFileName,\n      original: offset\n    });\n    return convert.fromObject(generator).toComment({\n      multiline: true\n    });\n  }\n\n  return '';\n}\n\nvar hashArray = function hashArray(arr\n/*: Array<string> */\n) {\n  return hashString(arr.join(''));\n};\n\nvar unsafeRequire = require;\nvar getPackageRootPath = memoize(function (filename) {\n  return findRoot(filename);\n});\nvar separator = new RegExp(escapeRegexp(nodePath.sep), 'g');\n\nvar normalizePath = function normalizePath(path) {\n  return nodePath.normalize(path).replace(separator, '/');\n};\n\nfunction getTargetClassName(state, t) {\n  if (state.emotionTargetClassNameCount === undefined) {\n    state.emotionTargetClassNameCount = 0;\n  }\n\n  var hasFilepath = state.file.opts.filename && state.file.opts.filename !== 'unknown';\n  var filename = hasFilepath ? state.file.opts.filename : ''; // normalize the file path to ignore folder structure\n  // outside the current node project and arch-specific delimiters\n\n  var moduleName = '';\n  var rootPath = filename;\n\n  try {\n    rootPath = getPackageRootPath(filename);\n    moduleName = unsafeRequire(rootPath + '/package.json').name;\n  } catch (err) {}\n\n  var finalPath = filename === rootPath ? 'root' : filename.slice(rootPath.length);\n  var positionInFile = state.emotionTargetClassNameCount++;\n  var stuffToHash = [moduleName];\n\n  if (finalPath) {\n    stuffToHash.push(normalizePath(finalPath));\n  } else {\n    stuffToHash.push(state.file.code);\n  }\n\n  var stableClassName = \"e\" + hashArray(stuffToHash) + positionInFile;\n  return stableClassName;\n}\n\n// it's meant to simplify the most common cases so i don't want to make it especially complex\n// also, this will be unnecessary when prepack is ready\n\nfunction simplifyObject(node, t\n/*: Object */\n) {\n  var finalString = '';\n\n  for (var i = 0; i < node.properties.length; i++) {\n    var _ref;\n\n    var property = node.properties[i];\n\n    if (!t.isObjectProperty(property) || property.computed || !t.isIdentifier(property.key) && !t.isStringLiteral(property.key) || !t.isStringLiteral(property.value) && !t.isNumericLiteral(property.value) && !t.isObjectExpression(property.value)) {\n      return node;\n    }\n\n    var key = property.key.name || property.key.value;\n\n    if (key === 'styles') {\n      return node;\n    }\n\n    if (t.isObjectExpression(property.value)) {\n      var simplifiedChild = simplifyObject(property.value, t);\n\n      if (!t.isStringLiteral(simplifiedChild)) {\n        return node;\n      }\n\n      finalString += key + \"{\" + simplifiedChild.value + \"}\";\n      continue;\n    }\n\n    var value = property.value.value;\n    finalString += serializeStyles([(_ref = {}, _ref[key] = value, _ref)]).styles;\n  }\n\n  return t.stringLiteral(finalString);\n}\n\nvar haveSameLocation = function haveSameLocation(element1, element2) {\n  return element1.line === element2.line && element1.column === element2.column;\n};\n\nvar isAutoInsertedRule = function isAutoInsertedRule(element) {\n  return element.type === 'rule' && element.parent && haveSameLocation(element, element.parent);\n};\n\nvar toInputTree = function toInputTree(elements, tree) {\n  for (var i = 0; i < elements.length; i++) {\n    var element = elements[i];\n    var parent = element.parent,\n        children = element.children;\n\n    if (!parent) {\n      tree.push(element);\n    } else if (!isAutoInsertedRule(element)) {\n      parent.children.push(element);\n    }\n\n    if (Array.isArray(children)) {\n      element.children = [];\n      toInputTree(children, tree);\n    }\n  }\n\n  return tree;\n};\n\nvar stringifyTree = function stringifyTree(elements) {\n  return elements.map(function (element) {\n    switch (element.type) {\n      case 'import':\n      case 'decl':\n        return element.value;\n\n      case 'comm':\n        // When we encounter a standard multi-line CSS comment and it contains a '@'\n        // character, we keep the comment. Some Stylis plugins, such as\n        // the stylis-rtl via the cssjanus plugin, use this special comment syntax\n        // to control behavior (such as: /* @noflip */). We can do this\n        // with standard CSS comments because they will work with compression,\n        // as opposed to non-standard single-line comments that will break compressed CSS.\n        return element.props === '/' && element.value.includes('@') ? element.value : '';\n\n      case 'rule':\n        return element.value.replace(/&\\f/g, '&') + \"{\" + stringifyTree(element.children) + \"}\";\n\n      default:\n        {\n          return element.value + \"{\" + stringifyTree(element.children) + \"}\";\n        }\n    }\n  }).join('');\n};\n\nvar interleave = function interleave(strings\n/*: Array<*> */\n, interpolations\n/*: Array<*> */\n) {\n  return interpolations.reduce(function (array, interp, i) {\n    return array.concat([interp], strings[i + 1]);\n  }, [strings[0]]);\n};\n\nfunction getDynamicMatches(str\n/*: string */\n) {\n  var re = /xxx(\\d+):xxx/gm;\n  var match;\n  var matches = [];\n\n  while ((match = re.exec(str)) !== null) {\n    if (match !== null) {\n      matches.push({\n        value: match[0],\n        p1: parseInt(match[1], 10),\n        index: match.index\n      });\n    }\n  }\n\n  return matches;\n}\n\nfunction replacePlaceholdersWithExpressions(str\n/*: string */\n, expressions\n/*: Array<*> */\n, t) {\n  var matches = getDynamicMatches(str);\n\n  if (matches.length === 0) {\n    if (str === '') {\n      return [];\n    }\n\n    return [t.stringLiteral(str)];\n  }\n\n  var strings = [];\n  var finalExpressions = [];\n  var cursor = 0;\n  matches.forEach(function (_ref, i) {\n    var value = _ref.value,\n        p1 = _ref.p1,\n        index = _ref.index;\n    var preMatch = str.substring(cursor, index);\n    cursor = cursor + preMatch.length + value.length;\n\n    if (!preMatch && i === 0) {\n      strings.push(t.stringLiteral(''));\n    } else {\n      strings.push(t.stringLiteral(preMatch));\n    }\n\n    finalExpressions.push(expressions[p1]);\n\n    if (i === matches.length - 1) {\n      strings.push(t.stringLiteral(str.substring(index + value.length)));\n    }\n  });\n  return interleave(strings, finalExpressions).filter(function (node\n  /*: { value: string } */\n  ) {\n    return node.value !== '';\n  });\n}\n\nfunction createRawStringFromTemplateLiteral(quasi\n/*: {\nquasis: Array<{ value: { cooked: string } }>\n} */\n) {\n  var strs = quasi.quasis.map(function (x) {\n    return x.value.cooked;\n  });\n  var src = strs.reduce(function (arr, str, i) {\n    arr.push(str);\n\n    if (i !== strs.length - 1) {\n      arr.push(\"xxx\" + i + \":xxx\");\n    }\n\n    return arr;\n  }, []).join('').trim();\n  return src;\n}\n\nfunction minify(path, t) {\n  var quasi = path.node.quasi;\n  var raw = createRawStringFromTemplateLiteral(quasi);\n  var minified = stringifyTree(toInputTree(compile(raw), []));\n  var expressions = replacePlaceholdersWithExpressions(minified, quasi.expressions || [], t);\n  path.replaceWith(t.callExpression(path.node.tag, expressions));\n}\n\n// this only works correctly in modules, but we don't run on scripts anyway, so it's fine\n// the difference is that in modules template objects are being cached per call site\nfunction getTypeScriptMakeTemplateObjectPath(path) {\n  if (path.node.arguments.length === 0) {\n    return null;\n  }\n\n  var firstArgPath = path.get('arguments')[0];\n\n  if (firstArgPath.isLogicalExpression() && firstArgPath.get('left').isIdentifier() && firstArgPath.get('right').isAssignmentExpression() && firstArgPath.get('right.right').isCallExpression() && firstArgPath.get('right.right.callee').isIdentifier() && firstArgPath.node.right.right.callee.name.includes('makeTemplateObject') && firstArgPath.node.right.right.arguments.length === 2) {\n    return firstArgPath.get('right.right');\n  }\n\n  return null;\n} // this is only used to prevent appending strings/expressions to arguments incorectly\n// we could push them to found array expressions, as we do it for TS-transpile output \\_()_/\n// it seems overly complicated though - mainly because we'd also have to check against existing stuff of a particular type (source maps & labels)\n// considering Babel double-transpilation as a valid use case seems rather far-fetched\n\nfunction isTaggedTemplateTranspiledByBabel(path) {\n  if (path.node.arguments.length === 0) {\n    return false;\n  }\n\n  var firstArgPath = path.get('arguments')[0];\n\n  if (!firstArgPath.isCallExpression() || !firstArgPath.get('callee').isIdentifier()) {\n    return false;\n  }\n\n  var calleeName = firstArgPath.node.callee.name;\n\n  if (!calleeName.includes('templateObject')) {\n    return false;\n  }\n\n  var bindingPath = path.scope.getBinding(calleeName).path;\n\n  if (!bindingPath.isFunction()) {\n    return false;\n  }\n\n  var functionBody = bindingPath.get('body.body');\n\n  if (!functionBody[0].isVariableDeclaration()) {\n    return false;\n  }\n\n  var declarationInit = functionBody[0].get('declarations')[0].get('init');\n\n  if (!declarationInit.isCallExpression()) {\n    return false;\n  }\n\n  var declarationInitArguments = declarationInit.get('arguments');\n\n  if (declarationInitArguments.length === 0 || declarationInitArguments.length > 2 || declarationInitArguments.some(function (argPath) {\n    return !argPath.isArrayExpression();\n  })) {\n    return false;\n  }\n\n  return true;\n}\n\nvar appendStringReturningExpressionToArguments = function appendStringReturningExpressionToArguments(t, path, expression) {\n  var lastIndex = path.node.arguments.length - 1;\n  var last = path.node.arguments[lastIndex];\n\n  if (t.isStringLiteral(last)) {\n    if (typeof expression === 'string') {\n      path.node.arguments[lastIndex].value += expression;\n    } else {\n      path.node.arguments[lastIndex] = t.binaryExpression('+', last, expression);\n    }\n  } else {\n    var makeTemplateObjectCallPath = getTypeScriptMakeTemplateObjectPath(path);\n\n    if (makeTemplateObjectCallPath) {\n      makeTemplateObjectCallPath.get('arguments').forEach(function (argPath) {\n        var elements = argPath.get('elements');\n        var lastElement = elements[elements.length - 1];\n\n        if (typeof expression === 'string') {\n          lastElement.replaceWith(t.stringLiteral(lastElement.node.value + expression));\n        } else {\n          lastElement.replaceWith(t.binaryExpression('+', lastElement.node, t.cloneNode(expression)));\n        }\n      });\n    } else if (!isTaggedTemplateTranspiledByBabel(path)) {\n      if (typeof expression === 'string') {\n        path.node.arguments.push(t.stringLiteral(expression));\n      } else {\n        path.node.arguments.push(expression);\n      }\n    }\n  }\n};\nvar joinStringLiterals = function joinStringLiterals(expressions\n/*: Array<*> */\n, t) {\n  return expressions.reduce(function (finalExpressions, currentExpression, i) {\n    if (!t.isStringLiteral(currentExpression)) {\n      finalExpressions.push(currentExpression);\n    } else if (t.isStringLiteral(finalExpressions[finalExpressions.length - 1])) {\n      finalExpressions[finalExpressions.length - 1].value += currentExpression.value;\n    } else {\n      finalExpressions.push(currentExpression);\n    }\n\n    return finalExpressions;\n  }, []);\n};\n\nfunction createNodeEnvConditional(t, production, development) {\n  return t.conditionalExpression(t.binaryExpression('===', t.memberExpression(t.memberExpression(t.identifier('process'), t.identifier('env')), t.identifier('NODE_ENV')), t.stringLiteral('production')), production, development);\n}\n\nvar CSS_OBJECT_STRINGIFIED_ERROR = \"You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).\";\nvar transformExpressionWithStyles = function transformExpressionWithStyles(_ref\n/*: {\nbabel,\nstate,\npath,\nshouldLabel: boolean,\nsourceMap?: string\n} */\n) {\n  var babel = _ref.babel,\n      state = _ref.state,\n      path = _ref.path,\n      shouldLabel = _ref.shouldLabel,\n      _ref$sourceMap = _ref.sourceMap,\n      sourceMap = _ref$sourceMap === void 0 ? '' : _ref$sourceMap;\n  var autoLabel = state.opts.autoLabel || 'dev-only';\n  var t = babel.types;\n\n  if (t.isTaggedTemplateExpression(path)) {\n    if (!sourceMap && state.emotionSourceMap && path.node.quasi.loc !== undefined) {\n      sourceMap = getSourceMap(path.node.quasi.loc.start, state);\n    }\n\n    minify(path, t);\n  }\n\n  if (t.isCallExpression(path)) {\n    var canAppendStrings = path.node.arguments.every(function (arg) {\n      return arg.type !== 'SpreadElement';\n    });\n    path.get('arguments').forEach(function (node) {\n      if (t.isObjectExpression(node)) {\n        node.replaceWith(simplifyObject(node.node, t));\n      }\n    });\n    path.node.arguments = joinStringLiterals(path.node.arguments, t);\n\n    if (!sourceMap && canAppendStrings && state.emotionSourceMap && path.node.loc !== undefined) {\n      sourceMap = getSourceMap(path.node.loc.start, state);\n    }\n\n    var label = shouldLabel && autoLabel !== 'never' ? getLabelFromPath(path, state, t) : null;\n\n    if (path.node.arguments.length === 1 && t.isStringLiteral(path.node.arguments[0])) {\n      var cssString = path.node.arguments[0].value.replace(/;$/, '');\n      var res = serializeStyles([\"\" + cssString + (label && autoLabel === 'always' ? \";label:\" + label + \";\" : '')]);\n      var prodNode = t.objectExpression([t.objectProperty(t.identifier('name'), t.stringLiteral(res.name)), t.objectProperty(t.identifier('styles'), t.stringLiteral(res.styles))]);\n\n      if (!state.emotionStringifiedCssId) {\n        var uid = state.file.scope.generateUidIdentifier('__EMOTION_STRINGIFIED_CSS_ERROR__');\n        state.emotionStringifiedCssId = uid;\n        var cssObjectToString = t.functionDeclaration(uid, [], t.blockStatement([t.returnStatement(t.stringLiteral(CSS_OBJECT_STRINGIFIED_ERROR))]));\n        cssObjectToString._compact = true;\n        state.file.path.unshiftContainer('body', [cssObjectToString]);\n      }\n\n      if (label && autoLabel === 'dev-only') {\n        res = serializeStyles([cssString + \";label:\" + label + \";\"]);\n      }\n\n      var devNode = t.objectExpression([t.objectProperty(t.identifier('name'), t.stringLiteral(res.name)), t.objectProperty(t.identifier('styles'), t.stringLiteral(res.styles + sourceMap)), t.objectProperty(t.identifier('toString'), t.cloneNode(state.emotionStringifiedCssId))].filter(Boolean));\n      return createNodeEnvConditional(t, prodNode, devNode);\n    }\n\n    if (canAppendStrings && label) {\n      var labelString = \";label:\" + label + \";\";\n\n      switch (autoLabel) {\n        case 'dev-only':\n          {\n            var labelConditional = createNodeEnvConditional(t, t.stringLiteral(''), t.stringLiteral(labelString));\n            appendStringReturningExpressionToArguments(t, path, labelConditional);\n            break;\n          }\n\n        case 'always':\n          appendStringReturningExpressionToArguments(t, path, labelString);\n          break;\n      }\n    }\n\n    if (sourceMap) {\n      var sourceMapConditional = createNodeEnvConditional(t, t.stringLiteral(''), t.stringLiteral(sourceMap));\n      appendStringReturningExpressionToArguments(t, path, sourceMapConditional);\n    }\n  }\n};\n\nvar getKnownProperties = function getKnownProperties(t, node) {\n  return new Set(node.properties.filter(function (n) {\n    return t.isObjectProperty(n) && !n.computed;\n  }).map(function (n) {\n    return t.isIdentifier(n.key) ? n.key.name : n.key.value;\n  }));\n};\n\nvar createObjectSpreadLike = function createObjectSpreadLike(t, file) {\n  for (var _len = arguments.length, objs = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    objs[_key - 2] = arguments[_key];\n  }\n\n  return t.callExpression(file.addHelper('extends'), [t.objectExpression([])].concat(objs));\n};\n\nvar getStyledOptions = function getStyledOptions(t, path, state) {\n  var autoLabel = state.opts.autoLabel || 'dev-only';\n  var args = path.node.arguments;\n  var optionsArgument = args.length >= 2 ? args[1] : null;\n  var prodProperties = [];\n  var devProperties = null;\n  var knownProperties = optionsArgument && t.isObjectExpression(optionsArgument) ? getKnownProperties(t, optionsArgument) : new Set();\n\n  if (!knownProperties.has('target')) {\n    prodProperties.push(t.objectProperty(t.identifier('target'), t.stringLiteral(getTargetClassName(state))));\n  }\n\n  var label = autoLabel !== 'never' && !knownProperties.has('label') ? getLabelFromPath(path, state, t) : null;\n\n  if (label) {\n    var labelNode = t.objectProperty(t.identifier('label'), t.stringLiteral(label));\n\n    switch (autoLabel) {\n      case 'always':\n        prodProperties.push(labelNode);\n        break;\n\n      case 'dev-only':\n        devProperties = [labelNode];\n        break;\n    }\n  }\n\n  if (optionsArgument) {\n    // for some reason `.withComponent` transformer gets requeued\n    // so check if this has been already transpiled to avoid double wrapping\n    if (t.isConditionalExpression(optionsArgument) && t.isBinaryExpression(optionsArgument.test) && t.buildMatchMemberExpression('process.env.NODE_ENV')(optionsArgument.test.left)) {\n      return optionsArgument;\n    }\n\n    if (!t.isObjectExpression(optionsArgument)) {\n      var prodNode = createObjectSpreadLike(t, state.file, t.objectExpression(prodProperties), optionsArgument);\n      return devProperties ? createNodeEnvConditional(t, prodNode, t.cloneNode(createObjectSpreadLike(t, state.file, t.objectExpression(prodProperties.concat(devProperties)), optionsArgument))) : prodNode;\n    }\n\n    prodProperties.unshift.apply(prodProperties, optionsArgument.properties);\n  }\n\n  return devProperties ? createNodeEnvConditional(t, t.objectExpression(prodProperties), t.cloneNode(t.objectExpression(prodProperties.concat(devProperties)))) : t.objectExpression(prodProperties);\n};\n\nfunction addImport(state, importSource\n/*: string */\n, importedSpecifier\n/*: string */\n, nameHint\n/* ?: string */\n) {\n  var cacheKey = ['import', importSource, importedSpecifier].join(':');\n\n  if (state[cacheKey] === undefined) {\n    var importIdentifier;\n\n    if (importedSpecifier === 'default') {\n      importIdentifier = addDefault(state.file.path, importSource, {\n        nameHint: nameHint\n      });\n    } else {\n      importIdentifier = addNamed(state.file.path, importedSpecifier, importSource, {\n        nameHint: nameHint\n      });\n    }\n\n    state[cacheKey] = importIdentifier.name;\n  }\n\n  return {\n    type: 'Identifier',\n    name: state[cacheKey]\n  };\n}\n\n/*\ntype Transformer = Function\n*/\n\nfunction createTransformerMacro(transformers\n/*: { [key: string]: Transformer | [Transformer, Object] } */\n, _ref\n/*: { importSource: string } */\n) {\n  var importSource = _ref.importSource;\n  var macro = createMacro(function (_ref2) {\n    var path = _ref2.path,\n        source = _ref2.source,\n        references = _ref2.references,\n        state = _ref2.state,\n        babel = _ref2.babel,\n        isEmotionCall = _ref2.isEmotionCall;\n\n    if (!path) {\n      path = state.file.scope.path.get('body').find(function (p) {\n        return p.isImportDeclaration() && p.node.source.value === source;\n      });\n    }\n\n    if (/\\/macro$/.test(source)) {\n      path.get('source').replaceWith(babel.types.stringLiteral(source.replace(/\\/macro$/, '')));\n    }\n\n    if (!isEmotionCall) {\n      state.emotionSourceMap = true;\n    }\n\n    Object.keys(references).forEach(function (importSpecifierName) {\n      if (transformers[importSpecifierName]) {\n        references[importSpecifierName].reverse().forEach(function (reference) {\n          var options;\n          var transformer;\n\n          if (Array.isArray(transformers[importSpecifierName])) {\n            transformer = transformers[importSpecifierName][0];\n            options = transformers[importSpecifierName][1];\n          } else {\n            transformer = transformers[importSpecifierName];\n            options = {};\n          }\n\n          transformer({\n            state: state,\n            babel: babel,\n            path: path,\n            importSource: importSource,\n            importSpecifierName: importSpecifierName,\n            options: options,\n            reference: reference\n          });\n        });\n      }\n    });\n    return {\n      keepImports: true\n    };\n  });\n  macro.transformers = transformers;\n  return macro;\n}\n\nvar isAlreadyTranspiled = function isAlreadyTranspiled(path) {\n  if (!path.isCallExpression()) {\n    return false;\n  }\n\n  var firstArgPath = path.get('arguments.0');\n\n  if (!firstArgPath) {\n    return false;\n  }\n\n  if (!firstArgPath.isConditionalExpression()) {\n    return false;\n  }\n\n  var alternatePath = firstArgPath.get('alternate');\n\n  if (!alternatePath.isObjectExpression()) {\n    return false;\n  }\n\n  var properties = new Set(alternatePath.get('properties').map(function (p) {\n    return p.node.key.name;\n  }));\n  return ['name', 'styles'].every(function (p) {\n    return properties.has(p);\n  });\n};\n\nvar createEmotionTransformer = function createEmotionTransformer(isPure\n/*: boolean */\n) {\n  return function (_ref\n  /*: Object */\n  ) {\n    var state = _ref.state,\n        babel = _ref.babel;\n        _ref.importSource;\n        var reference = _ref.reference;\n        _ref.importSpecifierName;\n    var path = reference.parentPath;\n\n    if (isAlreadyTranspiled(path)) {\n      return;\n    }\n\n    if (isPure) {\n      path.addComment('leading', '#__PURE__');\n    }\n\n    var node = transformExpressionWithStyles({\n      babel: babel,\n      state: state,\n      path: path,\n      shouldLabel: true\n    });\n\n    if (node) {\n      path.node.arguments[0] = node;\n    }\n  };\n};\n\nvar transformers$1 = {\n  css: createEmotionTransformer(true),\n  injectGlobal: createEmotionTransformer(false),\n  keyframes: createEmotionTransformer(true)\n};\nvar createEmotionMacro = function createEmotionMacro(importSource\n/*: string */\n) {\n  return createTransformerMacro(transformers$1, {\n    importSource: importSource\n  });\n};\n\nvar getReferencedSpecifier = function getReferencedSpecifier(path, specifierName) {\n  var specifiers = path.get('specifiers');\n  return specifierName === 'default' ? specifiers.find(function (p) {\n    return p.isImportDefaultSpecifier();\n  }) : specifiers.find(function (p) {\n    return p.node.local.name === specifierName;\n  });\n};\n\nvar styledTransformer = function styledTransformer(_ref\n/*: {\nstate: Object,\nbabel: Object,\npath: any,\nimportSource: string,\nimportSpecifierName: string,\nreference: Object,\noptions: { styledBaseImport?: [string, string], isWeb: boolean }\n} */\n) {\n  var state = _ref.state,\n      babel = _ref.babel,\n      path = _ref.path,\n      importSource = _ref.importSource,\n      reference = _ref.reference,\n      importSpecifierName = _ref.importSpecifierName,\n      _ref$options = _ref.options,\n      styledBaseImport = _ref$options.styledBaseImport,\n      isWeb = _ref$options.isWeb;\n  var t = babel.types;\n\n  var getStyledIdentifier = function getStyledIdentifier() {\n    if (!styledBaseImport || styledBaseImport[0] === importSource && styledBaseImport[1] === importSpecifierName) {\n      return t.cloneNode(reference.node);\n    }\n\n    if (path.node) {\n      var referencedSpecifier = getReferencedSpecifier(path, importSpecifierName);\n\n      if (referencedSpecifier) {\n        referencedSpecifier.remove();\n      }\n\n      if (!path.get('specifiers').length) {\n        path.remove();\n      }\n    }\n\n    var baseImportSource = styledBaseImport[0],\n        baseSpecifierName = styledBaseImport[1];\n    return addImport(state, baseImportSource, baseSpecifierName, 'styled');\n  };\n\n  var createStyledComponentPath = null;\n\n  if (t.isMemberExpression(reference.parent) && reference.parent.computed === false) {\n    if ( // checks if the first character is lowercase\n    // becasue we don't want to transform the member expression if\n    // it's in primitives/native\n    reference.parent.property.name.charCodeAt(0) > 96) {\n      reference.parentPath.replaceWith(t.callExpression(getStyledIdentifier(), [t.stringLiteral(reference.parent.property.name)]));\n    } else {\n      reference.replaceWith(getStyledIdentifier());\n    }\n\n    createStyledComponentPath = reference.parentPath;\n  } else if (reference.parentPath && t.isCallExpression(reference.parentPath) && reference.parent.callee === reference.node) {\n    reference.replaceWith(getStyledIdentifier());\n    createStyledComponentPath = reference.parentPath;\n  }\n\n  if (!createStyledComponentPath) {\n    return;\n  }\n\n  var styledCallLikeWithStylesPath = createStyledComponentPath.parentPath;\n  var node = transformExpressionWithStyles({\n    path: styledCallLikeWithStylesPath,\n    state: state,\n    babel: babel,\n    shouldLabel: false\n  });\n\n  if (node && isWeb) {\n    // we know the argument length will be 1 since that's the only time we will have a node since it will be static\n    styledCallLikeWithStylesPath.node.arguments[0] = node;\n  }\n\n  styledCallLikeWithStylesPath.addComment('leading', '#__PURE__');\n\n  if (isWeb) {\n    createStyledComponentPath.node.arguments[1] = getStyledOptions(t, createStyledComponentPath, state);\n  }\n};\nvar createStyledMacro = function createStyledMacro(_ref2\n/*: {\nimportSource: string,\noriginalImportSource?: string,\nbaseImportName?: string,\nisWeb: boolean\n} */\n) {\n  var importSource = _ref2.importSource,\n      _ref2$originalImportS = _ref2.originalImportSource,\n      originalImportSource = _ref2$originalImportS === void 0 ? importSource : _ref2$originalImportS,\n      _ref2$baseImportName = _ref2.baseImportName,\n      baseImportName = _ref2$baseImportName === void 0 ? 'default' : _ref2$baseImportName,\n      isWeb = _ref2.isWeb;\n  return createTransformerMacro({\n    \"default\": [styledTransformer, {\n      styledBaseImport: [importSource, baseImportName],\n      isWeb: isWeb\n    }]\n  }, {\n    importSource: originalImportSource\n  });\n};\n\nvar transformCssCallExpression = function transformCssCallExpression(_ref\n/*: {\nstate: *,\nbabel: *,\npath: *,\nsourceMap?: string,\nannotateAsPure?: boolean\n} */\n) {\n  var state = _ref.state,\n      babel = _ref.babel,\n      path = _ref.path,\n      sourceMap = _ref.sourceMap,\n      _ref$annotateAsPure = _ref.annotateAsPure,\n      annotateAsPure = _ref$annotateAsPure === void 0 ? true : _ref$annotateAsPure;\n  var node = transformExpressionWithStyles({\n    babel: babel,\n    state: state,\n    path: path,\n    shouldLabel: true,\n    sourceMap: sourceMap\n  });\n\n  if (node) {\n    path.replaceWith(node);\n    path.hoist();\n  } else if (annotateAsPure && path.isCallExpression()) {\n    path.addComment('leading', '#__PURE__');\n  }\n};\nvar transformCsslessArrayExpression = function transformCsslessArrayExpression(_ref2\n/*: {\nbabel: *,\nstate: *,\npath: *\n} */\n) {\n  var state = _ref2.state,\n      babel = _ref2.babel,\n      path = _ref2.path;\n  var t = babel.types;\n  var expressionPath = path.get('value.expression');\n  var sourceMap = state.emotionSourceMap && path.node.loc !== undefined ? getSourceMap(path.node.loc.start, state) : '';\n  expressionPath.replaceWith(t.callExpression( // the name of this identifier doesn't really matter at all\n  // it'll never appear in generated code\n  t.identifier('___shouldNeverAppearCSS'), path.node.value.expression.elements));\n  transformCssCallExpression({\n    babel: babel,\n    state: state,\n    path: expressionPath,\n    sourceMap: sourceMap,\n    annotateAsPure: false\n  });\n\n  if (t.isCallExpression(expressionPath)) {\n    expressionPath.replaceWith(t.arrayExpression(expressionPath.node.arguments));\n  }\n};\nvar transformCsslessObjectExpression = function transformCsslessObjectExpression(_ref3\n/*: {\nbabel: *,\nstate: *,\npath: *,\ncssImport: { importSource: string, cssExport: string }\n} */\n) {\n  var state = _ref3.state,\n      babel = _ref3.babel,\n      path = _ref3.path,\n      cssImport = _ref3.cssImport;\n  var t = babel.types;\n  var expressionPath = path.get('value.expression');\n  var sourceMap = state.emotionSourceMap && path.node.loc !== undefined ? getSourceMap(path.node.loc.start, state) : '';\n  expressionPath.replaceWith(t.callExpression( // the name of this identifier doesn't really matter at all\n  // it'll never appear in generated code\n  t.identifier('___shouldNeverAppearCSS'), [path.node.value.expression]));\n  transformCssCallExpression({\n    babel: babel,\n    state: state,\n    path: expressionPath,\n    sourceMap: sourceMap\n  });\n\n  if (t.isCallExpression(expressionPath)) {\n    expressionPath.get('callee').replaceWith(addImport(state, cssImport.importSource, cssImport.cssExport, 'css'));\n  }\n};\n\nvar cssTransformer = function cssTransformer(_ref4\n/*: {\nstate: any,\nbabel: any,\nreference: any\n} */\n) {\n  var state = _ref4.state,\n      babel = _ref4.babel,\n      reference = _ref4.reference;\n  transformCssCallExpression({\n    babel: babel,\n    state: state,\n    path: reference.parentPath\n  });\n};\n\nvar globalTransformer = function globalTransformer(_ref5\n/*: {\nstate: any,\nbabel: any,\nreference: any,\nimportSource: string,\noptions: { cssExport?: string }\n} */\n) {\n  var state = _ref5.state,\n      babel = _ref5.babel,\n      reference = _ref5.reference,\n      importSource = _ref5.importSource,\n      options = _ref5.options;\n  var t = babel.types;\n\n  if (!t.isJSXIdentifier(reference.node) || !t.isJSXOpeningElement(reference.parentPath.node)) {\n    return;\n  }\n\n  var stylesPropPath = reference.parentPath.get('attributes').find(function (p) {\n    return t.isJSXAttribute(p.node) && p.node.name.name === 'styles';\n  });\n\n  if (!stylesPropPath) {\n    return;\n  }\n\n  if (t.isJSXExpressionContainer(stylesPropPath.node.value)) {\n    if (t.isArrayExpression(stylesPropPath.node.value.expression)) {\n      transformCsslessArrayExpression({\n        state: state,\n        babel: babel,\n        path: stylesPropPath\n      });\n    } else if (t.isObjectExpression(stylesPropPath.node.value.expression)) {\n      transformCsslessObjectExpression({\n        state: state,\n        babel: babel,\n        path: stylesPropPath,\n        cssImport: options.cssExport !== undefined ? {\n          importSource: importSource,\n          cssExport: options.cssExport\n        } : {\n          importSource: '@emotion/react',\n          cssExport: 'css'\n        }\n      });\n    }\n  }\n};\n\nvar transformers = {\n  // this is an empty function because this transformer is never called\n  // we don't run any transforms on `jsx` directly\n  // instead we use it as a hint to enable css prop optimization\n  jsx: function jsx() {},\n  css: cssTransformer,\n  Global: globalTransformer\n};\nvar coreMacro = createTransformerMacro(transformers, {\n  importSource: '@emotion/react'\n});\n\nvar _excluded = [\"canonicalImport\"];\n\nvar getCssExport = function getCssExport(reexported, importSource, mapping) {\n  var cssExport = Object.keys(mapping).find(function (localExportName) {\n    var _mapping$localExportN = mapping[localExportName].canonicalImport,\n        packageName = _mapping$localExportN[0],\n        exportName = _mapping$localExportN[1];\n    return packageName === '@emotion/react' && exportName === 'css';\n  });\n\n  if (!cssExport) {\n    throw new Error(\"You have specified that '\" + importSource + \"' re-exports '\" + reexported + \"' from '@emotion/react' but it doesn't also re-export 'css' from '@emotion/react', 'css' is necessary for certain optimisations, please re-export it from '\" + importSource + \"'\");\n  }\n\n  return cssExport;\n};\n\nvar webStyledMacro = createStyledMacro({\n  importSource: '@emotion/styled/base',\n  originalImportSource: '@emotion/styled',\n  isWeb: true\n});\nvar nativeStyledMacro = createStyledMacro({\n  importSource: '@emotion/native',\n  originalImportSource: '@emotion/native',\n  isWeb: false\n});\nvar primitivesStyledMacro = createStyledMacro({\n  importSource: '@emotion/primitives',\n  originalImportSource: '@emotion/primitives',\n  isWeb: false\n});\nvar vanillaEmotionMacro = createEmotionMacro('@emotion/css');\nvar transformersSource = {\n  '@emotion/css': transformers$1,\n  '@emotion/react': transformers,\n  '@emotion/styled': {\n    \"default\": [styledTransformer, {\n      styledBaseImport: ['@emotion/styled/base', 'default'],\n      isWeb: true\n    }]\n  },\n  '@emotion/primitives': {\n    \"default\": [styledTransformer, {\n      isWeb: false\n    }]\n  },\n  '@emotion/native': {\n    \"default\": [styledTransformer, {\n      isWeb: false\n    }]\n  }\n};\nvar macros = {\n  core: coreMacro,\n  nativeStyled: nativeStyledMacro,\n  primitivesStyled: primitivesStyledMacro,\n  webStyled: webStyledMacro,\n  vanillaEmotion: vanillaEmotionMacro\n};\n/*\nexport type BabelPath = any\n\nexport type EmotionBabelPluginPass = any\n*/\n\nvar AUTO_LABEL_VALUES = ['dev-only', 'never', 'always'];\nfunction index (babel, options) {\n  if (options.autoLabel !== undefined && !AUTO_LABEL_VALUES.includes(options.autoLabel)) {\n    throw new Error(\"The 'autoLabel' option must be undefined, or one of the following: \" + AUTO_LABEL_VALUES.map(function (s) {\n      return \"\\\"\" + s + \"\\\"\";\n    }).join(', '));\n  }\n\n  var t = babel.types;\n  return {\n    name: '@emotion',\n    // https://github.com/babel/babel/blob/0c97749e0fe8ad845b902e0b23a24b308b0bf05d/packages/babel-plugin-syntax-jsx/src/index.ts#L9-L18\n    manipulateOptions: function manipulateOptions(opts, parserOpts) {\n      var plugins = parserOpts.plugins;\n\n      if (plugins.some(function (p) {\n        var plugin = Array.isArray(p) ? p[0] : p;\n        return plugin === 'typescript' || plugin === 'jsx';\n      })) {\n        return;\n      }\n\n      plugins.push('jsx');\n    },\n    visitor: {\n      ImportDeclaration: function ImportDeclaration(path, state) {\n        var macro = state.pluginMacros[path.node.source.value]; // most of this is from https://github.com/kentcdodds/babel-plugin-macros/blob/main/src/index.js\n\n        if (macro === undefined) {\n          return;\n        }\n\n        if (t.isImportNamespaceSpecifier(path.node.specifiers[0])) {\n          return;\n        }\n\n        var imports = path.node.specifiers.map(function (s) {\n          return {\n            localName: s.local.name,\n            importedName: s.type === 'ImportDefaultSpecifier' ? 'default' : s.imported.name\n          };\n        });\n        var shouldExit = false;\n        var hasReferences = false;\n        var referencePathsByImportName = imports.reduce(function (byName, _ref) {\n          var importedName = _ref.importedName,\n              localName = _ref.localName;\n          var binding = path.scope.getBinding(localName);\n\n          if (!binding) {\n            shouldExit = true;\n            return byName;\n          }\n\n          byName[importedName] = binding.referencePaths;\n          hasReferences = hasReferences || Boolean(byName[importedName].length);\n          return byName;\n        }, {});\n\n        if (!hasReferences || shouldExit) {\n          return;\n        }\n        /**\n         * Other plugins that run before babel-plugin-macros might use path.replace, where a path is\n         * put into its own replacement. Apparently babel does not update the scope after such\n         * an operation. As a remedy, the whole scope is traversed again with an empty \"Identifier\"\n         * visitor - this makes the problem go away.\n         *\n         * See: https://github.com/kentcdodds/import-all.macro/issues/7\n         */\n\n\n        state.file.scope.path.traverse({\n          Identifier: function Identifier() {}\n        });\n        macro({\n          path: path,\n          references: referencePathsByImportName,\n          state: state,\n          babel: babel,\n          isEmotionCall: true,\n          isBabelMacrosCall: true\n        });\n      },\n      Program: function Program(path, state) {\n        var macros = {};\n        var jsxReactImports\n        /*: Array<{\n        importSource: string,\n        export: string,\n        cssExport: string\n        }> */\n        = [{\n          importSource: '@emotion/react',\n          \"export\": 'jsx',\n          cssExport: 'css'\n        }];\n        state.jsxReactImport = jsxReactImports[0];\n        Object.keys(state.opts.importMap || {}).forEach(function (importSource) {\n          var value = state.opts.importMap[importSource];\n          var transformers = {};\n          Object.keys(value).forEach(function (localExportName) {\n            var _value$localExportNam = value[localExportName],\n                canonicalImport = _value$localExportNam.canonicalImport,\n                options = _objectWithoutPropertiesLoose(_value$localExportNam, _excluded);\n\n            var packageName = canonicalImport[0],\n                exportName = canonicalImport[1];\n\n            if (packageName === '@emotion/react' && exportName === 'jsx') {\n              jsxReactImports.push({\n                importSource: importSource,\n                \"export\": localExportName,\n                cssExport: getCssExport('jsx', importSource, value)\n              });\n              return;\n            }\n\n            var packageTransformers = transformersSource[packageName];\n\n            if (packageTransformers === undefined) {\n              throw new Error(\"There is no transformer for the export '\" + exportName + \"' in '\" + packageName + \"'\");\n            }\n\n            var extraOptions;\n\n            if (packageName === '@emotion/react' && exportName === 'Global') {\n              // this option is not supposed to be set in importMap\n              extraOptions = {\n                cssExport: getCssExport('Global', importSource, value)\n              };\n            } else if (packageName === '@emotion/styled' && exportName === 'default') {\n              // this is supposed to override defaultOptions value\n              // and let correct value to be set if coming in options\n              extraOptions = {\n                styledBaseImport: undefined\n              };\n            }\n\n            var _ref2 = Array.isArray(packageTransformers[exportName]) ? packageTransformers[exportName] : [packageTransformers[exportName]],\n                exportTransformer = _ref2[0],\n                defaultOptions = _ref2[1];\n\n            transformers[localExportName] = [exportTransformer, _extends({}, defaultOptions, extraOptions, options)];\n          });\n          macros[importSource] = createTransformerMacro(transformers, {\n            importSource: importSource\n          });\n        });\n        state.pluginMacros = _extends({\n          '@emotion/styled': webStyledMacro,\n          '@emotion/react': coreMacro,\n          '@emotion/primitives': primitivesStyledMacro,\n          '@emotion/native': nativeStyledMacro,\n          '@emotion/css': vanillaEmotionMacro\n        }, macros);\n\n        var _loop = function _loop() {\n          var node = _step.value;\n\n          if (t.isImportDeclaration(node)) {\n            var jsxReactImport = jsxReactImports.find(function (thing) {\n              return node.source.value === thing.importSource && node.specifiers.some(function (x) {\n                return t.isImportSpecifier(x) && x.imported.name === thing[\"export\"];\n              });\n            });\n\n            if (jsxReactImport) {\n              state.jsxReactImport = jsxReactImport;\n              return \"break\";\n            }\n          }\n        };\n\n        for (var _iterator = _createForOfIteratorHelperLoose(path.node.body), _step; !(_step = _iterator()).done;) {\n          var _ret = _loop();\n\n          if (_ret === \"break\") break;\n        }\n\n        if (state.opts.cssPropOptimization === false) {\n          state.transformCssProp = false;\n        } else {\n          state.transformCssProp = true;\n        }\n\n        if (state.opts.sourceMap === false) {\n          state.emotionSourceMap = false;\n        } else {\n          state.emotionSourceMap = true;\n        }\n      },\n      JSXAttribute: function JSXAttribute(path, state) {\n        if (path.node.name.name !== 'css' || !state.transformCssProp) {\n          return;\n        }\n\n        if (t.isJSXExpressionContainer(path.node.value)) {\n          if (t.isArrayExpression(path.node.value.expression)) {\n            transformCsslessArrayExpression({\n              state: state,\n              babel: babel,\n              path: path\n            });\n          } else if (t.isObjectExpression(path.node.value.expression)) {\n            transformCsslessObjectExpression({\n              state: state,\n              babel: babel,\n              path: path,\n              cssImport: state.jsxReactImport\n            });\n          }\n        }\n      },\n      CallExpression: {\n        exit: function exit(path\n        /*: BabelPath */\n        , state\n        /*: EmotionBabelPluginPass */\n        ) {\n          try {\n            if (path.node.callee && path.node.callee.property && path.node.callee.property.name === 'withComponent') {\n              switch (path.node.arguments.length) {\n                case 1:\n                case 2:\n                  {\n                    path.node.arguments[1] = getStyledOptions(t, path, state);\n                  }\n              }\n            }\n          } catch (e) {\n            throw path.buildCodeFrameError(e);\n          }\n        }\n      }\n    }\n  };\n}\n\nexport { index as default, macros };\n", "module.exports = require('@emotion/babel-plugin').macros.webStyled\n"],
  "mappings": "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,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,GAAE,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,GAAE,GAAE,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,IAAG,IAAG,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,GAAE,KAAI,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,KAAI,IAAG,KAAI,IAAG,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,IAAG,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,GAAE,GAAE,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,GAAE,GAAE,IAAG,IAAG,GAAE,KAAI,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,MAAK,IAAG,IAAG,MAAK,IAAG,GAAE,IAAG,MAAK,GAAE,KAAI,MAAK,IAAG,MAAK,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,KAAI,IAAG,KAAI,IAAG,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,GAAE,IAAG,MAAK,GAAE,MAAK,IAAG,GAAE,MAAK,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,KAAI,MAAK,KAAI,GAAE,IAAG,GAAE,GAAE,GAAE,GAAE,MAAK,IAAG,GAAE,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,KAAI,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,MAAK,IAAG,GAAE,GAAE,KAAI,IAAG,KAAI,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,IAAG,IAAG,KAAI,IAAG,KAAI,IAAG,GAAE,GAAE,KAAI,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,IAAG,GAAE,GAAE,MAAK,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE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CO,aAASmM,sCACdpM,MACAC,MACmD;AACnDH,aAAO,mCAAmCE,MAAMC,IAAI;IACtD;AACO,aAASoM,0BACdrM,MACAC,MACuC;AACvCH,aAAO,uBAAuBE,MAAMC,IAAI;IAC1C;AACO,aAASqM,wBACdtM,MACAC,MACqC;AACrCH,aAAO,qBAAqBE,MAAMC,IAAI;IACxC;AACO,aAASsM,uBACdvM,MACAC,MACoC;AACpCH,aAAO,oBAAoBE,MAAMC,IAAI;IACvC;AACO,aAASuM,mBACdxM,MACAC,MACgC;AAChCH,aAAO,gBAAgBE,MAAMC,IAAI;IACnC;AACO,aAASwM,uBACdzM,MACAC,MACoC;AACpCH,aAAO,oBAAoBE,MAAMC,IAAI;IACvC;AACO,aAASyM,sBACd1M,MACAC,MACmC;AACnCH,aAAO,mBAAmBE,MAAMC,IAAI;IACtC;AACO,aAAS0M,yBACd3M,MACAC,MACsC;AACtCH,aAAO,sBAAsBE,MAAMC,IAAI;IACzC;AACO,aAAS2M,qBACd5M,MACAC,MACkC;AAClCH,aAAO,kBAAkBE,MAAMC,IAAI;IACrC;AACO,aAAS4M,oBACd7M,MACAC,MACiC;AACjCH,aAAO,iBAAiBE,MAAMC,IAAI;IACpC;AACO,aAAS6M,sBACd9M,MACAC,MACmC;AACnCH,aAAO,mBAAmBE,MAAMC,IAAI;IACtC;AACO,aAAS8M,sBACd/M,MACAC,MACmC;AACnCH,aAAO,mBAAmBE,MAAMC,IAAI;IACtC;AACO,aAAS+M,sBACdhN,MACAC,MACmC;AACnCH,aAAO,mBAAmBE,MAAMC,IAAI;IACtC;AACO,aAASgN,sBACdjN,MACAC,MACmC;AACnCH,aAAO,mBAAmBE,MAAMC,IAAI;IACtC;AACO,aAASiN,yBACdlN,MACAC,MACsC;AACtCH,aAAO,sBAAsBE,MAAMC,IAAI;IACzC;AACO,aAASkN,uBACdnN,MACAC,MACoC;AACpCH,aAAO,oBAAoBE,MAAMC,IAAI;IACvC;AACO,aAASmN,oBACdpN,MACAC,MACiC;AACjCH,aAAO,iBAAiBE,MAAMC,IAAI;IACpC;AACO,aAASoN,iBACdrN,MACAC,MAC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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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",
  "names": ["index", "set", "SourceMapGenerator", "sourceFile", "map", "index", "index", "value", "needle", "section", "SourceMapGenerator", "map", "json", "value", "findRoot", "string", "shallowEqual", "actual", "expected", "keys", "Object", "key", "warnings", "Set", "deprecationWarning", "oldName", "newName", "prefix", "has", "add", "internal", "trace", "captureShortStackTrace", "console", "warn", "skip", "length", "stackTraceLimit", "prepareStackTrace", "Error", "stackTrace", "err", "stack", "shortStackTrace", "slice", "test", "getFileName", "map", "frame", "join", "_shallowEqual", "require", "_deprecationWarning", "isArrayExpression", "node", "opts", "type", "shallowEqual", "isAssignmentExpression", "isBinaryExpression", "isInterpreterDirective", "isDirective", "isDirectiveLiteral", "isBlockStatement", "isBreakStatement", "isCallExpression", "isCatchClause", "isConditionalExpression", "isContinueStatement", "isDebuggerStatement", "isDoWhileStatement", "isEmptyStatement", "isExpressionStatement", "isFile", "isForInStatement", "isForStatement", "isFunctionDeclaration", "isFunctionExpression", "isIdentifier", "isIfStatement", "isLabeledStatement", "isStringLiteral", "isNumericLiteral", "isNullLiteral", "isBooleanLiteral", "isRegExpLiteral", "isLogicalExpression", "isMemberExpression", "isNewExpression", "isProgram", "isObjectExpression", "isObjectMethod", "isObjectProperty", "isRestElement", "isReturnStatement", "isSequenceExpression", "isParenthesizedExpression", "isSwitchCase", "isSwitchStatement", "isThisExpression", "isThrowStatement", "isTryStatement", "isUnaryExpression", "isUpdateExpression", "isVariableDeclaration", "isVariableDeclarator", "isWhileStatement", "isWithStatement", "isAssignmentPattern", "isArrayPattern", "isArrowFunctionExpression", "isClassBody", "isClassExpression", "isClassDeclaration", "isExportAllDeclaration", "isExportDefaultDeclaration", "isExportNamedDeclaration", "isExportSpecifier", "isForOfStatement", "isImportDeclaration", "isImportDefaultSpecifier", "isImportNamespaceSpecifier", "isImportSpecifier", "isImportExpression", "isMetaProperty", "isClassMethod", "isObjectPattern", "isSpreadElement", "isSuper", "isTaggedTemplateExpression", "isTemplateElement", "isTemplateLiteral", "isYieldExpression", "isAwaitExpression", "isImport", "isBigIntLiteral", "isExportNamespaceSpecifier", "isOptionalMemberExpression", "isOptionalCallExpression", "isClassProperty", "isClassAccessorProperty", "isClassPrivateProperty", "isClassPrivateMethod", "isPrivateName", "isStaticBlock", "isAnyTypeAnnotation", "isArrayTypeAnnotation", "isBooleanTypeAnnotation", "isBooleanLiteralTypeAnnotation", "isNullLiteralTypeAnnotation", "isClassImplements", "isDeclareClass", "isDeclareFunction", "isDeclareInterface", "isDeclareModule", "isDeclareModuleExports", "isDeclareTypeAlias", "isDeclareOpaqueType", "isDeclareVariable", "isDeclareExportDeclaration", "isDeclareExportAllDeclaration", "isDeclaredPredicate", "isExistsTypeAnnotation", "isFunctionTypeAnnotation", "isFunctionTypeParam", "isGenericTypeAnnotation", "isInferredPredicate", "isInterfaceExtends", "isInterfaceDeclaration", "isInterfaceTypeAnnotation", "isIntersectionTypeAnnotation", "isMixedTypeAnnotation", "isEmptyTypeAnnotation", "isNullableTypeAnnotation", "isNumberLiteralTypeAnnotation", "isNumberTypeAnnotation", "isObjectTypeAnnotation", "isObjectTypeInternalSlot", "isObjectTypeCallProperty", "isObjectTypeIndexer", "isObjectTypeProperty", "isObjectTypeSpreadProperty", "isOpaqueType", "isQualifiedTypeIdentifier", "isStringLiteralTypeAnnotation", "isStringTypeAnnotation", "isSymbolTypeAnnotation", "isThisTypeAnnotation", "isTupleTypeAnnotation", "isTypeofTypeAnnotation", "isTypeAlias", "isTypeAnnotation", "isTypeCastExpression", "isTypeParameter", "isTypeParameterDeclaration", "isTypeParameterInstantiation", "isUnionTypeAnnotation", "isVariance", "isVoidTypeAnnotation", "isEnumDeclaration", "isEnumBooleanBody", "isEnumNumberBody", "isEnumStringBody", "isEnumSymbolBody", "isEnumBooleanMember", "isEnumNumberMember", "isEnumStringMember", "isEnumDefaultedMember", "isIndexedAccessType", "isOptionalIndexedAccessType", "isJSXAttribute", "isJSXClosingElement", "isJSXElement", "isJSXEmptyExpression", "isJSXExpressionContainer", "isJSXSpreadChild", "isJSXIdentifier", "isJSXMemberExpression", "isJSXNamespacedName", "isJSXOpeningElement", "isJSXSpreadAttribute", "isJSXText", "isJSXFragment", "isJSXOpeningFragment", "isJSXClosingFragment", "isNoop", "isPlaceholder", "isV8IntrinsicIdentifier", "isArgumentPlaceholder", "isBindExpression", "isImportAttribute", "isDecorator", "isDoExpression", "isExportDefaultSpecifier", "isRecordExpression", "isTupleExpression", "isDecimalLiteral", "isModuleExpression", "isTopicReference", "isPipelineTopicExpression", "isPipelineBareFunction", "isPipelinePrimaryTopicReference", "isTSParameterProperty", "isTSDeclareFunction", "isTSDeclareMethod", "isTSQualifiedName", "isTSCallSignatureDeclaration", "isTSConstructSignatureDeclaration", "isTSPropertySignature", "isTSMethodSignature", "isTSIndexSignature", "isTSAnyKeyword", "isTSBooleanKeyword", "isTSBigIntKeyword", "isTSIntrinsicKeyword", "isTSNeverKeyword", "isTSNullKeyword", "isTSNumberKeyword", "isTSObjectKeyword", "isTSStringKeyword", "isTSSymbolKeyword", "isTSUndefinedKeyword", "isTSUnknownKeyword", "isTSVoidKeyword", "isTSThisType", "isTSFunctionType", "isTSConstructorType", "isTSTypeReference", "isTSTypePredicate", "isTSTypeQuery", "isTSTypeLiteral", "isTSArrayType", "isTSTupleType", "isTSOptionalType", "isTSRestType", "isTSNamedTupleMember", "isTSUnionType", "isTSIntersectionType", "isTSConditionalType", "isTSInferType", "isTSParenthesizedType", "isTSTypeOperator", "isTSIndexedAccessType", "isTSMappedType", "isTSLiteralType", "isTSExpressionWithTypeArguments", "isTSInterfaceDeclaration", "isTSInterfaceBody", "isTSTypeAliasDeclaration", "isTSInstantiationExpression", "isTSAsExpression", "isTSSatisfiesExpression", "isTSTypeAssertion", "isTSEnumDeclaration", "isTSEnumMember", "isTSModuleDeclaration", "isTSModuleBlock", "isTSImportType", "isTSImportEqualsDeclaration", "isTSExternalModuleReference", "isTSNonNullExpression", "isTSExportAssignment", "isTSNamespaceExportDeclaration", "isTSTypeAnnotation", "isTSTypeParameterInstantiation", "isTSTypeParameterDeclaration", "isTSTypeParameter", "isStandardized", "expectedNode", "isExpression", "isBinary", "isScopable", "isBlockParent", "isBlock", "isStatement", "isTerminatorless", "isCompletionStatement", "isConditional", "isLoop", "isWhile", "isExpressionWrapper", "isFor", "isForXStatement", "isFunction", "isFunctionParent", "isPureish", "isDeclaration", "isPatternLike", "isLVal", "isTSEntityName", "isLiteral", "isImmutable", "isUserWhitespacable", "isMethod", "isObjectMember", "isProperty", "isUnaryLike", "isPattern", "isClass", "isImportOrExportDeclaration", "isExportDeclaration", "isModuleSpecifier", "isAccessor", "isPrivate", "isFlow", "isFlowType", "isFlowBaseAnnotation", "isFlowDeclaration", "isFlowPredicate", "isEnumBody", "isEnumMember", "isJSX", "isMiscellaneous", "isTypeScript", "isTSTypeElement", "isTSType", "isTSBaseType", "isNumberLiteral", "deprecationWarning", "isRegexLiteral", "isRestProperty", "isSpreadProperty", "isModuleDeclaration", "_index", "require", "matchesPattern", "member", "match", "allowPartial", "isMemberExpression", "parts", "Array", "isArray", "split", "nodes", "node", "object", "push", "property", "length", "i", "j", "value", "isIdentifier", "name", "isStringLiteral", "isThisExpression", "_matchesPattern", "require", "buildMatchMemberExpression", "match", "allowPartial", "parts", "split", "member", "matchesPattern", "_buildMatchMemberExpression", "require", "isReactComponent", "buildMatchMemberExpression", "_default", "exports", "default", "isCompatTag", "tagName", "test", "_index", "require", "isType", "nodeType", "targetType", "ALIAS_KEYS", "aliases", "FLIPPED_ALIAS_KEYS", "alias", "_index", "require", "isPlaceholderType", "placeholderType", "targetType", "aliases", "PLACEHOLDERS_ALIAS", "alias", "_shallowEqual", "require", "_isType", "_isPlaceholderType", "_index", "is", "type", "node", "opts", "matches", "isType", "FLIPPED_ALIAS_KEYS", "isPlaceholderType", "expectedNode", "undefined", "shallowEqual", "nonASCIIidentifierStartChars", "nonASCIIidentifierChars", "nonASCIIidentifierStart", "RegExp", "nonASCIIidentifier", "astralIdentifierStartCodes", "astralIdentifierCodes", "isInAstralSet", "code", "set", "pos", "i", "length", "isIdentifierStart", "test", "String", "fromCharCode", "isIdentifierChar", "isIdentifierName", "name", "isFirst", "cp", "charCodeAt", "trail", "reservedWords", "keyword", "strict", "strictBind", "keywords", "Set", "reservedWordsStrictSet", "reservedWordsStrictBindSet", "isReservedWord", "word", "inModule", "isStrictReservedWord", "has", "isStrictBindOnlyReservedWord", "isStrictBindReservedWord", "isKeyword", "_identifier", "require", "_keyword", "_helperValidatorIdentifier", "require", "isValidIdentifier", "name", "reserved", "isKeyword", "isStrictReservedWord", "isIdentifierName", "isDigit", "code", "forbiddenNumericSeparatorSiblings", "decBinOct", "Set", "hex", "isAllowedNumericSeparatorSibling", "bin", "ch", "oct", "dec", "readStringContents", "type", "input", "pos", "lineStart", "curLine", "errors", "initialPos", "initialLineStart", "initialCurLine", "out", "firstInvalidLoc", "chunkStart", "length", "unterminated", "slice", "charCodeAt", "isStringEnd", "res", "readEscapedChar", "str", "containsInvalid", "inTemplate", "throwOnInvalid", "readHexChar", "String", "fromCharCode", "readCodePoint", "fromCodePoint", "strictNumericEscape", "startPos", "match", "exec", "octalStr", "octal", "parseInt", "next", "len", "forceLen", "n", "readInt", "invalidEscapeSequence", "radix", "allowNumSeparator", "bailOnError", "start", "forbiddenSiblings", "isAllowedSibling", "invalid", "total", "i", "e", "Infinity", "val", "prev", "numericSeparatorInEscapeSequence", "Number", "isNaN", "has", "unexpectedNumericSeparator", "_isDigit", "invalidDigit", "indexOf", "invalidCodePoint", "STATEMENT_OR_BLOCK_KEYS", "exports", "FLATTENABLE_KEYS", "FOR_INIT_KEYS", "COMMENT_KEYS", "LOGICAL_OPERATORS", "UPDATE_OPERATORS", "BOOLEAN_NUMBER_BINARY_OPERATORS", "EQUALITY_BINARY_OPERATORS", "COMPARISON_BINARY_OPERATORS", "BOOLEAN_BINARY_OPERATORS", "NUMBER_BINARY_OPERATORS", "BINARY_OPERATORS", "ASSIGNMENT_OPERATORS", "map", "op", "BOOLEAN_UNARY_OPERATORS", "NUMBER_UNARY_OPERATORS", "STRING_UNARY_OPERATORS", "UNARY_OPERATORS", "INHERIT_KEYS", "optional", "force", "BLOCK_SCOPED_SYMBOL", "Symbol", "for", "NOT_LOCAL_BINDING", "_is", "require", "_validate", "VISITOR_KEYS", "exports", "ALIAS_KEYS", "FLIPPED_ALIAS_KEYS", "NODE_FIELDS", "BUILDER_KEYS", "DEPRECATED_KEYS", "NODE_PARENT_VALIDATIONS", "getType", "val", "Array", "isArray", "validate", "validateType", "typeNames", "assertNodeType", "validateOptional", "optional", "validateOptionalType", "arrayOf", "elementType", "chain", "assertValueType", "assertEach", "arrayOfType", "validateArrayOfType", "callback", "childValidator", "process", "env", "BABEL_TYPES_8_BREAKING", "validateChild", "validator", "node", "key", "i", "length", "subkey", "v", "each", "assertOneOf", "values", "includes", "TypeError", "JSON", "stringify", "oneOf", "types", "type", "is", "oneOfNodeTypes", "assertNodeOrValueType", "oneOfNodeOrValueTypes", "valid", "assertShape", "shape", "errors", "property", "Object", "keys", "validateField", "error", "push", "message", "join", "shapeOf", "assertOptionalChainStart", "_current", "current", "callee", "object", "fns", "args", "fn", "chainOf", "Error", "validTypeOpts", "Set", "validFieldKeys", "store", "defineAliasedType", "aliases", "opts", "defined", "_store$opts$inherits$", "_defined", "inherits", "slice", "additional", "filter", "a", "unshift", "defineType", "fields", "getOwnPropertyNames", "field", "def", "default", "deprecated", "visitor", "builder", "k", "has", "deprecatedAlias", "concat", "undefined", "forEach", "alias", "_is", "require", "_isValidIdentifier", "_helperValidatorIdentifier", "_helperStringParser", "_index", "_utils", "defineType", "defineAliasedType", "fields", "elements", "validate", "arrayOf", "assertNodeOrValueType", "default", "process", "env", "BABEL_TYPES_8_BREAKING", "undefined", "visitor", "aliases", "operator", "assertValueType", "Object", "assign", "identifier", "assertOneOf", "ASSIGNMENT_OPERATORS", "pattern", "node", "key", "val", "validator", "is", "left", "type", "assertNodeType", "right", "builder", "BINARY_OPERATORS", "expression", "inOp", "oneOfNodeTypes", "value", "directives", "arrayOfType", "body", "validateArrayOfType", "label", "optional", "callee", "arguments", "typeArguments", "typeParameters", "param", "test", "consequent", "alternate", "program", "comments", "each", "assertEach", "tokens", "init", "update", "functionCommon", "params", "generator", "async", "exports", "functionTypeAnnotationCommon", "returnType", "functionDeclarationCommon", "declare", "id", "predicate", "parent", "inherits", "patternLikeCommon", "typeAnnotation", "decorators", "name", "chain", "isValidIdentifier", "TypeError", "match", "exec", "parentKey", "nonComp", "computed", "imported", "meta", "isKeyword", "isReservedWord", "deprecatedAlias", "Number", "isFinite", "error", "Error", "flags", "invalid", "LOGICAL_OPERATORS", "object", "property", "normal", "sourceType", "interpreter", "properties", "kind", "shorthand", "argument", "listKey", "index", "length", "expressions", "discriminant", "cases", "block", "handler", "finalizer", "prefix", "UNARY_OPERATORS", "UPDATE_OPERATORS", "declarations", "withoutInit", "forEach", "decl", "definite", "superClass", "superTypeParameters", "implements", "mixins", "abstract", "importAttributes", "attributes", "assertions", "deprecated", "source", "exportKind", "validateOptional", "declaration", "validateType", "specifiers", "sourced", "sourceless", "local", "exported", "lval", "await", "module", "phase", "importKind", "options", "classMethodOrPropertyCommon", "accessibility", "static", "override", "classMethodOrDeclareMethodCommon", "access", "tag", "quasi", "assertShape", "raw", "cooked", "templateElementCookedValidator", "unterminatedCalled", "str", "firstInvalidLoc", "readStringContents", "unterminated", "strictNumericEscape", "invalidEscapeSequence", "numericSeparatorInEscapeSequence", "unexpectedNumericSeparator", "invalidDigit", "invalidCodePoint", "tail", "quasis", "delegate", "assertOptionalChainStart", "readonly", "variance", "_core", "require", "_utils", "defineType", "defineAliasedType", "defineInterfaceishType", "name", "isDeclareClass", "builder", "visitor", "aliases", "fields", "Object", "assign", "id", "validateType", "typeParameters", "validateOptionalType", "extends", "validateOptional", "arrayOfType", "mixins", "implements", "body", "elementType", "value", "validate", "assertValueType", "predicate", "kind", "assertOneOf", "typeAnnotation", "right", "supertype", "impltype", "declaration", "specifiers", "source", "default", "importAttributes", "exportKind", "params", "validateArrayOfType", "rest", "this", "returnType", "optional", "types", "properties", "indexers", "callProperties", "internalSlots", "exact", "inexact", "static", "method", "key", "variance", "proto", "argument", "qualification", "expression", "bound", "explicitType", "members", "hasUnknownMembers", "init", "objectType", "indexType", "_utils", "require", "defineType", "defineAliasedType", "visitor", "aliases", "fields", "name", "validate", "assertNodeType", "value", "optional", "builder", "Object", "assign", "openingElement", "closingElement", "children", "validateArrayOfType", "selfClosing", "assertValueType", "expression", "object", "property", "namespace", "default", "attributes", "typeParameters", "argument", "openingFragment", "closingFragment", "_utils", "require", "PLACEHOLDERS", "exports", "PLACEHOLDERS_ALIAS", "Declaration", "Pattern", "type", "alias", "ALIAS_KEYS", "length", "PLACEHOLDERS_FLIPPED_ALIAS", "Object", "keys", "forEach", "hasOwnProperty", "call", "push", "_utils", "require", "_placeholders", "_core", "defineType", "defineAliasedType", "visitor", "builder", "fields", "Object", "assign", "name", "validate", "assertNodeType", "expectedNode", "assertOneOf", "PLACEHOLDERS", "patternLikeCommon", "assertValueType", "_utils", "require", "defineType", "visitor", "aliases", "fields", "process", "env", "BABEL_TYPES_8_BREAKING", "object", "validate", "Object", "assign", "oneOfNodeTypes", "callee", "assertNodeType", "key", "value", "expression", "builder", "body", "async", "assertValueType", "default", "exported", "properties", "validateArrayOfType", "elements", "arrayOfType", "_utils", "require", "_core", "_is", "defineType", "defineAliasedType", "bool", "assertValueType", "tSFunctionTypeAnnotationCommon", "returnType", "validate", "assertNodeType", "optional", "typeParameters", "aliases", "visitor", "fields", "accessibility", "assertOneOf", "readonly", "parameter", "override", "decorators", "arrayOfType", "Object", "assign", "functionDeclarationCommon", "classMethodOrDeclareMethodCommon", "left", "validateType", "right", "signatureDeclarationCommon", "validateOptionalType", "validateArrayOfType", "callConstructSignatureDeclaration", "namedTypeElementCommon", "key", "computed", "default", "validateOptional", "typeAnnotation", "kind", "static", "parameters", "tsKeywordTypes", "type", "fnOrCtrBase", "abstract", "typeName", "builder", "parameterName", "asserts", "exprName", "members", "elementType", "elementTypes", "label", "unionOrIntersection", "types", "checkType", "extendsType", "trueType", "falseType", "typeParameter", "operator", "objectType", "indexType", "nameType", "literal", "unaryExpression", "unaryOperator", "validator", "parent", "node", "is", "argument", "oneOfNodeTypes", "expressionWithTypeArguments", "expression", "declare", "id", "extends", "body", "TSTypeExpression", "const", "initializer", "global", "qualifier", "options", "isExport", "moduleReference", "importKind", "params", "name", "in", "out", "constraint", "DEPRECATED_ALIASES", "exports", "ModuleDeclaration", "require", "_utils", "_placeholders", "_deprecatedAliases", "Object", "keys", "DEPRECATED_ALIASES", "forEach", "deprecatedAlias", "FLIPPED_ALIAS_KEYS", "TYPES", "exports", "concat", "VISITOR_KEYS", "DEPRECATED_KEYS", "_index", "require", "validate", "node", "key", "val", "fields", "NODE_FIELDS", "type", "field", "validateField", "validateChild", "validateInternal", "maybeNode", "optional", "_NODE_PARENT_VALIDATI", "NODE_PARENT_VALIDATIONS", "call", "_NODE_PARENT_VALIDATI2", "_validate", "require", "_deprecationWarning", "utils", "validateInternal", "validate", "NODE_FIELDS", "arrayExpression", "elements", "node", "type", "defs", "ArrayExpression", "assignmentExpression", "operator", "left", "right", "AssignmentExpression", "binaryExpression", "BinaryExpression", "interpreterDirective", "value", "InterpreterDirective", "directive", "Directive", "directiveLiteral", "DirectiveLiteral", "blockStatement", "body", "directives", "BlockStatement", "breakStatement", "label", "BreakStatement", "callExpression", "callee", "_arguments", "arguments", "CallExpression", "catchClause", "param", "CatchClause", "conditionalExpression", "test", "consequent", "alternate", "ConditionalExpression", "continueStatement", "ContinueStatement", "debuggerStatement", "doWhileStatement", "DoWhileStatement", "emptyStatement", "expressionStatement", "expression", "ExpressionStatement", "file", "program", "comments", "tokens", "File", "forInStatement", "ForInStatement", "forStatement", "init", "update", "ForStatement", "functionDeclaration", "id", "params", "generator", "async", "FunctionDeclaration", "functionExpression", "FunctionExpression", "identifier", "name", "Identifier", "ifStatement", "IfStatement", "labeledStatement", "LabeledStatement", "stringLiteral", "StringLiteral", "numericLiteral", "NumericLiteral", "nullLiteral", "booleanLiteral", "BooleanLiteral", "regExpLiteral", "pattern", "flags", "RegExpLiteral", "logicalExpression", "LogicalExpression", "memberExpression", "object", "property", "computed", "optional", "MemberExpression", "newExpression", "NewExpression", "sourceType", "interpreter", "Program", "objectExpression", "properties", "ObjectExpression", "objectMethod", "kind", "key", "ObjectMethod", "objectProperty", "shorthand", "decorators", "ObjectProperty", "restElement", "argument", "RestElement", "returnStatement", "ReturnStatement", "sequenceExpression", "expressions", "SequenceExpression", "parenthesizedExpression", "ParenthesizedExpression", "switchCase", "SwitchCase", "switchStatement", "discriminant", "cases", "SwitchStatement", "thisExpression", "throwStatement", "ThrowStatement", "tryStatement", "block", "handler", "finalizer", "TryStatement", "unaryExpression", "prefix", "UnaryExpression", "updateExpression", "UpdateExpression", "variableDeclaration", "declarations", "VariableDeclaration", "variableDeclarator", "VariableDeclarator", "whileStatement", "WhileStatement", "withStatement", "WithStatement", "assignmentPattern", "AssignmentPattern", "arrayPattern", "ArrayPattern", "arrowFunctionExpression", "ArrowFunctionExpression", "classBody", "ClassBody", "classExpression", "superClass", "ClassExpression", "classDeclaration", "ClassDeclaration", "exportAllDeclaration", "source", "ExportAllDeclaration", "exportDefaultDeclaration", "declaration", "ExportDefaultDeclaration", "exportNamedDeclaration", "specifiers", "ExportNamedDeclaration", "exportSpecifier", "local", "exported", "ExportSpecifier", "forOfStatement", "_await", "await", "ForOfStatement", "importDeclaration", "ImportDeclaration", "importDefaultSpecifier", "ImportDefaultSpecifier", "importNamespaceSpecifier", "ImportNamespaceSpecifier", "importSpecifier", "imported", "ImportSpecifier", "importExpression", "options", "ImportExpression", "metaProperty", "meta", "MetaProperty", "classMethod", "_static", "static", "ClassMethod", "objectPattern", "ObjectPattern", "spreadElement", "SpreadElement", "_super", "taggedTemplateExpression", "tag", "quasi", "TaggedTemplateExpression", "templateElement", "tail", "TemplateElement", "templateLiteral", "quasis", "TemplateLiteral", "yieldExpression", "delegate", "YieldExpression", "awaitExpression", "AwaitExpression", "_import", "bigIntLiteral", "BigIntLiteral", "exportNamespaceSpecifier", "ExportNamespaceSpecifier", "optionalMemberExpression", "OptionalMemberExpression", "optionalCallExpression", "OptionalCallExpression", "classProperty", "typeAnnotation", "ClassProperty", "classAccessorProperty", "ClassAccessorProperty", "classPrivateProperty", "ClassPrivateProperty", "classPrivateMethod", "ClassPrivateMethod", "privateName", "PrivateName", "staticBlock", "StaticBlock", "anyTypeAnnotation", "arrayTypeAnnotation", "elementType", "ArrayTypeAnnotation", "booleanTypeAnnotation", "booleanLiteralTypeAnnotation", "BooleanLiteralTypeAnnotation", "nullLiteralTypeAnnotation", "classImplements", "typeParameters", "ClassImplements", "declareClass", "_extends", "extends", "DeclareClass", "declareFunction", "DeclareFunction", "declareInterface", "DeclareInterface", "declareModule", "DeclareModule", "declareModuleExports", "DeclareModuleExports", "declareTypeAlias", "DeclareTypeAlias", "declareOpaqueType", "supertype", "DeclareOpaqueType", "declareVariable", "DeclareVariable", "declareExportDeclaration", "attributes", "DeclareExportDeclaration", "declareExportAllDeclaration", "DeclareExportAllDeclaration", "declaredPredicate", "DeclaredPredicate", "existsTypeAnnotation", "functionTypeAnnotation", "rest", "returnType", "FunctionTypeAnnotation", "functionTypeParam", "FunctionTypeParam", "genericTypeAnnotation", "GenericTypeAnnotation", "inferredPredicate", "interfaceExtends", "InterfaceExtends", "interfaceDeclaration", "InterfaceDeclaration", "interfaceTypeAnnotation", "InterfaceTypeAnnotation", "intersectionTypeAnnotation", "types", "IntersectionTypeAnnotation", "mixedTypeAnnotation", "emptyTypeAnnotation", "nullableTypeAnnotation", "NullableTypeAnnotation", "numberLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "numberTypeAnnotation", "objectTypeAnnotation", "indexers", "callProperties", "internalSlots", "exact", "ObjectTypeAnnotation", "objectTypeInternalSlot", "method", "ObjectTypeInternalSlot", "objectTypeCallProperty", "ObjectTypeCallProperty", "objectTypeIndexer", "variance", "ObjectTypeIndexer", "objectTypeProperty", "proto", "ObjectTypeProperty", "objectTypeSpreadProperty", "ObjectTypeSpreadProperty", "opaqueType", "impltype", "OpaqueType", "qualifiedTypeIdentifier", "qualification", "QualifiedTypeIdentifier", "stringLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "stringTypeAnnotation", "symbolTypeAnnotation", "thisTypeAnnotation", "tupleTypeAnnotation", "TupleTypeAnnotation", "typeofTypeAnnotation", "TypeofTypeAnnotation", "typeAlias", "TypeAlias", "TypeAnnotation", "typeCastExpression", "TypeCastExpression", "typeParameter", "bound", "_default", "default", "TypeParameter", "typeParameterDeclaration", "TypeParameterDeclaration", "typeParameterInstantiation", "TypeParameterInstantiation", "unionTypeAnnotation", "UnionTypeAnnotation", "Variance", "voidTypeAnnotation", "enumDeclaration", "EnumDeclaration", "enumBooleanBody", "members", "explicitType", "hasUnknownMembers", "EnumBooleanBody", "enumNumberBody", "EnumNumberBody", "enumStringBody", "EnumStringBody", "enumSymbolBody", "EnumSymbolBody", "enumBooleanMember", "EnumBooleanMember", "enumNumberMember", "EnumNumberMember", "enumStringMember", "EnumStringMember", "enumDefaultedMember", "EnumDefaultedMember", "indexedAccessType", "objectType", "indexType", "IndexedAccessType", "optionalIndexedAccessType", "OptionalIndexedAccessType", "jsxAttribute", "JSXAttribute", "jsxClosingElement", "JSXClosingElement", "jsxElement", "openingElement", "closingElement", "children", "selfClosing", "JSXElement", "jsxEmptyExpression", "jsxExpressionContainer", "JSXExpressionContainer", "jsxSpreadChild", "JSXSpreadChild", "jsxIdentifier", "JSXIdentifier", "jsxMemberExpression", "JSXMemberExpression", "jsxNamespacedName", "namespace", "JSXNamespacedName", "jsxOpeningElement", "JSXOpeningElement", "jsxSpreadAttribute", "JSXSpreadAttribute", "jsxText", "JSXText", "jsxFragment", "openingFragment", "closingFragment", "JSXFragment", "jsxOpeningFragment", "jsxClosingFragment", "noop", "placeholder", "expectedNode", "Placeholder", "v8IntrinsicIdentifier", "V8IntrinsicIdentifier", "argumentPlaceholder", "bindExpression", "BindExpression", "importAttribute", "ImportAttribute", "decorator", "Decorator", "doExpression", "DoExpression", "exportDefaultSpecifier", "ExportDefaultSpecifier", "recordExpression", "RecordExpression", "tupleExpression", "TupleExpression", "decimalLiteral", "DecimalLiteral", "moduleExpression", "ModuleExpression", "topicReference", "pipelineTopicExpression", "PipelineTopicExpression", "pipelineBareFunction", "PipelineBareFunction", "pipelinePrimaryTopicReference", "tsParameterProperty", "parameter", "TSParameterProperty", "tsDeclareFunction", "TSDeclareFunction", "tsDeclareMethod", "TSDeclareMethod", "tsQualifiedName", "TSQualifiedName", "tsCallSignatureDeclaration", "parameters", "TSCallSignatureDeclaration", "tsConstructSignatureDeclaration", "TSConstructSignatureDeclaration", "tsPropertySignature", "TSPropertySignature", "tsMethodSignature", "TSMethodSignature", "tsIndexSignature", "TSIndexSignature", "tsAnyKeyword", "tsBooleanKeyword", "tsBigIntKeyword", "tsIntrinsicKeyword", "tsNeverKeyword", "tsNullKeyword", "tsNumberKeyword", "tsObjectKeyword", "tsStringKeyword", "tsSymbolKeyword", "tsUndefinedKeyword", "tsUnknownKeyword", "tsVoidKeyword", "tsThisType", "tsFunctionType", "TSFunctionType", "tsConstructorType", "TSConstructorType", "tsTypeReference", "typeName", "TSTypeReference", "tsTypePredicate", "parameterName", "asserts", "TSTypePredicate", "tsTypeQuery", "exprName", "TSTypeQuery", "tsTypeLiteral", "TSTypeLiteral", "tsArrayType", "TSArrayType", "tsTupleType", "elementTypes", "TSTupleType", "tsOptionalType", "TSOptionalType", "tsRestType", "TSRestType", "tsNamedTupleMember", "TSNamedTupleMember", "tsUnionType", "TSUnionType", "tsIntersectionType", "TSIntersectionType", "tsConditionalType", "checkType", "extendsType", "trueType", "falseType", "TSConditionalType", "tsInferType", "TSInferType", "tsParenthesizedType", "TSParenthesizedType", "tsTypeOperator", "TSTypeOperator", "tsIndexedAccessType", "TSIndexedAccessType", "tsMappedType", "nameType", "TSMappedType", "tsLiteralType", "literal", "TSLiteralType", "tsExpressionWithTypeArguments", "TSExpressionWithTypeArguments", "tsInterfaceDeclaration", "TSInterfaceDeclaration", "tsInterfaceBody", "TSInterfaceBody", "tsTypeAliasDeclaration", "TSTypeAliasDeclaration", "tsInstantiationExpression", "TSInstantiationExpression", "tsAsExpression", "TSAsExpression", "tsSatisfiesExpression", "TSSatisfiesExpression", "tsTypeAssertion", "TSTypeAssertion", "tsEnumDeclaration", "TSEnumDeclaration", "tsEnumMember", "initializer", "TSEnumMember", "tsModuleDeclaration", "TSModuleDeclaration", "tsModuleBlock", "TSModuleBlock", "tsImportType", "qualifier", "TSImportType", "tsImportEqualsDeclaration", "moduleReference", "isExport", "TSImportEqualsDeclaration", "tsExternalModuleReference", "TSExternalModuleReference", "tsNonNullExpression", "TSNonNullExpression", "tsExportAssignment", "TSExportAssignment", "tsNamespaceExportDeclaration", "TSNamespaceExportDeclaration", "tsTypeAnnotation", "TSTypeAnnotation", "tsTypeParameterInstantiation", "TSTypeParameterInstantiation", "tsTypeParameterDeclaration", "TSTypeParameterDeclaration", "tsTypeParameter", "constraint", "TSTypeParameter", "NumberLiteral", "deprecationWarning", "RegexLiteral", "RestProperty", "SpreadProperty", "_index", "require", "_index2", "cleanJSXElementLiteralChild", "child", "args", "lines", "value", "split", "lastNonEmptyLine", "i", "length", "exec", "str", "line", "isFirstLine", "isLastLine", "isLastNonEmptyLine", "trimmedLine", "replace", "push", "inherits", "stringLiteral", "_index", "require", "_cleanJSXElementLiteralChild", "buildChildren", "node", "elements", "i", "children", "length", "child", "isJSXText", "cleanJSXElementLiteralChild", "isJSXExpressionContainer", "expression", "isJSXEmptyExpression", "push", "_index", "require", "isNode", "node", "VISITOR_KEYS", "type", "_isNode", "require", "assertNode", "node", "isNode", "_node$type", "type", "JSON", "stringify", "TypeError", "_is", "require", "_deprecationWarning", "assert", "type", "node", "opts", "is", "Error", "JSON", "stringify", "assertArrayExpression", "assertAssignmentExpression", "assertBinaryExpression", "assertInterpreterDirective", "assertDirective", "assertDirectiveLiteral", "assertBlockStatement", "assertBreakStatement", "assertCallExpression", "assertCatchClause", "assertConditionalExpression", "assertContinueStatement", "assertDebuggerStatement", "assertDoWhileStatement", "assertEmptyStatement", "assertExpressionStatement", "assertFile", "assertForInStatement", "assertForStatement", "assertFunctionDeclaration", "assertFunctionExpression", "assertIdentifier", "assertIfStatement", "assertLabeledStatement", "assertStringLiteral", "assertNumericLiteral", "assertNullLiteral", "assertBooleanLiteral", "assertRegExpLiteral", "assertLogicalExpression", "assertMemberExpression", "assertNewExpression", "assertProgram", "assertObjectExpression", "assertObjectMethod", "assertObjectProperty", "assertRestElement", "assertReturnStatement", "assertSequenceExpression", "assertParenthesizedExpression", "assertSwitchCase", "assertSwitchStatement", "assertThisExpression", "assertThrowStatement", "assertTryStatement", "assertUnaryExpression", "assertUpdateExpression", "assertVariableDeclaration", "assertVariableDeclarator", "assertWhileStatement", "assertWithStatement", "assertAssignmentPattern", "assertArrayPattern", "assertArrowFunctionExpression", "assertClassBody", "assertClassExpression", "assertClassDeclaration", "assertExportAllDeclaration", "assertExportDefaultDeclaration", "assertExportNamedDeclaration", "assertExportSpecifier", "assertForOfStatement", "assertImportDeclaration", "assertImportDefaultSpecifier", "assertImportNamespaceSpecifier", "assertImportSpecifier", "assertImportExpression", "assertMetaProperty", "assertClassMethod", "assertObjectPattern", "assertSpreadElement", "assertSuper", "assertTaggedTemplateExpression", "assertTemplateElement", "assertTemplateLiteral", "assertYieldExpression", "assertAwaitExpression", "assertImport", "assertBigIntLiteral", "assertExportNamespaceSpecifier", "assertOptionalMemberExpression", "assertOptionalCallExpression", "assertClassProperty", "assertClassAccessorProperty", "assertClassPrivateProperty", "assertClassPrivateMethod", "assertPrivateName", "assertStaticBlock", "assertAnyTypeAnnotation", "assertArrayTypeAnnotation", "assertBooleanTypeAnnotation", "assertBooleanLiteralTypeAnnotation", "assertNullLiteralTypeAnnotation", "assertClassImplements", "assertDeclareClass", "assertDeclareFunction", "assertDeclareInterface", "assertDeclareModule", "assertDeclareModuleExports", "assertDeclareTypeAlias", "assertDeclareOpaqueType", "assertDeclareVariable", "assertDeclareExportDeclaration", "assertDeclareExportAllDeclaration", "assertDeclaredPredicate", "assertExistsTypeAnnotation", "assertFunctionTypeAnnotation", "assertFunctionTypeParam", "assertGenericTypeAnnotation", "assertInferredPredicate", "assertInterfaceExtends", "assertInterfaceDeclaration", "assertInterfaceTypeAnnotation", "assertIntersectionTypeAnnotation", "assertMixedTypeAnnotation", "assertEmptyTypeAnnotation", "assertNullableTypeAnnotation", "assertNumberLiteralTypeAnnotation", "assertNumberTypeAnnotation", "assertObjectTypeAnnotation", "assertObjectTypeInternalSlot", "assertObjectTypeCallProperty", "assertObjectTypeIndexer", "assertObjectTypeProperty", "assertObjectTypeSpreadProperty", "assertOpaqueType", "assertQualifiedTypeIdentifier", "assertStringLiteralTypeAnnotation", "assertStringTypeAnnotation", "assertSymbolTypeAnnotation", "assertThisTypeAnnotation", "assertTupleTypeAnnotation", "assertTypeofTypeAnnotation", "assertTypeAlias", "assertTypeAnnotation", "assertTypeCastExpression", "assertTypeParameter", "assertTypeParameterDeclaration", "assertTypeParameterInstantiation", "assertUnionTypeAnnotation", "assertVariance", "assertVoidTypeAnnotation", "assertEnumDeclaration", "assertEnumBooleanBody", "assertEnumNumberBody", "assertEnumStringBody", "assertEnumSymbolBody", "assertEnumBooleanMember", "assertEnumNumberMember", "assertEnumStringMember", "assertEnumDefaultedMember", "assertIndexedAccessType", "assertOptionalIndexedAccessType", "assertJSXAttribute", "assertJSXClosingElement", "assertJSXElement", "assertJSXEmptyExpression", "assertJSXExpressionContainer", "assertJSXSpreadChild", "assertJSXIdentifier", "assertJSXMemberExpression", "assertJSXNamespacedName", "assertJSXOpeningElement", "assertJSXSpreadAttribute", "assertJSXText", "assertJSXFragment", "assertJSXOpeningFragment", "assertJSXClosingFragment", "assertNoop", "assertPlaceholder", "assertV8IntrinsicIdentifier", "assertArgumentPlaceholder", "assertBindExpression", "assertImportAttribute", "assertDecorator", "assertDoExpression", "assertExportDefaultSpecifier", "assertRecordExpression", "assertTupleExpression", "assertDecimalLiteral", "assertModuleExpression", "assertTopicReference", "assertPipelineTopicExpression", "assertPipelineBareFunction", "assertPipelinePrimaryTopicReference", "assertTSParameterProperty", "assertTSDeclareFunction", "assertTSDeclareMethod", "assertTSQualifiedName", "assertTSCallSignatureDeclaration", "assertTSConstructSignatureDeclaration", "assertTSPropertySignature", "assertTSMethodSignature", "assertTSIndexSignature", "assertTSAnyKeyword", "assertTSBooleanKeyword", "assertTSBigIntKeyword", "assertTSIntrinsicKeyword", "assertTSNeverKeyword", "assertTSNullKeyword", "assertTSNumberKeyword", "assertTSObjectKeyword", "assertTSStringKeyword", "assertTSSymbolKeyword", "assertTSUndefinedKeyword", "assertTSUnknownKeyword", "assertTSVoidKeyword", "assertTSThisType", "assertTSFunctionType", "assertTSConstructorType", "assertTSTypeReference", "assertTSTypePredicate", "assertTSTypeQuery", "assertTSTypeLiteral", "assertTSArrayType", "assertTSTupleType", "assertTSOptionalType", "assertTSRestType", "assertTSNamedTupleMember", "assertTSUnionType", "assertTSIntersectionType", "assertTSConditionalType", "assertTSInferType", "assertTSParenthesizedType", "assertTSTypeOperator", "assertTSIndexedAccessType", "assertTSMappedType", "assertTSLiteralType", "assertTSExpressionWithTypeArguments", "assertTSInterfaceDeclaration", "assertTSInterfaceBody", "assertTSTypeAliasDeclaration", "assertTSInstantiationExpression", "assertTSAsExpression", "assertTSSatisfiesExpression", "assertTSTypeAssertion", "assertTSEnumDeclaration", "assertTSEnumMember", "assertTSModuleDeclaration", "assertTSModuleBlock", "assertTSImportType", "assertTSImportEqualsDeclaration", "assertTSExternalModuleReference", "assertTSNonNullExpression", "assertTSExportAssignment", "assertTSNamespaceExportDeclaration", "assertTSTypeAnnotation", "assertTSTypeParameterInstantiation", "assertTSTypeParameterDeclaration", "assertTSTypeParameter", "assertStandardized", "assertExpression", "assertBinary", "assertScopable", "assertBlockParent", "assertBlock", "assertStatement", "assertTerminatorless", "assertCompletionStatement", "assertConditional", "assertLoop", "assertWhile", "assertExpressionWrapper", "assertFor", "assertForXStatement", "assertFunction", "assertFunctionParent", "assertPureish", "assertDeclaration", "assertPatternLike", "assertLVal", "assertTSEntityName", "assertLiteral", "assertImmutable", "assertUserWhitespacable", "assertMethod", "assertObjectMember", "assertProperty", "assertUnaryLike", "assertPattern", "assertClass", "assertImportOrExportDeclaration", "assertExportDeclaration", "assertModuleSpecifier", "assertAccessor", "assertPrivate", "assertFlow", "assertFlowType", "assertFlowBaseAnnotation", "assertFlowDeclaration", "assertFlowPredicate", "assertEnumBody", "assertEnumMember", "assertJSX", "assertMiscellaneous", "assertTypeScript", "assertTSTypeElement", "assertTSType", "assertTSBaseType", "assertNumberLiteral", "deprecationWarning", "assertRegexLiteral", "assertRestProperty", "assertSpreadProperty", "assertModuleDeclaration", "_index", "require", "_default", "exports", "default", "createTypeAnnotationBasedOnTypeof", "type", "stringTypeAnnotation", "numberTypeAnnotation", "voidTypeAnnotation", "booleanTypeAnnotation", "genericTypeAnnotation", "identifier", "anyTypeAnnotation", "Error", "_index", "require", "getQualifiedName", "node", "isIdentifier", "name", "id", "qualification", "removeTypeDuplicates", "nodesIn", "nodes", "Array", "from", "generics", "Map", "bases", "typeGroups", "Set", "types", "i", "length", "includes", "isAnyTypeAnnotation", "isFlowBaseAnnotation", "set", "type", "isUnionTypeAnnotation", "has", "push", "add", "isGenericTypeAnnotation", "existing", "get", "typeParameters", "params", "baseType", "genericName", "_index", "require", "_removeTypeDuplicates", "createFlowUnionType", "types", "flattened", "removeTypeDuplicates", "length", "unionTypeAnnotation", "_index", "require", "getQualifiedName", "node", "isIdentifier", "name", "right", "left", "removeTypeDuplicates", "nodesIn", "nodes", "Array", "from", "generics", "Map", "bases", "typeGroups", "Set", "types", "i", "length", "includes", "isTSAnyKeyword", "isTSBaseType", "set", "type", "isTSUnionType", "has", "push", "add", "isTSTypeReference", "typeParameters", "typeName", "existing", "get", "params", "baseType", "genericName", "_index", "require", "_removeTypeDuplicates", "_index2", "createTSUnionType", "typeAnnotations", "types", "map", "type", "isTSTypeAnnotation", "typeAnnotation", "flattened", "removeTypeDuplicates", "length", "tsUnionType", "_index", "require", "_index", "require", "buildUndefinedNode", "unaryExpression", "numericLiteral", "_index", "require", "_index2", "hasOwn", "Function", "call", "bind", "Object", "prototype", "hasOwnProperty", "cloneIfNode", "obj", "deep", "withoutLoc", "commentsCache", "type", "cloneNodeInternal", "cloneIfNodeOrArray", "Array", "isArray", "map", "node", "cloneNode", "Map", "newNode", "isIdentifier", "name", "optional", "typeAnnotation", "decorators", "NODE_FIELDS", "Error", "field", "keys", "isFile", "maybeCloneComments", "comments", "loc", "leadingComments", "innerComments", "trailingComments", "extra", "assign", "comment", "cache", "get", "value", "ret", "set", "_cloneNode", "require", "clone", "node", "cloneNode", "_cloneNode", "require", "cloneDeep", "node", "cloneNode", "_cloneNode", "require", "cloneDeepWithoutLoc", "node", "cloneNode", "_cloneNode", "require", "cloneWithoutLoc", "node", "cloneNode", "addComments", "node", "type", "comments", "key", "concat", "push", "_addComments", "require", "addComment", "node", "type", "content", "line", "addComments", "value", "inherit", "key", "child", "parent", "Array", "from", "Set", "concat", "filter", "Boolean", "_inherit", "require", "inheritInnerComments", "child", "parent", "inherit", "_inherit", "require", "inheritLeadingComments", "child", "parent", "inherit", "_inherit", "require", "inheritTrailingComments", "child", "parent", "inherit", "_inheritTrailingComments", "require", "_inheritLeadingComments", "_inheritInnerComments", "inheritsComments", "child", "parent", "inheritTrailingComments", "inheritLeadingComments", "inheritInnerComments", "_index", "require", "removeComments", "node", "COMMENT_KEYS", "forEach", "key", "_index", "require", "STANDARDIZED_TYPES", "exports", "FLIPPED_ALIAS_KEYS", "EXPRESSION_TYPES", "BINARY_TYPES", "SCOPABLE_TYPES", "BLOCKPARENT_TYPES", "BLOCK_TYPES", "STATEMENT_TYPES", "TERMINATORLESS_TYPES", "COMPLETIONSTATEMENT_TYPES", "CONDITIONAL_TYPES", "LOOP_TYPES", "WHILE_TYPES", "EXPRESSIONWRAPPER_TYPES", "FOR_TYPES", "FORXSTATEMENT_TYPES", "FUNCTION_TYPES", "FUNCTIONPARENT_TYPES", "PUREISH_TYPES", "DECLARATION_TYPES", "PATTERNLIKE_TYPES", "LVAL_TYPES", "TSENTITYNAME_TYPES", "LITERAL_TYPES", "IMMUTABLE_TYPES", "USERWHITESPACABLE_TYPES", "METHOD_TYPES", "OBJECTMEMBER_TYPES", "PROPERTY_TYPES", "UNARYLIKE_TYPES", "PATTERN_TYPES", "CLASS_TYPES", "IMPORTOREXPORTDECLARATION_TYPES", "EXPORTDECLARATION_TYPES", "MODULESPECIFIER_TYPES", "ACCESSOR_TYPES", "PRIVATE_TYPES", "FLOW_TYPES", "FLOWTYPE_TYPES", "FLOWBASEANNOTATION_TYPES", "FLOWDECLARATION_TYPES", "FLOWPREDICATE_TYPES", "ENUMBODY_TYPES", "ENUMMEMBER_TYPES", "JSX_TYPES", "MISCELLANEOUS_TYPES", "TYPESCRIPT_TYPES", "TSTYPEELEMENT_TYPES", "TSTYPE_TYPES", "TSBASETYPE_TYPES", "MODULEDECLARATION_TYPES", "_index", "require", "_index2", "toBlock", "node", "parent", "isBlockStatement", "blockNodes", "isEmptyStatement", "isStatement", "isFunction", "returnStatement", "expressionStatement", "blockStatement", "_toBlock", "require", "ensureBlock", "node", "key", "result", "toBlock", "_isValidIdentifier", "require", "_helperValidatorIdentifier", "toIdentifier", "input", "name", "c", "isIdentifierChar", "codePointAt", "replace", "match", "toUpperCase", "isValidIdentifier", "_toIdentifier", "require", "toBindingIdentifierName", "name", "toIdentifier", "_index", "require", "_index2", "toComputedKey", "node", "key", "property", "computed", "isIdentifier", "stringLiteral", "name", "_index", "require", "_default", "exports", "default", "toExpression", "node", "isExpressionStatement", "expression", "isExpression", "isClass", "type", "isFunction", "Error", "_index", "require", "traverseFast", "node", "enter", "opts", "keys", "VISITOR_KEYS", "type", "key", "subNode", "Array", "isArray", "_index", "require", "CLEAR_KEYS", "CLEAR_KEYS_PLUS_COMMENTS", "COMMENT_KEYS", "removeProperties", "node", "opts", "map", "preserveComments", "key", "undefined", "Object", "keys", "symbols", "getOwnPropertySymbols", "sym", "_traverseFast", "require", "_removeProperties", "removePropertiesDeep", "tree", "opts", "traverseFast", "removeProperties", "_index", "require", "_cloneNode", "_removePropertiesDeep", "toKeyAlias", "node", "key", "alias", "kind", "increment", "isIdentifier", "name", "isStringLiteral", "JSON", "stringify", "value", "removePropertiesDeep", "cloneNode", "computed", "static", "uid", "Number", "MAX_SAFE_INTEGER", "_index", "require", "_index2", "_default", "exports", "default", "toStatement", "node", "ignore", "isStatement", "mustHaveId", "newType", "isClass", "isFunction", "isAssignmentExpression", "expressionStatement", "id", "Error", "type", "_isValidIdentifier", "require", "_index", "_default", "exports", "default", "valueToNode", "objectToString", "Function", "call", "bind", "Object", "prototype", "toString", "isRegExp", "value", "isPlainObject", "proto", "getPrototypeOf", "undefined", "identifier", "booleanLiteral", "nullLiteral", "stringLiteral", "result", "Number", "isFinite", "numericLiteral", "Math", "abs", "numerator", "isNaN", "binaryExpression", "is", "unaryExpression", "pattern", "source", "flags", "exec", "regExpLiteral", "Array", "isArray", "arrayExpression", "map", "props", "key", "keys", "nodeKey", "isValidIdentifier", "push", "objectProperty", "objectExpression", "Error", "_index", "require", "appendToMemberExpression", "member", "append", "computed", "object", "memberExpression", "property", "_index", "require", "_inheritsComments", "inherits", "child", "parent", "key", "INHERIT_KEYS", "optional", "Object", "keys", "force", "inheritsComments", "_index", "require", "_index2", "prependToMemberExpression", "member", "prepend", "isSuper", "object", "Error", "memberExpression", "getAssignmentIdentifiers", "node", "search", "concat", "ids", "Object", "create", "length", "id", "pop", "type", "push", "elements", "left", "properties", "value", "argument", "operator", "name", "_index", "require", "getBindingIdentifiers", "node", "duplicates", "outerOnly", "newBindingsOnly", "search", "concat", "ids", "Object", "create", "length", "id", "shift", "isAssignmentExpression", "isUnaryExpression", "isUpdateExpression", "isIdentifier", "_ids", "name", "push", "isExportDeclaration", "isExportAllDeclaration", "isDeclaration", "declaration", "isFunctionDeclaration", "isFunctionExpression", "keys", "type", "i", "key", "nodes", "Array", "isArray", "DeclareClass", "DeclareFunction", "DeclareModule", "DeclareVariable", "DeclareInterface", "DeclareTypeAlias", "DeclareOpaqueType", "InterfaceDeclaration", "TypeAlias", "OpaqueType", "CatchClause", "LabeledStatement", "UnaryExpression", "AssignmentExpression", "ImportSpecifier", "ImportNamespaceSpecifier", "ImportDefaultSpecifier", "ImportDeclaration", "ExportSpecifier", "ExportNamespaceSpecifier", "ExportDefaultSpecifier", "FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression", "ObjectMethod", "ClassMethod", "ClassPrivateMethod", "ForInStatement", "ForOfStatement", "ClassDeclaration", "ClassExpression", "RestElement", "UpdateExpression", "ObjectProperty", "AssignmentPattern", "ArrayPattern", "ObjectPattern", "VariableDeclaration", "VariableDeclarator", "_getBindingIdentifiers", "require", "_default", "exports", "default", "getOuterBindingIdentifiers", "node", "duplicates", "getBindingIdentifiers", "_index", "require", "getNameFromLiteralId", "id", "isNullLiteral", "isRegExpLiteral", "pattern", "flags", "isTemplateLiteral", "quasis", "map", "quasi", "value", "raw", "join", "undefined", "String", "getObjectMemberKey", "node", "computed", "isLiteral", "key", "getFunctionName", "parent", "name", "originalNode", "prefix", "isObjectProperty", "isObjectMethod", "isClassMethod", "kind", "isVariableDeclarator", "init", "isAssignmentExpression", "operator", "right", "left", "isIdentifier", "isPrivateName", "_index", "require", "traverse", "node", "handlers", "state", "enter", "exit", "traverseSimpleImpl", "ancestors", "keys", "VISITOR_KEYS", "type", "key", "subNode", "Array", "isArray", "i", "length", "child", "push", "index", "pop", "_getBindingIdentifiers", "require", "isBinding", "node", "parent", "grandparent", "type", "keys", "getBindingIdentifiers", "i", "length", "key", "val", "Array", "isArray", "includes", "_index", "require", "_index2", "isLet", "node", "isVariableDeclaration", "kind", "BLOCK_SCOPED_SYMBOL", "_index", "require", "_isLet", "isBlockScoped", "node", "isFunctionDeclaration", "isClassDeclaration", "isLet", "_isType", "require", "_index", "isImmutable", "node", "isType", "type", "isIdentifier", "name", "_index", "require", "isNodesEquivalent", "a", "b", "type", "fields", "Object", "keys", "NODE_FIELDS", "visitorKeys", "VISITOR_KEYS", "field", "val_a", "val_b", "Array", "isArray", "length", "i", "includes", "key", "isReferenced", "node", "parent", "grandparent", "type", "property", "computed", "object", "init", "body", "key", "superClass", "right", "source", "local", "id", "_index", "require", "isScope", "node", "parent", "isBlockStatement", "isFunction", "isCatchClause", "isPattern", "isScopable", "_index", "require", "isSpecifierDefault", "specifier", "isImportDefaultSpecifier", "isIdentifier", "imported", "exported", "name", "_isValidIdentifier", "require", "RESERVED_WORDS_ES3_ONLY", "Set", "isValidES3Identifier", "name", "isValidIdentifier", "has", "_index", "require", "_index2", "isVar", "node", "isVariableDeclaration", "kind", "BLOCK_SCOPED_SYMBOL", "_getBindingIdentifiers", "require", "_index", "_index2", "_productions", "_cloneNode", "gatherSequenceExpressions", "nodes", "declars", "exprs", "ensureLastUndefined", "node", "isEmptyStatement", "isExpression", "push", "isExpressionStatement", "expression", "isVariableDeclaration", "kind", "declar", "declarations", "bindings", "getBindingIdentifiers", "key", "Object", "keys", "id", "cloneNode", "init", "assignmentExpression", "isIfStatement", "consequent", "buildUndefinedNode", "alternate", "conditionalExpression", "test", "isBlockStatement", "body", "indexOf", "length", "sequenceExpression", "_gatherSequenceExpressions", "require", "toSequenceExpression", "nodes", "scope", "length", "declars", "result", "gatherSequenceExpressions", "declar", "push", "_isReactComponent", "require", "_isCompatTag", "_buildChildren", "_assertNode", "_index", "Object", "keys", "forEach", "key", "prototype", "hasOwnProperty", "call", "_exportNames", "exports", "defineProperty", "enumerable", "get", "_createTypeAnnotationBasedOnTypeof", "_createFlowUnionType", "_createTSUnionType", "_index2", "_uppercase", "_productions", "_cloneNode", "_clone", "_cloneDeep", "_cloneDeepWithoutLoc", "_cloneWithoutLoc", "_addComment", "_addComments", "_inheritInnerComments", "_inheritLeadingComments", "_inheritsComments", "_inheritTrailingComments", "_removeComments", "_index3", "_index4", "_ensureBlock", "_toBindingIdentifierName", "_toBlock", "_toComputedKey", "_toExpression", "_toIdentifier", "_toKeyAlias", "_toStatement", "_valueToNode", "_index5", "_appendToMemberExpression", "_inherits", "_prependToMemberExpression", "_removeProperties", "_removePropertiesDeep", "_removeTypeDuplicates", "_getAssignmentIdentifiers", "_getBindingIdentifiers", "_getOuterBindingIdentifiers", "_getFunctionName", "_traverse", "_traverseFast", "_shallowEqual", "_is", "_isBinding", "_isBlockScoped", "_isImmutable", "_isLet", "_isNode", "_isNodesEquivalent", "_isPlaceholderType", "_isReferenced", "_isScope", "_isSpecifierDefault", "_isType", "_isValidES3Identifier", "_isValidIdentifier", "_isVar", "_matchesPattern", "_validate", "_buildMatchMemberExpression", "_index6", "_deprecationWarning", "react", "isReactComponent", "isCompatTag", "buildChildren", "toSequenceExpression", "default", "process", "env", "BABEL_TYPES_8_BREAKING", "console", "warn", "_assert", "require", "_t", "callExpression", "cloneNode", "expressionStatement", "identifier", "importDeclaration", "importDefaultSpecifier", "importNamespaceSpecifier", "importSpecifier", "memberExpression", "stringLiteral", "variableDeclaration", "variableDeclarator", "ImportBuilder", "constructor", "importedSource", "scope", "hub", "_statements", "_resultName", "_importedSource", "_scope", "_hub", "done", "statements", "resultName", "import", "push", "namespace", "name", "local", "generateUidIdentifier", "statement", "length", "assert", "type", "specifiers", "default", "id", "named", "importName", "var", "expression", "defaultInterop", "_interop", "addHelper", "wildcardInterop", "callee", "declarations", "init", "fail", "prop", "read", "exports", "isModule", "path", "node", "sourceType", "_assert", "require", "_t", "_importBuilder", "_isModule", "identifier", "importSpecifier", "numericLiteral", "sequenceExpression", "isImportDeclaration", "ImportInjector", "constructor", "path", "importedSource", "opts", "_defaultOpts", "importedType", "importedInterop", "importingInterop", "ensureLiveReference", "ensureNoContext", "importPosition", "programPath", "find", "p", "isProgram", "_programPath", "_programScope", "scope", "_hub", "hub", "_applyDefaults", "addDefault", "importedSourceIn", "addNamed", "importName", "assert", "_generateImport", "addNamespace", "addSideEffect", "isInit", "newOpts", "Object", "assign", "nameHint", "undefined", "blockHoist", "isDefault", "isNamed", "isNamespace", "name", "isMod", "isModule", "isModuleForNode", "isModuleForBabel", "Error", "builder", "ImportBuilder", "import", "namespace", "named", "es6Default", "default", "var", "wildcardInterop", "defaultInterop", "read", "prop", "statements", "resultName", "done", "_insertStatements", "type", "_insertStatementsAfter", "_insertStatementsBefore", "unshiftContainer", "length", "isValueImport", "firstImportDecl", "get", "node", "source", "value", "maybeAppendImportSpecifiers", "forEach", "_blockHoist", "targetPath", "val", "Number", "isFinite", "insertBefore", "statementsSet", "Set", "importDeclarations", "Map", "statement", "has", "set", "push", "lastImportPath", "bodyStmt", "newImports", "decl", "delete", "size", "insertAfter", "Array", "from", "exports", "importKind", "hasNamespaceImport", "specifiers", "hasDefaultImport", "target", "local", "unshift", "shift", "_importInjector", "require", "_isModule", "addDefault", "path", "importedSource", "opts", "ImportInjector", "addNamed", "name", "addNamespace", "addSideEffect", "stack", "parse", "getNodeModulesDirs", "paths", "opts", "concatty", "slicy", "Empty", "require_core", "maybeRealpath", "defaultReadPackage", "getPackageCandidates", "resolve", "err", "basedir", "pkg", "x", "callback", "cb", "exts", "isdir", "onfile", "require_core", "require_core", "core", "maybeRealpathSync", "defaultReadPackageSync", "getPackageCandidates", "x", "m", "n", "stack", "require_util", "errorEx", "LinesAndColumns", "string", "index", "isColorSupported", "process", "env", "FORCE_COLOR", "picocolors", "compose", "f", "g", "v", "buildDefs", "colors", "keyword", "cyan", "capitalized", "yellow", "jsxIdentifier", "punctuator", "number", "magenta", "string", "green", "regex", "comment", "gray", "invalid", "white", "bgRed", "bold", "gutter", "marker", "red", "message", "reset", "defsOn", "createColors", "defsOff", "getDefs", "enabled", "sometimesKeywords", "Set", "NEWLINE", "BRACKET", "tokenize", "JSX_TAG", "getTokenType", "token", "offset", "text", "type", "isKeyword", "value", "isStrictReservedWord", "has", "test", "slice", "toLowerCase", "match", "jsTokens", "default", "exec", "matchToToken", "index", "highlight", "defs", "highlighted", "split", "map", "str", "join", "deprecationWarningShown", "getMarkerLines", "loc", "source", "opts", "startLoc", "Object", "assign", "column", "line", "start", "endLoc", "end", "linesAbove", "linesBelow", "startLine", "startColumn", "endLine", "endColumn", "Math", "max", "min", "length", "lineDiff", "markerLines", "i", "lineNumber", "sourceLength", "codeFrameColumns", "rawLines", "shouldHighlight", "forceColor", "highlightCode", "lines", "hasColumns", "numberMaxWidth", "String", "highlightedLines", "frame", "paddedNumber", "hasMarker", "lastMarkerLine", "markerLine", "Array", "isArray", "markerSpacing", "replace", "numberOfMarkers", "repeat", "colNumber", "emitWarning", "deprecationError", "Error", "name", "console", "warn", "location", "string", "index", "obj", "value", "_getPrototypeOf", "o", "_setPrototypeOf", "p", "_construct", "Parent", "args", "Class", "_wrapNativeSuper", "_get", "target", "property", "receiver", "_unsupportedIterableToArray", "_arrayLikeToArray", "Range", "Node", "YAMLError", "YAMLReferenceError", "YAMLSemanticError", "YAMLSyntaxError", "YAMLWarning", "PlainValue", "parse", "offset", "BlankLine", "parse", "CollectionItem", "value", "Comment", "Collection", "Directive", "Document", "parseDirectives", "parseContents", "Alias", "BlockValue", "FlowCollection", "QuoteDouble", "QuoteSingle", "ParseContext", "value", "res", "tags", "resolve", "json", "_stringify", "Collection", "Alias", "map", "warn", "seq", "Node", "Scalar", "isEmptyPath", "toJSON", "stringify", "nodes", "str", "YAMLSeq", "set", "stringifyKey", "Pair", "getAliasCount", "YAMLMap", "Type", "Merge", "consumeMoreIndentedLines", "getFoldOptions", "containsDocumentMarker", "isCollectionItem", "valueHasPairComment", "seq", "pairs", "value", "omap", "map", "set", "YAMLOMap", "identify", "YAMLSet", "toJSON", "parseSexagesimal", "n", "stringifySexagesimal", "resolve", "stringify", "map", "value", "seq", "intResolve", "intIdentify", "tags", "createNode", "Node", "Alias", "schemas", "identify", "stringify", "resolve", "stringifyJSON", "boolStringify", "sortMapEntriesByKey", "Schema", "p", "tags", "Alias", "Node", "Collection", "copyTagPrefix", "createNode", "value", "Document", "parse", "stringify", "Anchors", "map", "visit", "listTagNames", "set", "warn", "importFresh", "loadJs", "filepath", "undefined", "require", "result", "parseJson", "loadJson", "content", "error", "message", "yaml", "loadYaml", "parse", "prettyErrors", "loaders", "getPropertyByPath", "source", "path", "Object", "prototype", "hasOwnProperty", "call", "parsedPath", "split", "reduce", "previous", "key", "undefined", "ExplorerBase", "constructor", "options", "cache", "loadCache", "Map", "searchCache", "config", "validateConfig", "clearLoadCache", "clear", "clearSearchCache", "clearCaches", "searchPlaces", "forEach", "place", "loaderKey", "path", "extname", "loader", "loaders", "Error", "getExtensionDescription", "shouldSearchStopWithResult", "result", "isEmpty", "ignoreEmptySearchPlaces", "nextDirectoryToSearch", "currentDir", "currentResult", "nextDir", "nextDirUp", "stopDir", "loadPackageProp", "filepath", "content", "parsedContent", "loadJson", "packagePropValue", "packageProp", "getLoaderEntryForFile", "basename", "bind", "loadedContentToCosmiconfigResult", "loadedContent", "undefined", "validateFilePath", "dir", "dirname", "ext", "fsReadFileAsync", "pathname", "encoding", "Promise", "resolve", "reject", "fs", "readFile", "error", "contents", "filepath", "options", "throwNotFound", "content", "code", "readFileSync", "cacheWrapper", "cache", "key", "fn", "cached", "get", "undefined", "result", "set", "cacheWrapperSync", "getDirectory", "filepath", "filePathIsDirectory", "directory", "path", "dirname", "getDirectorySync", "Explorer", "ExplorerBase", "constructor", "options", "search", "searchFrom", "process", "cwd", "startDirectory", "result", "searchFromDirectory", "dir", "absoluteDir", "path", "resolve", "run", "searchDirectory", "nextDir", "nextDirectoryToSearch", "transformResult", "config", "transform", "searchCache", "place", "searchPlaces", "placeResult", "loadSearchPlace", "shouldSearchStopWithResult", "filepath", "join", "fileContents", "createCosmiconfigResult", "loadFileContent", "content", "trim", "undefined", "loader", "getLoaderEntryForFile", "loaderResult", "fileContent", "loadedContentToCosmiconfigResult", "load", "validateFilePath", "absoluteFilePath", "runLoad", "throwNotFound", "loadCache", "ExplorerSync", "ExplorerBase", "constructor", "options", "searchSync", "searchFrom", "process", "cwd", "startDirectory", "result", "searchFromDirectorySync", "dir", "absoluteDir", "path", "resolve", "run", "searchDirectorySync", "nextDir", "nextDirectoryToSearch", "transformResult", "config", "transform", "searchCache", "place", "searchPlaces", "placeResult", "loadSearchPlaceSync", "shouldSearchStopWithResult", "filepath", "join", "content", "createCosmiconfigResultSync", "loadFileContentSync", "trim", "undefined", "loader", "getLoaderEntryForFile", "loaderResult", "fileContent", "loadedContentToCosmiconfigResult", "loadSync", "validateFilePath", "absoluteFilePath", "runLoadSync", "throwNotFound", "cosmiconfigResult", "loadCache", "cosmiconfig", "moduleName", "options", "normalizedOptions", "normalizeOptions", "explorer", "Explorer", "search", "bind", "load", "clearLoadCache", "clearSearchCache", "clearCaches", "cosmiconfigSync", "explorerSync", "ExplorerSync", "searchSync", "loadSync", "defaultLoaders", "Object", "freeze", "loaders", "loadJs", "loadJson", "loadYaml", "noExt", "identity", "x", "defaults", "packageProp", "searchPlaces", "ignoreEmptySearchPlaces", "stopDir", "os", "homedir", "cache", "transform", "require_dist", "resolve", "createMacro", "nodePath", "convert", "value", "index", "transformers", "macros", "options", "defaultOptions", "_loop", "sanitizeLabelPart", "getObjPropertyLikeName", "hashArray", "findRoot", "escapeRegexp", "normalizePath", "haveSameLocation", "isAutoInsertedRule", "toInputTree", "stringifyTree", "interleave", "appendStringReturningExpressionToArguments", "joinStringLiterals", "transformExpressionWithStyles", "getKnownProperties", "createObjectSpreadLike", "getStyledOptions", "isAlreadyTranspiled", "createEmotionTransformer", "createEmotionMacro", "getReferencedSpecifier", "styledTransformer", "getStyledIdentifier", "createStyledMacro", "transformCssCallExpression", "transformCsslessArrayExpression", "transformCsslessObjectExpression", "cssTransformer", "globalTransformer", "getCssExport"]
}
